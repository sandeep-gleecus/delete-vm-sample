using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Linq;
using System.ServiceModel;
using System.Web;
using System.Web.Security;
using Inflectra.SpiraTest.Business;
using Inflectra.SpiraTest.Common;
using Inflectra.SpiraTest.DataModel;
using Inflectra.SpiraTest.Web.Classes;
using Inflectra.SpiraTest.Web.Services.v6_0.DataObjects;

namespace Inflectra.SpiraTest.Web.Services.v6_0
{
	/// <summary>This web service enables the import and export of data to/from the system. Each function is prefixed by the
	/// area of the system that it relates to. For example, the Requirement_Retrieve function relates to the
	/// Requirements module.</summary>
	/// <remarks>This API is available for all installations v6.0 or greater. There are older APIs available
	/// for older versions of the system (v4.0, v3.0, v2.2, v1.5.2, v1.2)</remarks>
	/// <version>v6.0</version>
	public class SoapService : SoapServiceBase, ISoapService
	{
		private const string CLASS_NAME = "Inflectra.SpiraTest.Web.Services.v6_0.SoapService::";

		#region Authentication Methods

		/// <summary>
		/// Authenticates against the server. Need to call before using other methods.
		/// This overload allows you to specify the name of the plug-in calling the API
		/// </summary>
		/// <param name="userName">The username of the user</param>
		/// <param name="password">The unhashed password of the user</param>
		/// <param name="plugInName">The name of the plug-in</param>
		/// <returns>The credentials object if successful, NULL if not</returns>
		/// <remarks>
		/// 1) Also checks to make sure they have enough connection licenses
		/// 2) Will fallback to using the API Key if the user is OAUTH (similar to how the v5.0 API works)
		/// </remarks>
		/// <example>
		/// RemoteCredentials credentials = Connection_Authenticate1("fredbloggs", "PleaseChange", "My Integration App 1");
		/// if (credentials == null) { MessageBox.Show("Incorrect login/password"); }
		/// else { MessageBox.Show("You have logged in as User ID: " + credentials.UserId); }
		/// </example>
		public RemoteCredentials Connection_Authenticate1(string userName, string password, string plugInName)
		{
			const string METHOD_NAME = "Connection_Authenticate1";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Create and populate credentials object
			RemoteCredentials credentials = new RemoteCredentials();
			credentials.UserName = userName;
			credentials.Password = password;
			credentials.PlugInName = plugInName;

			//Authenticate the user based on passed-in credentials
			//The call will populate the user id and admin flag
			bool validUser = IsAuthenticated(credentials);

			//If the password check does not return, lets see if the password is a GUID and test it.
			//This may be because the user uses OAUTH
			Guid passGuid;
			if (!validUser && Guid.TryParse(password, out passGuid))
			{
				SpiraMembershipProvider prov = (SpiraMembershipProvider)Membership.Provider;
				if (prov != null)
				{
					validUser = prov.ValidateUserByRssToken(userName, password, true, true);
				}
			}

			//If not valid, null out the credentials
			if (!validUser)
			{
				//Signify failure
				credentials = null;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);

			return credentials;
		}

		/// <summary>
		/// Authenticates against the server. Need to call before using other methods.
		/// This overload allows you to use the same API Key / RSS Token as the REST Service
		/// </summary>
		/// <param name="userName">The username of the user</param>
		/// <param name="apiKey">The user's API Key / RSS Token</param>
		/// <param name="plugInName">The name of the plug-in</param>
		/// <returns>The credentials object if successful, NULL if not</returns>
		/// <remarks>Also checks to make sure they have enough connection licenses</remarks>
		/// <example>
		/// RemoteCredentials credentials = Connection_Authenticate2("fredbloggs", "{03D4B256-C10F-4BAC-86F7-10E817C9CC84}", "My Integration App 1");
		/// if (credentials == null) { MessageBox.Show("Incorrect login/api key"); }
		/// else { MessageBox.Show("You have logged in as User ID: " + credentials.UserId); }
		/// </example>
		public RemoteCredentials Connection_Authenticate2(string userName, string apiKey, string plugInName)
		{
			const string METHOD_NAME = "Connection_Authenticate1";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Create and populate credentials object
			RemoteCredentials credentials = new RemoteCredentials();
			credentials.UserName = userName;
			credentials.ApiKey = apiKey;
			credentials.PlugInName = plugInName;

			//Authenticate the user based on passed-in credentials
			//The call will populate the user id and admin flag
			bool validUser = IsAuthenticated(credentials);

			//If not valid, null out the credentials
			if (!validUser)
			{
				//Signify failure
				credentials = null;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);

			return credentials;
		}

		#endregion

		#region System Methods

		/// <summary>
		/// Retrieves the current date-time on the server converted into UTC
		/// </summary>
		/// <returns>The current date-time in UTC</returns>
		public DateTime System_GetServerDateTime()
		{
			//Returns the current date-time on the server in UTC timezone
			return DateTime.UtcNow;
		}

		/// <summary>
		/// Gets the base URL of the website that the system is running under. Used for notifications and exported artifacts
		/// </summary>
		/// <returns>The URL</returns>
		public string System_GetWebServerUrl()
		{
			return ConfigurationSettings.Default.General_WebServerUrl;
		}

		/// <summary>
		/// Gets the brand name of the product installed
		/// </summary>
		/// <returns>The product name</returns>
		public string System_GetProductName()
		{
			return ConfigurationSettings.Default.License_ProductType;
		}

		/// <summary>
		/// Executes any scheduled notification events
		/// </summary>
		public void System_ProcessNotifications()
		{
			//Do Nothing
		}

		/// <summary>
		/// Returns the application-relative URL to a particular artifact in the system
		/// </summary>
		/// <param name="navigationLinkId">
		/// The id of the type of page to return. Possible values are:
		/// None = -1,
		/// Login = -2,
		/// MyPage = -3,
		/// ProjectHome = -4,
		/// Requirements = 1,
		/// TestCases = 2,
		/// Incidents = 3,
		/// Releases = 4,
		/// Reports = -5,
		/// TestSets = 8,
		/// Administration = -6,
		/// ErrorPage = -7,
		/// MyProfile = -8,
		/// Tasks = 6,
		/// Iterations = -9,
		/// Documents = -10,
		/// Resources = -11,
		/// ProjectGroupHome = -12,
		/// SourceCode = -13,
		/// TestRuns = 5,
		/// TestSteps = 7,
		/// Attachment = -14,
		/// TestStepRuns = -15,
		/// TestExecute = -16
		/// </param>
		/// <param name="projectId">The project ID of the artifact. Ignored if not needed. Specifying -1 will not include ProjectPath, specifying -2 will insert the token {proj} for the ProjectID.</param>
		/// <param name="artifactId">The ID of the artifact. Ignored if not needed, specifying -2 will insert the token {art} for the ArtifactID</param>
		/// <param name="tabName">The name of the tab or extra item in the URL. Null if not specified.</param>
		/// <returns>String of the new URL. It includes the ~ character to represent the application root</returns>
		public string System_GetArtifactUrl(int navigationLinkId, int projectId, int artifactId, string tabName)
		{
			const string METHOD_NAME = "System_GetArtifactUrl";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Get the appropriate rewriter Url
			string serverUrl = UrlRewriterModule.RetrieveRewriterURL((UrlRoots.NavigationLinkEnum)navigationLinkId, projectId, artifactId, tabName);

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			return serverUrl;
		}

		/// <summary>
		/// Retrieves the version number of the current installation.
		/// </summary>
		/// <returns>A RemoteVersion data object.</returns>
		public RemoteVersion System_GetProductVersion()
		{
			const string METHOD_NAME = "System_GetProductVersion";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			RemoteVersion returnValues = new RemoteVersion();
			returnValues.Version = GlobalFunctions.DISPLAY_SOFTWARE_VERSION + "." + GlobalFunctions.DISPLAY_SOFTWARE_VERSION_BUILD;
			returnValues.Patch = GlobalFunctions.DISPLAY_SOFTWARE_VERSION_BUILD;

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);

			return returnValues;
		}

		/// <summary>
		/// Returns the current configuration settings for the installation.
		/// </summary>
		/// <param name="credentials">Credentials for accessing the API</param>
		/// <returns>List of remote settings objects (name, value)</returns>
		/// <remarks>
		/// The user counts are returned even if not authenticated, since needed by the hosting monitoring service
		/// </remarks>
		public List<RemoteSetting> System_GetSettings(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "System_GetSettings";

			try
			{
				List<RemoteSetting> returnList = new List<RemoteSetting>();
				//See if we have an authenticated user
				RemoteSetting remoteSetting;
				if (credentials != null && IsAuthenticated(credentials))
				{
					//Get the list of settings from the provider
					System.Configuration.SettingsPropertyValueCollection settingsPropValueCol = Common.ConfigurationSettings.Default.PropertyValues;

					//Loop through the settings and remove any password ones that may contain sensitive information
					foreach (System.Configuration.SettingsPropertyValue settingsValue in settingsPropValueCol)
					{
						string propName = settingsValue.Name;
						if (!propName.ToLowerInvariant().Contains("password") && !propName.ToLowerInvariant().Contains("passwd"))
						{
							remoteSetting = new RemoteSetting();
							remoteSetting.Name = propName;
							remoteSetting.Value = settingsValue.PropertyValue.ToString();
							returnList.Add(remoteSetting);
						}
					}
				}

				//Also add settings for the count of named users and count of active users
				//This is useful information and also ensures that we're actually hitting the database which
				//is important because this function is also used as a diagnostic that the site is actually
				//up and running

				//Named user count
				List<DataModel.User> users = new UserManager().GetUsers(false);
				remoteSetting = new RemoteSetting();
				remoteSetting.Name = "Users_NamedUserCount";
				remoteSetting.Value = users.Count.ToString();
				returnList.Add(remoteSetting);

				//Active user count
				int activeUserCount = new UserManager().GetNumberOfUsersOnline(5);
				remoteSetting = new RemoteSetting();
				remoteSetting.Name = "Users_ActiveUserCount";
				remoteSetting.Value = activeUserCount.ToString();
				returnList.Add(remoteSetting);

				return returnList;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>Returns the project ID number that the queried artifact exists in.</summary>
		/// <param name="artifactTypeId">The id of the type of artifact we want to retrieve the documents for:
		/// (Requirement = 1,
		///	TestCase = 2,
		/// Incident = 3,
		///	Release = 4,
		///	TestRun = 5,
		///	Task = 6,
		/// TestStep = 7,
		/// TestSet = 8,
		/// AutomationHost = 9,
		/// Risk = 14)</param>
		/// <param name="artifactId">The artifact ID.</param>
		/// <returns>The project #.</returns>
		public int System_GetProjectIdForArtifact(RemoteCredentials credentials, int artifactTypeId, int artifactId)
		{
			const string METHOD_NAME = CLASS_NAME + "System_GetSettings";

			int retNum = 0;

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			try
			{
				Artifact.ArtifactTypeEnum artType = (Artifact.ArtifactTypeEnum)artifactTypeId;
				switch (artType)
				{
					case Artifact.ArtifactTypeEnum.AutomationHost:
						{
							AutomationHostView automationHost = new AutomationManager().RetrieveHostById(artifactId, true);
							if (automationHost != null)
								retNum = automationHost.ProjectId;
							break;
						}

					case Artifact.ArtifactTypeEnum.Incident:
						{
							Incident incident = new IncidentManager().RetrieveById(artifactId, false, true);
							if (incident != null)
								retNum = incident.ProjectId;
							break;
						}

					case Artifact.ArtifactTypeEnum.Release:
						{
							ReleaseView release = new ReleaseManager().RetrieveById2(null, artifactId, true);
							if (release != null)
								retNum = release.ProjectId;
							break;
						}

					case Artifact.ArtifactTypeEnum.Requirement:
						{
							RequirementView requirement = new RequirementManager().RetrieveById2(null, artifactId, true);
							if (requirement != null)
								retNum = requirement.ProjectId;
							break;
						}

					case Artifact.ArtifactTypeEnum.Task:
						{
							Task task = new TaskManager().RetrieveById(artifactId, true);
							if (task != null)
								retNum = task.ProjectId;
							break;
						}

					case Artifact.ArtifactTypeEnum.TestCase:
						{
							TestCaseView testCase = new TestCaseManager().RetrieveById(null, artifactId, true);
							if (testCase != null)
								retNum = testCase.ProjectId;
							break;
						}

					case Artifact.ArtifactTypeEnum.TestRun:
						{
							TestRunView testRun = new TestRunManager().RetrieveById(artifactId);
							if (testRun != null)
								retNum = testRun.ProjectId;
							break;
						}

					case Artifact.ArtifactTypeEnum.TestSet:
						{
							TestSetView testSet = new TestSetManager().RetrieveById(null, artifactId, true);
							if (testSet != null)
								retNum = testSet.ProjectId;
							break;
						}

					case Artifact.ArtifactTypeEnum.TestStep:
						{
							TestStep testStep = new TestCaseManager().RetrieveStepById(null, artifactId);
							if (testStep != null && testStep.TestCase != null)
							{
								retNum = testStep.TestCase.ProjectId;
							}
							break;
						}

					case Artifact.ArtifactTypeEnum.Risk:
						{
							Risk risk = new RiskManager().Risk_RetrieveById(artifactId);
							if (risk != null)
							{
								retNum = risk.ProjectId;
							}
							break;
						}

					default:
						break;
				}
			}
			catch (Exception ex)
			{
				Logger.LogErrorEvent(METHOD_NAME, ex, "Pulling project id for: Type #" + artifactTypeId.ToString() + ", ID #" + artifactId.ToString());
				throw;
			}

			return retNum;
		}

		/// <summary>Retrieves a filtered list of event logs from across the system</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="startingRow">The starting row (starting with 1)</param>
		/// <param name="numberOfRows">The number of rows to retrieve (mad 500)</param>
		/// <param name="remoteSort">The sort to be applied</param>
		/// <param name="remoteFilters">The array of filters</param>
		/// <returns>List of event log entries</returns>
		/// <remarks>Filter on event type using the following ints: Error = 1, Warning = 2, Information = 4, SuccessAudit = 8, FailureAudit = 16</remarks>
		/// <remarks>Sorting</remarks>
		public List<RemoteEvent2> System_RetrieveEvents(RemoteCredentials credentials, int startingRow, int numberOfRows, RemoteSort remoteSort, List<RemoteFilter> remoteFilters)
		{
			const string METHOD_NAME = "System_RetrieveEvents";
			const int MAX_ROWS = 500;

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we can access system event logs
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewSystemWideData);
			}

			//Extract the filters and sort from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);
			string sortExpression = "";
			if (remoteSort != null)
			{
				sortExpression = PopulationFunctions.PopulateSort(remoteSort);
			}

			//Call the business object to actually retrieve the incident dataset
			int totalCount;
			numberOfRows = (numberOfRows > MAX_ROWS) ? MAX_ROWS : numberOfRows;
			EventManager eventManager = new EventManager();
			List<Event> events = eventManager.GetEvents(filters, sortExpression, startingRow - 1, numberOfRows, GlobalFunctions.GetCurrentTimezoneUtcOffset(), out totalCount);

			//Populate the API data object and return
			List<RemoteEvent2> remoteEvents = new List<RemoteEvent2>();
			foreach (Event eventEntry in events)
			{
				//Create and populate the row
				RemoteEvent2 remoteEvent = new RemoteEvent2();
				remoteEvent.Message = eventEntry.Message;
				remoteEvent.Details = eventEntry.Details;
				remoteEvent.EventTypeId = eventEntry.Type.EventTypeId;
				remoteEvent.EventTypeName = eventEntry.Type.Name;
				remoteEvent.EventCategory = eventEntry.EventCategory;
				remoteEvent.EventCode = eventEntry.EventCode;
				remoteEvent.EventTimeUtc = eventEntry.EventTimeUtc;
				remoteEvent.EventId = eventEntry.EventId;
				remoteEvents.Add(remoteEvent);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteEvents;
		}

		#endregion

		#region DataSyncSystem Methods

		/// <summary>
		/// Retrieves a single data sync system by its ID
		/// </summary>
		/// <param name="credentials">Credentials for accessing the API</param>
		/// <param name="dataSyncSystemId">The id of the system</param>
		/// <returns>The data sync system</returns>
		public RemoteDataSyncSystem DataSyncSystem_RetrieveById(RemoteCredentials credentials, int dataSyncSystemId)
		{
			const string METHOD_NAME = "DataSyncSystem_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			else
			{
				//We don't need to know the user as long as it authenticates since it can only
				//read the list of plug-ins which is not secure/private information

				try
				{
					//Get the list of data syncs in the system
					DataMappingManager dataMappingManager = new DataMappingManager();
					DataSyncSystem dataSyncSystem = dataMappingManager.RetrieveDataSyncSystemById(dataSyncSystemId);

					//Populate the API data object and return
					RemoteDataSyncSystem remoteDataSyncSystem = new RemoteDataSyncSystem();
					if (dataSyncSystem != null)
					{
						PopulationFunctions.PopulateDataSyncSystem(remoteDataSyncSystem, dataSyncSystem);
					}

					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();
					return remoteDataSyncSystem;
				}
				catch (Exception exception)
				{
					Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
					Logger.Flush();
					throw ConvertExceptions(exception);
				}
			}
		}

		/// <summary>
		/// Creates a new data sync system entry
		/// </summary>
		/// <param name="credentials">Credentials for accessing the API</param>
		/// <param name="remoteDataSyncSystem">The new data sync system</param>
		/// <returns>The data sync system with its primary key populated</returns>
		/// <remarks>Does not activate the sync for any projects</remarks>
		public RemoteDataSyncSystem DataSyncSystem_Create(RemoteCredentials credentials, RemoteDataSyncSystem remoteDataSyncSystem)
		{
			const string METHOD_NAME = "DataSyncSystem_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are a system admin
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyDataSyncs);
			}

			try
			{
				//Create the new data sync entry
				DataMappingManager dataMappingManager = new DataMappingManager();

				//First see if it already exists, if so, just return that
				DataSyncSystem dataSyncSystem = dataMappingManager.RetrieveDataSyncSystemByName(remoteDataSyncSystem.Name);
				if (dataSyncSystem != null)
				{
					PopulationFunctions.PopulateDataSyncSystem(remoteDataSyncSystem, dataSyncSystem);
				}
				else
				{
					int dataSyncSystemId = dataMappingManager.InsertDataSyncSystem(
						remoteDataSyncSystem.Name,
						remoteDataSyncSystem.DisplayName,
						remoteDataSyncSystem.Description,
						remoteDataSyncSystem.ConnectionString,
						remoteDataSyncSystem.Login,
						remoteDataSyncSystem.Password,
						remoteDataSyncSystem.TimeOffsetHours,
						remoteDataSyncSystem.AutoMapUsers,
						remoteDataSyncSystem.Custom01,
						remoteDataSyncSystem.Custom02,
						remoteDataSyncSystem.Custom03,
						remoteDataSyncSystem.Custom04,
						remoteDataSyncSystem.Custom05
						);

					//Populate the new ID and return the object
					remoteDataSyncSystem.DataSyncSystemId = dataSyncSystemId;
				}
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteDataSyncSystem;
			}
			catch (FaultException)
			{
				throw;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates an existing data sync system entry
		/// </summary>
		/// <param name="credentials">Credentials for accessing the API</param>
		/// <param name="remoteDataSyncSystem">The data sync system to be updated</param>
		public void DataSyncSystem_Update(RemoteCredentials credentials, RemoteDataSyncSystem remoteDataSyncSystem)
		{
			const string METHOD_NAME = "DataSyncSystem_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are a system admin
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyDataSyncs);
			}

			try
			{
				//Call the business object to first retrieve the existing item
				DataMappingManager dataMappingManager = new DataMappingManager();
				DataSyncSystem dataSyncSystem = dataMappingManager.RetrieveDataSyncSystemById(remoteDataSyncSystem.DataSyncSystemId);

				//Actually do the update
				UpdateFunctions.UpdateDataSyncSystem(dataSyncSystem, remoteDataSyncSystem);
				dataMappingManager.UpdateDataSyncSystem(dataSyncSystem);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (FaultException)
			{
				throw;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of data-sync plug-ins that need to be synchronized with
		/// </summary>
		/// <param name="credentials">Credentials for accessing the API</param>
		/// <returns>The list of datasync plug-ins</returns>
		public List<RemoteDataSyncSystem> DataSyncSystem_Retrieve(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "DataSyncSystem_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			else
			{
				//We don't need to know the user as long as it authenticates since it can only
				//read the list of plug-ins which is not secure/private information

				//Get the list of data syncs in the system
				DataMappingManager dataMappingManager = new DataMappingManager();
				List<DataSyncSystem> dataSyncSystems = dataMappingManager.RetrieveDataSyncSystems();

				//Populate the API data object and return
				List<RemoteDataSyncSystem> remoteDataSyncSystems = new List<RemoteDataSyncSystem>();
				foreach (DataSyncSystem dataSyncRow in dataSyncSystems)
				{
					//Create and populate the row
					RemoteDataSyncSystem remoteDataSyncSystem = new RemoteDataSyncSystem();
					PopulationFunctions.PopulateDataSyncSystem(remoteDataSyncSystem, dataSyncRow);
					remoteDataSyncSystems.Add(remoteDataSyncSystem);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteDataSyncSystems;
			}
		}

		/// <summary>
		/// Updates the status for a failed data-sync plug-in
		/// </summary>
		/// <param name="credentials">Credentials for accessing the API</param>
		/// <param name="dataSyncSystemId">The id of the plug-in</param>
		public void DataSyncSystem_SaveRunFailure(RemoteCredentials credentials, int dataSyncSystemId)
		{
			const string METHOD_NAME = "DataSyncSystem_SaveRunFailure";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			DataMappingManager dataMappingManager = new DataMappingManager();
			dataMappingManager.SaveRunFailure(dataSyncSystemId);

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Updates the status for a successful data-sync plug-in
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="dataSyncSystemId">The id of the plug-in</param>
		/// <param name="lastRunDate">The date it last ran</param>
		public void DataSyncSystem_SaveRunSuccess(RemoteCredentials credentials, int dataSyncSystemId, DateTime lastRunDate)
		{
			const string METHOD_NAME = "DataSyncSystem_SaveRunSuccess";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			DataMappingManager dataMappingManager = new DataMappingManager();
			dataMappingManager.SaveRunSuccess(dataSyncSystemId, lastRunDate);

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Updates the status for a data-sync plug-in that executed with warnings
		/// </summary>
		/// <param name="credentials">Credentials for accessing the API</param>
		/// <param name="dataSyncSystemId">The id of the plug-in</param>
		/// <param name="lastRunDate">The date it last ran</param>
		public void DataSyncSystem_SaveRunWarning(RemoteCredentials credentials, int dataSyncSystemId, DateTime lastRunDate)
		{
			const string METHOD_NAME = "DataSyncSystem_SaveRunWarning";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			DataMappingManager dataMappingManager = new DataMappingManager();
			dataMappingManager.SaveRunWarning(dataSyncSystemId, lastRunDate);

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Writes an error/warning event entry to the SpiraTeam database log
		/// </summary>
		/// <param name="credentials">Credentials for accessing the API</param>
		/// <param name="details">The details of the error</param>
		/// <param name="message">The short error message</param>
		/// <param name="eventLogEntryType">The event log entry type</param>
		public void DataSyncSystem_WriteEvent(RemoteCredentials credentials, string message, string details, int eventLogEntryType)
		{
			const string METHOD_NAME = "DataSyncSystem_SaveRunWarning";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			try
			{
				Logger.WriteToDatabase("DataSync::DataSyncSystem_WriteEvent", message, details, (System.Diagnostics.EventLogEntryType)eventLogEntryType, null, Logger.EVENT_CATEGORY_DATA_SYNCHRONIZATION);
			}
			catch
			{
				//Do Nothing
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		#endregion

		#region Component Methods

		/// <summary>
		/// Retrieves a list of all the components in the current project
		/// </summary>
		/// <param name="credentials">The credentials to access the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="activeOnly">Do we want to only include active components</param>
		/// <param name="includeDeleted">Should we include deleted components</param>
		/// <returns>A list of components</returns>
		public List<RemoteComponent> Component_Retrieve(RemoteCredentials credentials, int projectId, bool activeOnly, bool includeDeleted)
		{
			const string METHOD_NAME = "Component_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//As long as we are a member of the project we can view components

			try
			{
				//Call the business object to actually retrieve the components

				//If the component was not found, just return null
				ComponentManager componentManager = new ComponentManager();
				List<Component> components = componentManager.Component_Retrieve(projectId, activeOnly, includeDeleted);
				if (components == null)
				{
					return null;
				}

				//Loop through the components
				List<RemoteComponent> remoteComponents = new List<RemoteComponent>();
				foreach (Component component in components)
				{
					//Populate the API data object and return
					RemoteComponent remoteComponent = new RemoteComponent();
					PopulationFunctions.PopulateComponent(remoteComponent, component);
					remoteComponents.Add(remoteComponent);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteComponents;
			}
			catch (FaultException)
			{
				throw;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a single component by its ID
		/// </summary>
		/// <param name="projectId">The id of the project</param>
		/// <param name="credentials">The credentials for the API</param>
		/// <param name="componentId">The id of the component</param>
		/// <returns>A single component</returns>
		public RemoteComponent Component_RetrieveById(RemoteCredentials credentials, int projectId, int componentId)
		{
			const string METHOD_NAME = "Component_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//As long as we are a member of the project we can view components

			try
			{
				//Call the business object to actually retrieve the component

				//If the component was not found, just return null
				ComponentManager componentManager = new ComponentManager();
				Component component = componentManager.Component_RetrieveById(componentId);
				if (component == null)
				{
					return null;
				}

				//Make sure that the project ids match
				if (component.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteComponent remoteComponent = new RemoteComponent();
				PopulationFunctions.PopulateComponent(remoteComponent, component);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteComponent;
			}
			catch (FaultException)
			{
				throw;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Creates a new component in the current project
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteComponent">The component to be created</param>
		/// <returns>The component with its ID populated</returns>
		public RemoteComponent Component_Create(RemoteCredentials credentials, RemoteComponent remoteComponent)
		{
			const string METHOD_NAME = "Component_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteComponent.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update custom properties (project owner)
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.None, Project.PermissionEnum.ProjectAdmin))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedUpdateComponents);
			}

			try
			{
				//Call the business object to do the insert
				ComponentManager componentManager = new ComponentManager();
				int componentId = componentManager.Component_Insert(
					projectId,
					remoteComponent.Name,
					remoteComponent.IsActive
					);

				//Add the new ID
				remoteComponent.ComponentId = componentId;

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteComponent;
			}
			catch (FaultException)
			{
				throw;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates an existing component in the current project
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteComponent">The component to be updated</param>
		public void Component_Update(RemoteCredentials credentials, RemoteComponent remoteComponent)
		{
			const string METHOD_NAME = "Component_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteComponent.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update custom properties (project owner)
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.None, Project.PermissionEnum.ProjectAdmin))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedUpdateComponents);
			}

			try
			{
				if (!remoteComponent.ComponentId.HasValue)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_ComponentIdNotPopulated);
				}

				//Call the business object to first retrieve the existing item
				ComponentManager componentManager = new ComponentManager();
				Component component = componentManager.Component_RetrieveById(remoteComponent.ComponentId.Value);
				if (component == null)
				{
					//Does not exist
					throw CreateFault("ArtifactNotExists", Resources.Messages.Services_ComponentDoesNotExist);
				}

				//Make sure that the project ids match
				if (component.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Actually do the update
				UpdateFunctions.UpdateComponent(component, remoteComponent);
				componentManager.Component_Update(component);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (FaultException)
			{
				throw;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes a component in the current project
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="componentId">The id of the component</param>
		public void Component_Delete(RemoteCredentials credentials, int projectId, int componentId)
		{
			const string METHOD_NAME = "Component_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to update custom properties (project owner)
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.None, Project.PermissionEnum.ProjectAdmin))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedUpdateComponents);
			}

			try
			{
				//Call the business object to do the delete, but first make sure it belongs to the current project
				ComponentManager componentManager = new ComponentManager();
				Component component = componentManager.Component_RetrieveById(componentId);
				if (component == null)
				{
					//Nothing to delete
					return;
				}

				//Make sure that the project ids match
				if (component.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}
				componentManager.Component_Delete(componentId);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (FaultException)
			{
				throw;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Undeletes a component in the current project
		/// </summary>
		/// <param name="projectId">The id of the project</param>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="componentId">The id of the component</param>
		public void Component_Undelete(RemoteCredentials credentials, int projectId, int componentId)
		{
			const string METHOD_NAME = "Component_Undelete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update custom properties (project owner)
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.None, Project.PermissionEnum.ProjectAdmin))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedUpdateComponents);
			}

			try
			{
				//Call the business object to do the delete, but first make sure it belongs to the current project
				ComponentManager componentManager = new ComponentManager();
				Component component = componentManager.Component_RetrieveById(componentId, true);
				if (component == null)
				{
					//Nothing to un-delete
					return;
				}

				//Make sure that the project ids match
				if (component.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}
				componentManager.Component_Undelete(componentId);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (FaultException)
			{
				throw;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		#endregion

		#region Project Template Methods

		/// <summary>
		/// Creates a new project template
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteProjectTemplate">The new template to create</param>
		/// <param name="existingProjectTemplateId">The id of an existing template to base it off</param>
		/// <returns>The template object with the ID populated</returns>
		public RemoteProjectTemplate ProjectTemplate_Create(RemoteCredentials credentials, RemoteProjectTemplate remoteProjectTemplate, int? existingProjectTemplateId)
		{
			const string METHOD_NAME = "ProjectTemplate_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a project template id specified
			if (remoteProjectTemplate.ProjectTemplateId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_ProjectTemplateIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have permissions to create projects (i.e. is a system admin)
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateProjectTemplates);
			}

			try
			{
				//Now create the project template- either using default values or an existing template
				TemplateManager templateManager = new TemplateManager();
				int projectTemplateId = templateManager.Insert(
					remoteProjectTemplate.Name,
					remoteProjectTemplate.Description,
					remoteProjectTemplate.IsActive,
					existingProjectTemplateId
					);

				//Now populate the project template id onto the object
				remoteProjectTemplate.ProjectTemplateId = projectTemplateId;

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteProjectTemplate;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes an existing project template
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectTemplateId">The id of the template to delete</param>
		public void ProjectTemplate_Delete(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Project_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have permissions to delete project templates (i.e. is a system admin)
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteProjects);
			}

			try
			{
				//Now delete the project template
				TemplateManager templateManager = new TemplateManager();
				templateManager.Delete(userId, projectTemplateId);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();

		}

		/// <summary>
		/// Updates an existing project template
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteProjectTemplate">The template object to update</param>
		public void ProjectTemplate_Update(RemoteCredentials credentials, RemoteProjectTemplate remoteProjectTemplate)
		{
			const string METHOD_NAME = "ProjectTemplate_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have an template id specified
			if (!remoteProjectTemplate.ProjectTemplateId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_ProjectTemplateIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have permissions to update project templates (i.e. is a system admin)
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedUpdateProjectTemplates);
			}

			try
			{
				//First retrieve the existing template
				TemplateManager templateManager = new TemplateManager();
				ProjectTemplate projectTemplate = templateManager.RetrieveById(remoteProjectTemplate.ProjectTemplateId.Value);

				//Make sure we have the data
				if (projectTemplate == null)
				{
					throw CreateFault("ArtifactNotFoundException", Resources.Messages.Services_ArtifactNotFound);
				}

				//Need to extract the data from the API data object update the entity
				UpdateFunctions.UpdateProjectTemplate(projectTemplate, remoteProjectTemplate);

				//Call the business object to actually update the project template
				templateManager.Update(projectTemplate);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of project templates
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <returns>The list of project templates</returns>
		public List<RemoteProjectTemplate> ProjectTemplate_Retrieve(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "ProjectTemplate_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have permissions to create projects (i.e. is a system admin)
			//Once we have template ownership (not part of projects) we can make it more lenient
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateProjects);
			}

			try
			{
				//Get the project template
				TemplateManager templateManager = new TemplateManager();
				List<ProjectTemplate> projectTemplates = templateManager.Retrieve(null, null);

				//Populate the API data object and return
				List<RemoteProjectTemplate> remoteProjectTemplates = new List<RemoteProjectTemplate>();
				foreach (ProjectTemplate projectTemplate in projectTemplates)
				{
					RemoteProjectTemplate remoteProjectTemplate = new RemoteProjectTemplate();
					PopulationFunctions.PopulateProjectTemplate(remoteProjectTemplate, projectTemplate);
					remoteProjectTemplates.Add(remoteProjectTemplate);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteProjectTemplates;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a single project template
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectTemplateId">The id of the template to retrieve</param>
		/// <returns>A single project template</returns>
		public RemoteProjectTemplate ProjectTemplate_RetrieveById(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "ProjectTemplate_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have permissions to create projects (i.e. is a system admin)
			//Once we have template ownership (not part of projects) we can make it more lenient
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateProjects);
			}

			try
			{
				//Get the project template
				TemplateManager templateManager = new TemplateManager();
				ProjectTemplate projectTemplate = templateManager.RetrieveById(projectTemplateId);

				if (projectTemplate == null)
				{
					throw new ArtifactNotExistsException("Unable to locate requested project template - " + projectTemplateId);
				}

				//Populate the API data object and return
				RemoteProjectTemplate remoteProjectTemplate = new RemoteProjectTemplate();
				PopulationFunctions.PopulateProjectTemplate(remoteProjectTemplate, projectTemplate);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteProjectTemplate;
			}
			catch (ArtifactNotExistsException)
			{
				//If the template was not found, just return null
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested project template");
				Logger.Flush();
				return null;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		#endregion

		#region Project Methods

		/// <summary>Retrieves the list of users that are members of the current project</summary>
		/// <returns>List of ProjectUser objects</returns>
		/// <param name="projectId">The id of the project</param>
		/// <param name="credentials">The credentials for accessing the API</param>
		public List<RemoteProjectUser> Project_RetrieveUserMembership(RemoteCredentials credentials, int projectId)
		{
			const string METHOD_NAME = "Project_RetrieveUserMembership";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			try
			{
				//Retrieve the list of users that are members of the current project
				Business.ProjectManager projectManager = new Business.ProjectManager();
				List<ProjectUser> projectUsers = projectManager.RetrieveUserMembershipById(projectId);

				//Populate the API data object and return
				List<RemoteProjectUser> remoteProjectUsers = new List<RemoteProjectUser>();
				foreach (ProjectUser projectUser in projectUsers)
				{
					RemoteProjectUser remoteProjectUser = new RemoteProjectUser();
					PopulationFunctions.PopulateProjectUser(remoteProjectUser, projectUser);
					remoteProjectUsers.Add(remoteProjectUser);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteProjectUsers;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Refreshes the task progress and test execution status for a project.
		/// Typically this needs to be called after TestRun_RecordAutomated3(...) API calls
		/// to ensure the data in the system is consistent
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">the id of the project</param>
		/// <param name="releaseId">The release we want to refresh, or pass NULL for all releases in the project</param>
		/// <param name="runInBackground">
		/// Do we want to run this in the background. If it runs in the background it will return immediately and continue processing on the server/
		/// Otherwise the caller will have to wait until it finishes. Choosing True is better if you have a large project that will take longer to
		/// refresh that the web service timeout, but False is better if your subsequent code relies on the data being refreshed
		/// </param>
		public void Project_RefreshProgressExecutionStatusCaches(RemoteCredentials credentials, int projectId, int? releaseId, bool runInBackground)
		{
			const string METHOD_NAME = "Project_RefreshProgressExecutionStatusCaches";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we are a project owner to execute this
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.None, Project.PermissionEnum.ProjectAdmin))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyProject);
			}

			try
			{
				//We need to refresh the test status for the whole project
				Business.ProjectManager project = new Business.ProjectManager();
				project.RefreshTestStatusAndTaskProgressCache(projectId, runInBackground, releaseId);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Creates a new project in the system and makes the authenticated user owner of it
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteProject">The new project object (primary key will be empty)</param>
		/// <param name="existingProjectId">The id of an existing project to use as a template, or null to use the default template</param>
		/// <returns>The populated project object - including the primary key</returns>
		public RemoteProject Project_Create(RemoteCredentials credentials, RemoteProject remoteProject, Nullable<int> existingProjectId)
		{
			const string METHOD_NAME = "Project_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a project id specified
			if (remoteProject.ProjectId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_ProjectIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have permissions to create projects (i.e. is a system admin)
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateProjects);
			}

			string description = "";
			string url = "";
			if (!String.IsNullOrEmpty(remoteProject.Description))
			{
				description = remoteProject.Description;
			}
			if (!String.IsNullOrEmpty(remoteProject.Website))
			{
				url = remoteProject.Website;
			}

			//Provide sensible default values for the working hours
			if (remoteProject.WorkingHours < 1)
			{
				remoteProject.WorkingHours = ReleaseManager.DEFAULT_HOURS_PER_DAY;
			}
			if (remoteProject.WorkingDays < 1)
			{
				remoteProject.WorkingDays = ReleaseManager.DEFAULT_DAYS_PER_WEEK;
			}

			//Now create the project - either using default template or existing template
			Business.ProjectManager projectManager = new Business.ProjectManager();
			if (existingProjectId.HasValue)
			{
				int projectId = projectManager.CreateFromExisting(
				   remoteProject.Name,
				   description,
				   url,
				   existingProjectId.Value);

				//Now populate the project id onto the object
				remoteProject.ProjectId = projectId;
			}
			else
			{
				int projectId = projectManager.Insert(
				   remoteProject.Name,
				   remoteProject.ProjectGroupId,
				   description,
				   url,
				   remoteProject.Active,
				   remoteProject.ProjectTemplateId,
				   remoteProject.WorkingHours,
				   remoteProject.WorkingDays,
				   remoteProject.NonWorkingHours,
				   true, true, true, true, false, false, 1.0M, ProjectManager.DEFAULT_POINT_EFFORT, null, true, true, true, userId
				   );

				//Now populate the project id onto the object
				remoteProject.ProjectId = projectId;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteProject;
		}

		/// <summary>
		/// Updates an existing project
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteProject">The project object to update</param>
		public void Project_Update(RemoteCredentials credentials, RemoteProject remoteProject)
		{
			const string METHOD_NAME = "Project_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have an template id specified
			if (!remoteProject.ProjectId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_ProjectIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have permissions to update projects (i.e. is a system admin or project owner)
			if (!IsAuthorized(credentials, remoteProject.ProjectId.Value, DataModel.Artifact.ArtifactTypeEnum.None, Project.PermissionEnum.ProjectAdmin))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyProject);
			}

			try
			{
				//First retrieve the existing project
				ProjectManager projectManager = new ProjectManager();
				Project project = projectManager.RetrieveById(remoteProject.ProjectId.Value);

				//Make sure we have the data
				if (project == null)
				{
					throw CreateFault("ArtifactNotFoundException", Resources.Messages.Services_ArtifactNotFound);
				}

				//Need to extract the data from the API data object update the entity
				UpdateFunctions.UpdateProject(project, remoteProject);

				//Call the business object to actually update the project
				projectManager.Update(project);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes an existing project in the system
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The project being deleted</param>
		public void Project_Delete(RemoteCredentials credentials, int projectId)
		{
			const string METHOD_NAME = "Project_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have permissions to delete projects (i.e. is a system admin)
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteProjects);
			}

			//Now delete the project
			Business.ProjectManager projectManager = new Business.ProjectManager();
			projectManager.Delete(userId, projectId);

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Retrieves a list of projects that the authenticated user has access to
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <returns>The list of active projects</returns>
		public List<RemoteProject> Project_Retrieve(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Project_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			else
			{
				//Get the list of projects
				int userId = credentials.UserId;
				Business.ProjectManager projectManager = new Business.ProjectManager();
				List<ProjectForUserView> projects = projectManager.RetrieveForUser(userId);

				//Populate the API data object and return
				List<RemoteProject> remoteProjects = new List<RemoteProject>();
				foreach (ProjectForUserView project in projects)
				{
					//Create and populate the row
					RemoteProject remoteProject = new RemoteProject();
					PopulationFunctions.PopulateProject(remoteProject, project.ConvertTo<ProjectForUserView, Project>());
					remoteProjects.Add(remoteProject);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteProjects;
			}
		}

		/// <summary>
		/// Retrieves a list of project roles in the system
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <returns>The list of project roles</returns>
		public List<RemoteProjectRole> ProjectRole_Retrieve(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "ProjectRole_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			else
			{
				//Get the list of project roles
				int userId = credentials.UserId;
				Business.ProjectManager projectManager = new Business.ProjectManager();
				List<ProjectRole> projectRoles = projectManager.RetrieveProjectRoles(false, true);

				//Populate the API data object and return
				List<RemoteProjectRole> remoteProjectRoles = new List<RemoteProjectRole>();
				foreach (ProjectRole projectRole in projectRoles)
				{
					//Create and populate the row
					RemoteProjectRole remoteProjectRole = new RemoteProjectRole();
					PopulationFunctions.PopulateProjectRole(remoteProjectRole, projectRole);
					remoteProjectRoles.Add(remoteProjectRole);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteProjectRoles;
			}
		}

		/// <summary>
		/// Retrieves a single project in the system
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <returns>The project object</returns>
		public RemoteProject Project_RetrieveById(RemoteCredentials credentials, int projectId)
		{
			const string METHOD_NAME = "Project_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			else
			{
				//Get the list of projects
				int userId = credentials.UserId;
				Business.ProjectManager projectManager = new Business.ProjectManager();

				//If the project was not found, just return null
				try
				{
					Project project = projectManager.RetrieveById(projectId);

					//Populate the API data object and return
					RemoteProject remoteProject = new RemoteProject();
					PopulationFunctions.PopulateProject(remoteProject, project);

					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();
					return remoteProject;
				}
				catch (ArtifactNotExistsException)
				{
					Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested project");
					Logger.Flush();
					return null;
				}
			}
		}

		/// <summary>
		/// Adds users to a project with a specific role
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteProjectUser">The user/role to add to the project</param>
		public void Project_AddUserMembership(RemoteCredentials credentials, RemoteProjectUser remoteProjectUser)
		{
			const string METHOD_NAME = "Project_AddUserMembership";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Get the project ID
			int projectId = remoteProjectUser.ProjectId;

			//Make sure we're authorized
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we are a project owner to execute this
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.None, Project.PermissionEnum.ProjectAdmin))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyProject);
			}

			try
			{
				//Retrieve the list of users that are members of the current project
				Business.ProjectManager projectManager = new Business.ProjectManager();
				List<ProjectUser> projectUsers = projectManager.RetrieveUserMembershipById(projectId);

				//Make sure the project matches and that the user is not already a member
				if (remoteProjectUser.ProjectId != projectId)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyProject);
				}
				if (!remoteProjectUser.UserId.HasValue)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("NeedToProvideUserId", Resources.Messages.Services_UserIdIsNull);
				}
				if (projectUsers.Any(p => p.ProjectId == remoteProjectUser.ProjectId && p.UserId == remoteProjectUser.UserId))
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("UserIsAlreadyMemberOfProject", Resources.Messages.Services_UserIsAlreadyMemberOfProject);
				}

				//Add the user to the project
				projectManager.InsertUserMembership(
					remoteProjectUser.UserId.Value,
					remoteProjectUser.ProjectId,
					remoteProjectUser.ProjectRoleId
					);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Removes users from a project
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteProjectUser">The user/role to remove from the project</param>
		public void Project_RemoveUserMembership(RemoteCredentials credentials, RemoteProjectUser remoteProjectUser)
		{
			const string METHOD_NAME = "Project_RemoveUserMembership";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Get the project ID
			int projectId = remoteProjectUser.ProjectId;

			//Make sure we're authorized
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we are a project owner to execute this
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.None, Project.PermissionEnum.ProjectAdmin))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyProject);
			}

			try
			{
				//Retrieve the list of users that are members of the current project
				Business.ProjectManager projectManager = new Business.ProjectManager();
				List<ProjectUser> projectUsers = projectManager.RetrieveUserMembershipById(projectId);

				//Make sure the project matches and that the user is already a member
				if (remoteProjectUser.ProjectId != projectId)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyProject);
				}
				if (!remoteProjectUser.UserId.HasValue)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("NeedToProvideUserId", Resources.Messages.Services_UserIdIsNull);
				}
				if (!projectUsers.Any(p => p.ProjectId == remoteProjectUser.ProjectId && p.UserId == remoteProjectUser.UserId))
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("UserNotMemberOfProject", Resources.Messages.Services_UserMembershipNotFound);
				}

				//Remove the user from the project
				projectManager.DeleteUserMembership(
					remoteProjectUser.UserId.Value,
					remoteProjectUser.ProjectId
					);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates the user's role on a specific project
		/// </summary>
		/// <param name="credentials">The credentials fro accessing the API</param>
		/// <param name="remoteProjectUser">The membership entry to update</param>
		public void Project_UpdateUserMembership(RemoteCredentials credentials, RemoteProjectUser remoteProjectUser)
		{
			const string METHOD_NAME = "Project_UpdateUserMembership";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteProjectUser.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we are a project owner to execute this
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.None, Project.PermissionEnum.ProjectAdmin))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyProject);
			}

			try
			{
				//Retrieve the list of users that are members of the current project
				Business.ProjectManager projectManager = new Business.ProjectManager();
				List<ProjectUser> projectUsers = projectManager.RetrieveUserMembershipById(projectId);

				//Make sure the project matches and that the user is already a member
				if (remoteProjectUser.ProjectId != projectId)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyProject);
				}
				if (!remoteProjectUser.UserId.HasValue)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("NeedToProvideUserId", Resources.Messages.Services_UserIdIsNull);
				}
				ProjectUser projectUser = projectUsers.FirstOrDefault(p => p.UserId == remoteProjectUser.UserId.Value);
				if (projectUser == null)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("NotFindProjectMembership", Resources.Messages.Services_UserMembershipNotFound);
				}

				//Update the membership
				projectUser.StartTracking();
				projectUser.ProjectRoleId = remoteProjectUser.ProjectRoleId;
				projectManager.UpdateMembership(projectUsers);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		#endregion

		#region Custom Property Methods

		/// <summary>
		/// Retrieves the list of custom properties configured for the current project and the specified artifact type
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="artifactTypeId">The id of the type of artifact</param>
		/// <param name="includeDeleted">Should we include deleted custom properties</param>
		/// <returns>The list of custom properties</returns>
		/// <remarks>
		/// 1) Includes the custom list and custom list value child objects
		/// 2) The custom list values objects will include both active and inactive values, so need to check the flag before displaying
		/// </remarks>
		/// <example>
		/// RemoteCustomProperty[] remoteCustomProperties = spiraImportExport.CustomProperty_RetrieveForArtifactType(credentials, projectTemplateId, (int)DataModel.Artifact.ArtifactTypeEnum.Requirement, false);
		/// </example>
		public List<RemoteCustomProperty> CustomProperty_RetrieveForArtifactType(RemoteCredentials credentials, int projectTemplateId, int artifactTypeId, bool includeDeleted)
		{
			const string METHOD_NAME = "CustomProperty_RetrieveForArtifactType";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			try
			{
				//Get the custom properties for the current project and specified artifact
				//We don't get the corresponding custom lists right now, we'll do that in a separate step
				//since we also want the list values as well
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				List<CustomProperty> customProperties = customPropertyManager.CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, (DataModel.Artifact.ArtifactTypeEnum)artifactTypeId, false, includeDeleted);

				//Populate the API data objects and return
				List<RemoteCustomProperty> remoteCustomProperties = new List<RemoteCustomProperty>();
				foreach (CustomProperty customProperty in customProperties)
				{
					//Create and populate the row
					RemoteCustomProperty remoteCustomProperty = new RemoteCustomProperty(customProperty);
					if (customProperty.CustomPropertyListId.HasValue)
					{
						//We need to get the custom list and matching values for this custom property
						remoteCustomProperty.CustomList = CustomProperty_RetrieveCustomListById(credentials, projectTemplateId, customProperty.CustomPropertyListId.Value);
					}
					else
					{
						remoteCustomProperty.CustomList = null;
					}
					remoteCustomProperties.Add(remoteCustomProperty);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteCustomProperties;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}
		/// <summary>
		/// Retrieves a custom list by its ID, including any custom list values
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="customListId">The id of the custom list we want to retrieve</param>
		/// <returns>The custom list object (including any custom list values)</returns>
		/// <example>
		/// remoteCustomList = spiraImportExport.CustomProperty_RetrieveCustomListById(credentials, projectTemplateId, customListId1);
		/// </example>
		public RemoteCustomList CustomProperty_RetrieveCustomListById(RemoteCredentials credentials, int projectTemplateId, int customListId)
		{
			const string METHOD_NAME = "CustomProperty_RetrieveCustomListById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Get the custom list for the project
			try
			{
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				CustomPropertyList customPropertyList = customPropertyManager.CustomPropertyList_RetrieveById(customListId, true, true);

				//Make sure we have a list
				if (customPropertyList == null)
				{
					throw new Exception(Resources.Messages.Services_CustomListDoesNotExist);
				}

				//Make sure that this list belongs to the current project template (for security reasons)
				if (customPropertyList.ProjectTemplateId != projectTemplateId)
				{
					throw new Exception(Resources.Messages.Services_CustomListNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteCustomList remoteCustomList = new RemoteCustomList(customPropertyList);

				//Now populate the associated custom list values
				remoteCustomList.Values = new List<RemoteCustomListValue>();
				foreach (CustomPropertyValue customPropertyValue in customPropertyList.Values)
				{
					//Create and populate the row
					RemoteCustomListValue remoteCustomListValue = new RemoteCustomListValue(customPropertyValue);
					remoteCustomList.Values.Add(remoteCustomListValue);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteCustomList;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves all the custom lists in the current project template
		/// </summary>
		/// <returns>A collection of custom list data objects</returns>
		/// <remarks>
		/// Does not return the actual custom list values
		/// </remarks>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <example>
		/// RemoteCustomList[] remoteCustomLists = spiraImportExport.CustomProperty_RetrieveCustomLists(credentials, projectTemplateId);
		/// </example>
		public List<RemoteCustomList> CustomProperty_RetrieveCustomLists(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "CustomProperty_RetrieveCustomLists";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Get the custom lists for the project
			try
			{
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				List<CustomPropertyList> customPropertyLists = customPropertyManager.CustomPropertyList_RetrieveForProjectTemplate(projectTemplateId);

				//Populate the API data objects and return
				List<RemoteCustomList> remoteCustomLists = new List<RemoteCustomList>();
				foreach (CustomPropertyList customPropertyList in customPropertyLists)
				{
					//Create and populate the row
					RemoteCustomList remoteCustomList = new RemoteCustomList(customPropertyList);
					remoteCustomLists.Add(remoteCustomList);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteCustomLists;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates a custom list and any associated values in the system
		/// </summary>
		/// <param name="remoteCustomList">The custom list to update</param>
		/// <remarks>This will not add any new custom values, for that you need to use the AddCustomListValue() function</remarks>
		/// <example>
		/// remoteCustomList = spiraImportExport.CustomProperty_RetrieveCustomListById(credentials, projectTemplateId, customListId2);
		/// remoteCustomList.Name = "Component Names";
		/// remoteCustomList.Values[0].Name = "Component One";
		/// spiraImportExport.CustomProperty_UpdateCustomList(credentials, remoteCustomList);
		/// </example>
		public void CustomProperty_UpdateCustomList(RemoteCredentials credentials, RemoteCustomList remoteCustomList)
		{
			const string METHOD_NAME = "CustomProperty_UpdateCustomList";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectTemplateId = remoteCustomList.ProjectTemplateId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Instantiate the custom property business class
				Business.CustomPropertyManager customPropertyManager = new Business.CustomPropertyManager();

				//First we need to get the current definition of the custom list and associated values
				CustomPropertyList customPropertyList = customPropertyManager.CustomPropertyList_RetrieveById(remoteCustomList.CustomPropertyListId.Value, true, true);

				//Make sure that this list belongs to the current project (for security reasons)
				if (customPropertyList.ProjectTemplateId != projectTemplateId)
				{
					throw new Exception(Resources.Messages.Services_CustomListNotBelongToProject);
				}

				//Next we need to update the custom list itself
				customPropertyList.StartTracking();
				customPropertyList.Name = remoteCustomList.Name;
				customPropertyList.IsActive = remoteCustomList.Active;

				//Next we need to update any custom values (if there are any)
				if (remoteCustomList.Values != null)
				{
					//Now populate
					foreach (RemoteCustomListValue remoteCustomListValue in remoteCustomList.Values)
					{
						//Ignore any remoteCustomListValue objects that have no primary key value
						//Since they should be added using the AddCustomListValue() function instead
						if (remoteCustomListValue.CustomPropertyValueId.HasValue)
						{
							//See if we have a matching row in the entity collection
							CustomPropertyValue customPropertyValue = customPropertyList.Values.FirstOrDefault(cv => cv.CustomPropertyValueId == remoteCustomListValue.CustomPropertyValueId);
							if (customPropertyValue != null)
							{
								//Update the existing row
								customPropertyValue.StartTracking();
								customPropertyValue.Name = remoteCustomListValue.Name;
								customPropertyValue.IsActive = remoteCustomListValue.Active;
							}
						}
					}
				}

				//Now update the custom list and associated values
				customPropertyManager.CustomPropertyList_Update(customPropertyList);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Adds a new custom list into the project template
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteCustomList">The new custom list object</param>
		/// <returns>The custom list object with the primary key set</returns>
		/// <remarks>Also adds any custom list values if they are provided</remarks>
		/// <example>
		/// RemoteCustomListValue remoteCustomListValue = new RemoteCustomListValue();
		/// remoteCustomListValue.Name = "Feature";
		/// remoteCustomListValue.Active = true;
		/// RemoteCustomList remoteCustomList = new RemoteCustomList();
		/// remoteCustomList.Name = "Req Types";
		/// remoteCustomList.Active = true;
		/// remoteCustomList.Values = new RemoteCustomListValue[] { remoteCustomListValue };
		/// customListId1 = spiraImportExport.CustomProperty_AddCustomList(credentials, remoteCustomList).CustomPropertyListId.Value;
		/// </example>
		public RemoteCustomList CustomProperty_AddCustomList(RemoteCredentials credentials, RemoteCustomList remoteCustomList)
		{
			const string METHOD_NAME = "CustomProperty_AddCustomList";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a custom list id already set
			if (remoteCustomList.CustomPropertyListId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_CustomListIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectTemplateId = remoteCustomList.ProjectTemplateId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Instantiate the custom property business class
				Business.CustomPropertyManager customPropertyManager = new Business.CustomPropertyManager();

				//Now insert the new custom list
				remoteCustomList.CustomPropertyListId = customPropertyManager.CustomPropertyList_Add(projectTemplateId, remoteCustomList.Name, remoteCustomList.Active).CustomPropertyListId;

				//Now add the values if any are provided
				if (remoteCustomList.Values != null)
				{
					foreach (RemoteCustomListValue remoteCustomListValue in remoteCustomList.Values)
					{
						remoteCustomListValue.CustomPropertyValueId = customPropertyManager.CustomPropertyList_AddValue(remoteCustomList.CustomPropertyListId.Value, remoteCustomListValue.Name, remoteCustomListValue.Active).CustomPropertyValueId;
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteCustomList;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Adds a new custom property list value into the system
		/// </summary>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="remoteCustomListValue">The new custom list value object being added</param>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <returns>custom list value object with its primary key set</returns>
		/// <example>
		/// remoteCustomListValue = new RemoteCustomListValue();
		/// remoteCustomListValue.CustomPropertyListId = customListId1;
		/// remoteCustomListValue.Name = "Technical Quality";
		/// remoteCustomListValue.Active = true;
		/// customValueId2 = spiraImportExport.CustomProperty_AddCustomListValue(credentials, projectTemplateId, remoteCustomListValue).CustomPropertyValueId.Value;
		/// </example>
		public RemoteCustomListValue CustomProperty_AddCustomListValue(RemoteCredentials credentials, int projectTemplateId, RemoteCustomListValue remoteCustomListValue)
		{
			const string METHOD_NAME = "CustomProperty_AddCustomListValue";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a custom list id already set
			if (remoteCustomListValue.CustomPropertyValueId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_CustomPropertyValueIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Instantiate the custom property business class
				Business.CustomPropertyManager customPropertyManager = new Business.CustomPropertyManager();

				//Retrieve the custom list to make sure it's in the authorized template
				CustomPropertyList list = customPropertyManager.CustomPropertyList_RetrieveById(remoteCustomListValue.CustomPropertyListId);
				if (list.ProjectTemplateId != projectTemplateId)
				{
					throw new Exception(Resources.Messages.Services_CustomPropertyNotBelongToProject);
				}

				//Now insert the new custom property list value
				remoteCustomListValue.CustomPropertyValueId = customPropertyManager.CustomPropertyList_AddValue(remoteCustomListValue.CustomPropertyListId, remoteCustomListValue.Name, remoteCustomListValue.Active).CustomPropertyValueId;

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteCustomListValue;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Adds a new custom property definition to the project for the specified artifact type
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteCustomProperty">The new custom property definition</param>
		/// <param name="customListId">The id of the associated custom list (if a list property)</param>
		/// <returns>The custom property definition with the primary key populated</returns>
		/// <example>
		/// RemoteCustomProperty remoteCustomProperty = new RemoteCustomProperty();
		/// remoteCustomProperty.ArtifactTypeId = (int)DataModel.Artifact.ArtifactTypeEnum.Requirement;
		/// remoteCustomProperty.ProjectId = projectId1;
		/// remoteCustomProperty.PropertyNumber = 2;
		/// remoteCustomProperty.CustomPropertyTypeId = 6;  //List
		/// remoteCustomProperty.Name = "Req Type";
		/// spiraImportExport.CustomProperty_AddDefinition(credentials, remoteCustomProperty, remoteCustomList.CustomPropertyListId);
		/// </example>
		public RemoteCustomProperty CustomProperty_AddDefinition(RemoteCredentials credentials, RemoteCustomProperty remoteCustomProperty, int? customListId)
		{
			const string METHOD_NAME = "CustomProperty_AddDefinition";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectTemplateId = remoteCustomProperty.ProjectTemplateId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			//Make sure that we don't have a custom property id specified
			if (remoteCustomProperty.CustomPropertyId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_CustomPropertyIdNotNull);
			}

			//Make sure that this list belongs to the current project (for security reasons)
			if (remoteCustomProperty.ProjectTemplateId != projectTemplateId)
			{
				throw new Exception(Resources.Messages.Services_CustomPropertyNotBelongToProject);
			}

			try
			{
				//Instantiate the custom property business class
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();

				//Verify that the list id is correct
				if (customListId.HasValue)
				{
					CustomPropertyList customList = customPropertyManager.CustomPropertyList_RetrieveById(customListId.Value, false, true);
					if (customList == null)
					{
						throw new Exception(Resources.Messages.Services_CustomListDoesNotExist);
					}

					//Make sure the project's match
					if (customList.ProjectTemplateId != remoteCustomProperty.ProjectTemplateId)
					{
						throw new Exception(Resources.Messages.Services_CustomListNotBelongToProject);
					}
				}

				CustomProperty customProperty = customPropertyManager.CustomPropertyDefinition_AddToArtifact(
					remoteCustomProperty.ProjectTemplateId,
					(Artifact.ArtifactTypeEnum)remoteCustomProperty.ArtifactTypeId,
					remoteCustomProperty.CustomPropertyTypeId,
					remoteCustomProperty.PropertyNumber,
					remoteCustomProperty.Name,
					null,
					null,
					customListId);

				//Now we need to set the option values
				if (remoteCustomProperty.Options != null && remoteCustomProperty.Options.Count > 0)
				{
					foreach (RemoteCustomPropertyOption remoteCustomPropertyOption in remoteCustomProperty.Options)
					{
						CustomPropertyOptionValue customPropertyOptionValue = new CustomPropertyOptionValue();
						customPropertyOptionValue.CustomPropertyOptionId = remoteCustomPropertyOption.CustomPropertyOptionId;
						customPropertyOptionValue.CustomPropertyId = customProperty.CustomPropertyId;
						customPropertyOptionValue.Value = remoteCustomPropertyOption.Value;
						customPropertyManager.CustomPropertyOptions_Add(customPropertyOptionValue);
					}
				}

				remoteCustomProperty.CustomPropertyId = customProperty.CustomPropertyId;
				return remoteCustomProperty;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Deletes a custom property definition from the system, including any associated options
		/// </summary>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="customPropertyId">The id of the custom property to delete</param>
		/// <remarks>Does a hard delete</remarks>
		/// <example>
		/// remoteCustomProperty = spiraImportExport.CustomProperty_DeleteDefinition(5);
		/// </example>
		public void CustomProperty_DeleteDefinition(RemoteCredentials credentials, int projectTemplateId, int customPropertyId)
		{
			const string METHOD_NAME = "CustomProperty_UpdateDefinition";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Instantiate the custom property business class
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();

				//Retrieve the existing definition
				CustomProperty customProperty = customPropertyManager.CustomPropertyDefinition_RetrieveById(customPropertyId, true);
				if (customProperty == null)
				{
					throw new Exception(Resources.Messages.Services_CustomPropertyDoesNotExist);
				}

				//Make sure that this custom property belongs to the current project template (for security reasons)
				if (customProperty.ProjectTemplateId != projectTemplateId)
				{
					throw new Exception(Resources.Messages.Services_CustomPropertyNotBelongToProject);
				}

				//Finally delete the custom property definition (physically)
				customPropertyManager.CustomPropertyDefinition_RemoveById(customPropertyId);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Updates a custom property definition, including any associated options
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="remoteCustomProperty">The custom property definition to update</param>
		/// <remarks>
		/// This method updates the custom property Name, IsDeleted flag, and custom property options, but does not update the list values or other fields.
		/// To change the list values, you need to use: CustomProperty_UpdateCustomList(...)
		/// </remarks>
		/// <example>
		/// remoteCustomProperty = spiraImportExport.CustomProperty_RetrieveForArtifactType(1, false);
		/// remoteCustomProperty.Name = "Req Type";
		/// spiraImportExport.CustomProperty_UpdateDefinition(credentials, remoteCustomProperty);
		/// </example>
		public void CustomProperty_UpdateDefinition(RemoteCredentials credentials, RemoteCustomProperty remoteCustomProperty)
		{
			const string METHOD_NAME = "CustomProperty_UpdateDefinition";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectTemplateId = remoteCustomProperty.ProjectTemplateId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Instantiate the custom property business class
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();

				//Retrieve the existing definition
				CustomProperty customProperty = customPropertyManager.CustomPropertyDefinition_RetrieveForArtifactTypeAtPropertyNumber(projectTemplateId, (DataModel.Artifact.ArtifactTypeEnum)remoteCustomProperty.ArtifactTypeId, remoteCustomProperty.PropertyNumber, false);
				if (customProperty == null)
				{
					throw new Exception(Resources.Messages.Services_CustomPropertyDoesNotExist);
				}

				//Make sure that this custom property belongs to the current project (for security reasons)
				if (customProperty.ProjectTemplateId != projectTemplateId)
				{
					throw new Exception(Resources.Messages.Services_CustomPropertyNotBelongToProject);
				}

				//Next we need to update the custom property itself
				customProperty.StartTracking();
				customProperty.Name = remoteCustomProperty.Name;
				customProperty.IsDeleted = remoteCustomProperty.IsDeleted;

				//Now we need to change any of the option values as well (if there are any)
				if (remoteCustomProperty.Options != null)
				{
					//Now populate
					foreach (RemoteCustomPropertyOption remoteCustomPropertyOption in remoteCustomProperty.Options)
					{
						//See if it already exists or not (insert vs. update)
						CustomPropertyOptionValue optionValue = customProperty.Options.FirstOrDefault(o => o.CustomPropertyOptionId == remoteCustomPropertyOption.CustomPropertyOptionId);
						if (optionValue == null)
						{
							CustomPropertyOptionValue newCustomPropertyOptionValue = new CustomPropertyOptionValue();
							newCustomPropertyOptionValue.CustomPropertyOptionId = remoteCustomPropertyOption.CustomPropertyOptionId;
							newCustomPropertyOptionValue.Value = remoteCustomPropertyOption.Value;
							customProperty.Options.Add(newCustomPropertyOptionValue);
						}
						else
						{
							optionValue.StartTracking();
							optionValue.Value = remoteCustomPropertyOption.Value;
						}
					}

					//Finally handle any deletes
					List<CustomPropertyOptionValue> itemsToDelete = new List<CustomPropertyOptionValue>();
					foreach (CustomPropertyOptionValue optionValue in customProperty.Options)
					{
						if (!remoteCustomProperty.Options.Any(o => o.CustomPropertyOptionId == optionValue.CustomPropertyOptionId))
						{
							itemsToDelete.Add(optionValue);
						}
					}
					foreach (CustomPropertyOptionValue optionValue in itemsToDelete)
					{
						customProperty.Options.Remove(optionValue);
					}
				}

				//Finally commit the changes
				customPropertyManager.CustomPropertyDefinition_Update(customProperty);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		#endregion Project Methods

		#region Association Methods

		/// <summary>
		/// Adds a new association in the system
		/// </summary>
		/// <param name="remoteAssociation">The association to add</param>
		/// <returns>The association with its primary key populated</returns>
		/// <example>
		/// RemoteAssociation remoteAssociation = new RemoteAssociation();
		/// remoteAssociation.SourceArtifactId = requirementId1;
		/// remoteAssociation.SourceArtifactTypeId = (int)DataModel.Artifact.ArtifactTypeEnum.Requirement;
		/// remoteAssociation.DestArtifactId = incidentId1;
		/// remoteAssociation.DestArtifactTypeId = (int)DataModel.Artifact.ArtifactTypeEnum.Incident;
		/// remoteAssociation.Comment = "They are related";
		/// spiraImportExport.Association_Create(credentials, projectId, remoteAssociation);
		/// </example>
		public RemoteAssociation Association_Create(RemoteCredentials credentials, int projectId, RemoteAssociation remoteAssociation)
		{
			const string METHOD_NAME = "Association_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a ArtifactLinkID specified
			if (remoteAssociation.ArtifactLinkId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_ArtifactLinkIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to add associations to the Source artifact (considered a modify operation)
			if (!IsAuthorized(credentials, projectId, (Artifact.ArtifactTypeEnum)remoteAssociation.SourceArtifactTypeId, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedAddAssociations);
			}

			try
			{
				//Default to the authenticated user if no creator provided
				int creatorId = userId;
				if (remoteAssociation.CreatorId.HasValue)
				{
					creatorId = remoteAssociation.CreatorId.Value;
				}

				//Check the comment length
				string comment = remoteAssociation.Comment.MaxLength(255);

				//If the creation date is not specified, use the current one
				if (!remoteAssociation.CreationDate.HasValue)
				{
					remoteAssociation.CreationDate = DateTime.UtcNow;
				}

				//Now insert the association
				Business.ArtifactLinkManager artifactLinkManager = new Business.ArtifactLinkManager();
				remoteAssociation.ArtifactLinkId = artifactLinkManager.Insert(
				   projectId,
				   (DataModel.Artifact.ArtifactTypeEnum)remoteAssociation.SourceArtifactTypeId,
				   remoteAssociation.SourceArtifactId,
				   (DataModel.Artifact.ArtifactTypeEnum)remoteAssociation.DestArtifactTypeId,
				   remoteAssociation.DestArtifactId,
				   creatorId,
				   comment,
				   remoteAssociation.CreationDate.Value,
				   (DataModel.ArtifactLink.ArtifactLinkTypeEnum)remoteAssociation.ArtifactLinkTypeId
				   );
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteAssociation;
		}

		/// <summary>
		/// Updates the specified Association's information
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="remoteAssociation">The updated association information</param>
		/// <example>
		/// remoteAssociation.Comment = "They are the same bugs";
		/// spiraImportExport.Association_Update(credentials, projectId, remoteAssociation);
		/// </example>
		/// <remarks>
		/// Currently only the comment field is updated
		/// </remarks>
		public void Association_Update(RemoteCredentials credentials, int projectId, RemoteAssociation remoteAssociation)
		{
			const string METHOD_NAME = "Incident_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have an artifact link id specified
			if (!remoteAssociation.ArtifactLinkId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_ArtifactLinkIdMissing);
			}

			//Make sure that we're not trying update a system-generated association (they have negative primary keys)
			if (remoteAssociation.ArtifactLinkId.Value < 0)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("InvalidArgument", Resources.Messages.Services_ArtifactLinkReadOnly);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update the source artifact id
			if (!IsAuthorized(credentials, projectId, (Artifact.ArtifactTypeEnum)remoteAssociation.SourceArtifactTypeId, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedAddAssociations);
			}

			//First retrieve the existing datarow
			try
			{
				ArtifactLinkManager artifactLinkManager = new ArtifactLinkManager();
				ArtifactLink artifactLink = artifactLinkManager.RetrieveById(remoteAssociation.ArtifactLinkId.Value);

				//Need to extract the data from the API data object and add to the internal dataset
				UpdateFunctions.UpdateAssociationData(artifactLink, remoteAssociation);

				//Call the business object to actually update the association
				artifactLinkManager.Update(artifactLink, userId);
			}
			catch (Exception exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a set of associations to the specified artifact
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="artifactTypeId">The id of the artifact type</param>
		/// <param name="artifactId">The id of the artifact</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <returns>An array of association records</returns>
		/// <example>
		/// RemoteSort remoteSort = new RemoteSort();
		/// remoteSort.PropertyName = "Comment";
		/// remoteSort.SortAscending = true;
		/// RemoteFilter remoteFilter = new RemoteFilter();
		/// remoteFilter.PropertyName = "ArtifactTypeId";
		/// remoteFilter.IntValue = (int)DataModel.Artifact.ArtifactTypeEnum.Incident;
		/// remoteAssociations = spiraImportExport.Association_RetrieveForArtifact(credentials, projectId, (int)DataModel.Artifact.ArtifactTypeEnum.Incident, incidentId1, new RemoteFilter[] { remoteFilter }, remoteSort);
		/// </example>
		/// <remarks>
		/// The source artifact type and id will be the same as the ones passed in
		/// </remarks>
		public List<RemoteAssociation> Association_RetrieveForArtifact(RemoteCredentials credentials, int projectId, int artifactTypeId, int artifactId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort)
		{
			const string METHOD_NAME = "Association_RetrieveForArtifact";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view associations for the Source artifact (considered a view operation)
			if (!IsAuthorized(credentials, projectId, (Artifact.ArtifactTypeEnum)artifactTypeId, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewAssociations);
			}

			try
			{
				//Extract the filters from the provided API object
				Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

				//Call the business object to actually retrieve the association record
				ArtifactLinkManager artifactLinkManager = new ArtifactLinkManager();
				List<ArtifactLinkView> artifactLinks = artifactLinkManager.RetrieveByArtifactId((DataModel.Artifact.ArtifactTypeEnum)artifactTypeId, artifactId, remoteSort.PropertyName, remoteSort.SortAscending, filters);

				//Populate the API data object and return
				//Note that the view doesn't contain the source artifact info, we have to get that
				//from the passed in values to the API.
				List<RemoteAssociation> remoteAssociations = new List<RemoteAssociation>();
				foreach (ArtifactLinkView artifactLink in artifactLinks)
				{
					RemoteAssociation remoteAssociation = new RemoteAssociation();
					PopulationFunctions.PopulateAssociation(remoteAssociation, artifactLink, artifactId, artifactTypeId);

					//Add to the list
					remoteAssociations.Add(remoteAssociation);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteAssociations;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes an association between two artifacts
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="artifactLinkId">The id of the artifact link (association) to delete</param>
		/// <remarks>
		/// Requires modify permissions for the source artifact. Only positive link ids can be deleted (negative numbers are managed by the system)
		/// </remarks>
		public void Association_Delete(RemoteCredentials credentials, int projectId, int artifactLinkId)
		{
			const string METHOD_NAME = "Association_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//First retrieve the existing datarow
			try
			{
				Business.ArtifactLinkManager artifactLinkManager = new Business.ArtifactLinkManager();
				ArtifactLink artifactLink = artifactLinkManager.RetrieveById(artifactLinkId);

				//Make sure we have permissions to edit associations for either the source artifact
				DataModel.Artifact.ArtifactTypeEnum artifactType = (DataModel.Artifact.ArtifactTypeEnum)artifactLink.SourceArtifactTypeId;
				if (!IsAuthorized(credentials, projectId, artifactType, Project.PermissionEnum.Modify))
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
				}

				//Call the business object to actually mark the item as deleted
				artifactLinkManager.Delete(artifactLinkId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested association");
				Logger.Flush();
			}
		}

		#endregion Association Methods

		#region Document Methods

		/// <summary>
		/// Retrieves a filtered list of documents/attachments in a project for the specified folder
		/// </summary>
		/// <param name="projectId">The id of the project</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <param name="numberRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <param name="folderId">The id of the project attachment folder</param>
		/// <returns>List of documents</returns>
		/// <example>
		/// RemoteFilter remoteFilter = new RemoteFilter();
		/// remoteFilter.PropertyName = "Filename";
		/// remoteFilter.StringValue = "test_data";
		/// remoteSort.PropertyName = "Filename";
		/// remoteSort.SortAscending = true;
		/// remoteDocuments = spiraImportExport.Document_RetrieveForFolder(credentials, projectId, projectAttachmentFolderId, new RemoteFilter[] { remoteFilter }, remoteSort, 1, 999);
		/// </example>
		public List<RemoteDocument> Document_RetrieveForFolder(RemoteCredentials credentials, int projectId, int folderId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberRows)
		{
			const string METHOD_NAME = "Document_RetrieveForFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we can view documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Extract the filters from the provided API object
				Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

				//Call the business object to actually retrieve the project attachment dataset
				AttachmentManager attachmentManager = new AttachmentManager();
				List<ProjectAttachmentView> projectAttachments = attachmentManager.RetrieveForProject(projectId, folderId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberRows, filters, 0);
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Document, false);

				//Populate the API data object and return
				List<RemoteDocument> remoteDocuments = new List<RemoteDocument>();
				foreach (ProjectAttachmentView projectAttachment in projectAttachments)
				{
					//Create and populate the row
					RemoteDocument remoteDocument = new RemoteDocument();
					PopulationFunctions.PopulateDocument(remoteDocument, projectAttachment);
					PopulationFunctions.PopulateCustomProperties(remoteDocument, projectAttachment, customProperties);
					remoteDocuments.Add(remoteDocument);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteDocuments;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a filtered list of documents/attachments in a project across all folders
		/// </summary>
		/// <param name="projectId">The id of the project</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <param name="numberRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of documents</returns>
		/// <example>
		/// RemoteFilter remoteFilter = new RemoteFilter();
		/// remoteFilter.PropertyName = "Filename";
		/// remoteFilter.StringValue = "test_data";
		/// remoteSort.PropertyName = "Filename";
		/// remoteSort.SortAscending = true;
		/// remoteDocuments = spiraImportExport.Document_Retrieve(credentials, projectId, new RemoteFilter[] { remoteFilter }, remoteSort, 1, 999);
		/// </example>
		public List<RemoteDocument> Document_Retrieve(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberRows)
		{
			const string METHOD_NAME = "Document_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we can view documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Extract the filters from the provided API object
				Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

				//Call the business object to actually retrieve the project attachment dataset
				AttachmentManager attachmentManager = new AttachmentManager();
				List<ProjectAttachmentView> projectAttachments = attachmentManager.RetrieveForProject(projectId, null, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberRows, filters, 0);
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Document, false);

				//Populate the API data object and return
				List<RemoteDocument> remoteDocuments = new List<RemoteDocument>();
				foreach (ProjectAttachmentView projectAttachment in projectAttachments)
				{
					//Create and populate the row
					RemoteDocument remoteDocument = new RemoteDocument();
					PopulationFunctions.PopulateDocument(remoteDocument, projectAttachment);
					PopulationFunctions.PopulateCustomProperties(remoteDocument, projectAttachment, customProperties);
					remoteDocuments.Add(remoteDocument);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteDocuments;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes an attachment from an artifact. The attachment will still remain in the project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="attachmentId">The id of the attachment to delete</param>
		/// <param name="artifactId">The ID of the artifact to delete</param>
		/// <param name="artifactTypeId">The ID of the type of artifact being deleted</param>
		/// <remarks>
		/// spiraImportExport.Document_DeleteFromArtifact(credentials, projectId, attachmentId2, (int)DataModel.Artifact.ArtifactTypeEnum.TestCase, testCaseId1);
		/// </remarks>
		public void Document_DeleteFromArtifact(RemoteCredentials credentials, int projectId, int attachmentId, int artifactTypeId, int artifactId)
		{
			const string METHOD_NAME = "Document_DeleteFromArtifact";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteDocuments);
			}

			try
			{
				//Convert the artifact type id into the enumeration
				DataModel.Artifact.ArtifactTypeEnum artifactType = (DataModel.Artifact.ArtifactTypeEnum)artifactTypeId;

				//Now delete the attachment
				AttachmentManager attachmentManager = new AttachmentManager();
				attachmentManager.Delete(projectId, attachmentId, artifactId, artifactType);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Deletes an attachment from the project completely
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="attachmentId">The id of the attachment to delete</param>
		public void Document_Delete(RemoteCredentials credentials, int projectId, int attachmentId)
		{
			const string METHOD_NAME = "Document_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteDocuments);
			}

			try
			{
				//Now delete the attachment
				AttachmentManager attachmentManager = new AttachmentManager();
				attachmentManager.Delete(projectId, attachmentId);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Returns the actual binary content of a file attachment in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="attachmentId">The id of the file attachment to be retrieved</param>
		/// <returns>An array of bytes representing the attachment content</returns>
		/// <example>
		/// byte[] attachmentData = spiraImportExport.Document_OpenFile(credentials, projectId, attachmentId1);
		/// </example>
		public byte[] Document_OpenFile(RemoteCredentials credentials, int projectId, int attachmentId)
		{
			const string METHOD_NAME = "Document_OpenFile";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we can view documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				//Call the business object to actually retrieve the attachment data
				AttachmentManager attachmentManager = new AttachmentManager();
				FileStream stream = attachmentManager.OpenById(attachmentId);

				//Extract the data from the stream in byte form
				byte[] attachmentBytes = new byte[stream.Length];
				stream.Read(attachmentBytes, 0, (int)stream.Length);

				//Return the array of bytes
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return attachmentBytes;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, Resources.Messages.Services_DocumentNotFound);
				Logger.Flush();
				return null;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of all the document types in the current project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="activeOnly">Do we only want the active types</param>
		/// <returns>List of document types</returns>
		public List<RemoteDocumentType> Document_RetrieveTypes(RemoteCredentials credentials, int projectTemplateId, bool activeOnly)
		{
			const string METHOD_NAME = "Document_RetrieveTypes";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//There are no specific permissions required to view document types as long as you are a member of the project

			try
			{
				//Call the business object to actually retrieve the project attachment dataset
				AttachmentManager attachmentManager = new AttachmentManager();
				List<DocumentType> attachmentTypes = attachmentManager.RetrieveDocumentTypes(projectTemplateId, activeOnly);

				//Populate the API data object and return
				List<RemoteDocumentType> remoteDocumentTypes = new List<RemoteDocumentType>();
				foreach (DocumentType attachmentType in attachmentTypes)
				{
					//Create and populate the row
					RemoteDocumentType remoteDocumentType = new RemoteDocumentType();
					PopulationFunctions.PopulateDocumentType(remoteDocumentType, attachmentType);
					remoteDocumentTypes.Add(remoteDocumentType);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteDocumentTypes;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the default document type for the current project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <returns>The default document type</returns>
		public RemoteDocumentType Document_RetrieveDefaultType(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Document_RetrieveDefaultType";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			try
			{
				//Call the business object to actually retrieve the document data
				AttachmentManager attachmentManager = new AttachmentManager();
				int typeId = attachmentManager.GetDefaultDocumentType(projectTemplateId);
				DocumentType type = attachmentManager.RetrieveDocumentTypeById(typeId);

				//Now populate the list of API data objects
				RemoteDocumentType remoteDocumentType = new RemoteDocumentType();

				//Populate fields
				remoteDocumentType.DocumentTypeId = type.DocumentTypeId;
				remoteDocumentType.Name = type.Name;
				remoteDocumentType.Description = type.Description;
				remoteDocumentType.Active = type.IsActive;
				remoteDocumentType.Default = type.IsDefault;
				remoteDocumentType.ProjectTemplateId = type.ProjectTemplateId;

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				return remoteDocumentType;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Adds a new document type to the current project template
		/// </summary>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteDocumentType">The new document type object</param>
		/// <returns>The document type object with its primary key populated</returns>
		public RemoteDocumentType Document_AddType(RemoteCredentials credentials, int projectTemplateId, RemoteDocumentType remoteDocumentType)
		{
			const string METHOD_NAME = "Document_AddType";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Now insert the document type
				AttachmentManager attachmentManager = new AttachmentManager();
				remoteDocumentType.DocumentTypeId = attachmentManager.InsertDocumentType(projectTemplateId, remoteDocumentType.Name, remoteDocumentType.Description, remoteDocumentType.Active, remoteDocumentType.Default, null);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();

			remoteDocumentType.ProjectTemplateId = projectTemplateId;
			return remoteDocumentType;
		}

		/// <summary>
		/// Updates an existing document type to the current project template
		/// </summary>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteDocumentType">The updated document type object</param>
		public void Document_UpdateType(RemoteCredentials credentials, int projectTemplateId, RemoteDocumentType remoteDocumentType)
		{
			const string METHOD_NAME = "Document_UpdateTypes";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Now update the document type
				if (remoteDocumentType.DocumentTypeId.HasValue)
				{
					AttachmentManager attachmentManager = new AttachmentManager();
					DocumentType documentType = attachmentManager.RetrieveDocumentTypeById(remoteDocumentType.DocumentTypeId.Value);
					documentType.StartTracking();
					//Populate fields
					documentType.Name = remoteDocumentType.Name;
					documentType.Description = remoteDocumentType.Description;
					documentType.IsActive = remoteDocumentType.Active;
					documentType.IsDefault = remoteDocumentType.Default;
					attachmentManager.UpdateDocumentType(documentType);
				}
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Adds a new document folder into the current project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteDocumentFolder">The new document folder</param>
		/// <returns>The document folder with the primary key populated</returns>
		public RemoteDocumentFolder Document_AddFolder(RemoteCredentials credentials, RemoteDocumentFolder remoteDocumentFolder)
		{
			const string METHOD_NAME = "Document_AddFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteDocumentFolder.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to add document folders
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedAddDocuments);
			}

			try
			{
				//Make sure that the specified parent folder exists in the project
				AttachmentManager attachmentManager = new AttachmentManager();
				if (remoteDocumentFolder.ParentProjectAttachmentFolderId.HasValue)
				{
					try
					{
						ProjectAttachmentFolder projectAttachmentFolder = attachmentManager.RetrieveFolderById(remoteDocumentFolder.ParentProjectAttachmentFolderId.Value);
						if (projectAttachmentFolder.ProjectId != projectId)
						{
							//Set the parent folder to the project default if the passed in folder is not in the project
							attachmentManager.GetDefaultProjectFolder(projectId);
							remoteDocumentFolder.ParentProjectAttachmentFolderId = attachmentManager.GetDefaultProjectFolder(projectId);
						}
					}
					catch (ArtifactNotExistsException)
					{
						//Set the parent folder to the project default
						attachmentManager.GetDefaultProjectFolder(projectId);
						remoteDocumentFolder.ParentProjectAttachmentFolderId = attachmentManager.GetDefaultProjectFolder(projectId);
					}
				}
				else
				{
					//Set the parent folder to the project default if no parent is specified - can't have more than one root per product
					attachmentManager.GetDefaultProjectFolder(projectId);
					remoteDocumentFolder.ParentProjectAttachmentFolderId = attachmentManager.GetDefaultProjectFolder(projectId);
				}

				//Now insert the document folder
				remoteDocumentFolder.ProjectId = projectId;
				remoteDocumentFolder.ProjectAttachmentFolderId = attachmentManager.InsertProjectAttachmentFolder(
					remoteDocumentFolder.ProjectId,
					remoteDocumentFolder.Name,
					remoteDocumentFolder.ParentProjectAttachmentFolderId
					);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDocumentFolder;
		}

		/// <summary>
		/// Updates the name and position of an existing folder in the project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteDocumentFolder">The updated folder information</param>
		public void Document_UpdateFolder(RemoteCredentials credentials, RemoteDocumentFolder remoteDocumentFolder)
		{
			const string METHOD_NAME = "Document_UpdateFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have an folder id specified
			if (!remoteDocumentFolder.ProjectAttachmentFolderId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_ProjectAttachmentFolderIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteDocumentFolder.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to edit document folders
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyDocumentFolders);
			}

			try
			{
				//Make sure that the specified parent folder exists in the project
				AttachmentManager attachmentManager = new AttachmentManager();
				if (remoteDocumentFolder.ParentProjectAttachmentFolderId.HasValue)
				{
					try
					{
						ProjectAttachmentFolder attachmentFolder = attachmentManager.RetrieveFolderById(remoteDocumentFolder.ParentProjectAttachmentFolderId.Value);
						if (attachmentFolder.ProjectId != projectId)
						{
							//Set the parent folder to the project default if the passed in folder is not in the project
							attachmentManager.GetDefaultProjectFolder(projectId);
							remoteDocumentFolder.ParentProjectAttachmentFolderId = attachmentManager.GetDefaultProjectFolder(projectId);
						}
					}
					catch (ArtifactNotExistsException)
					{
						//Set the parent folder to the project default
						attachmentManager.GetDefaultProjectFolder(projectId);
						remoteDocumentFolder.ParentProjectAttachmentFolderId = attachmentManager.GetDefaultProjectFolder(projectId);
					}
				}
				else
				{
					//Set the parent folder to the project default if no parent is specified - can't have more than one root per product
					attachmentManager.GetDefaultProjectFolder(projectId);
					remoteDocumentFolder.ParentProjectAttachmentFolderId = attachmentManager.GetDefaultProjectFolder(projectId);
				}

				//Now update the document folder
				ProjectAttachmentFolder projectAttachmentFolder = attachmentManager.RetrieveFolderById(remoteDocumentFolder.ProjectAttachmentFolderId.Value);
				projectAttachmentFolder.StartTracking();
				projectAttachmentFolder.Name = remoteDocumentFolder.Name;
				projectAttachmentFolder.ParentProjectAttachmentFolderId = remoteDocumentFolder.ParentProjectAttachmentFolderId;
				attachmentManager.UpdateFolder(projectAttachmentFolder);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Deletes an existing document folder from the current project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="projectAttachmentFolderId">The id of the folder to delete</param>
		/// <remarks>This will delete all child folders and documents/attachements</remarks>
		public void Document_DeleteFolder(RemoteCredentials credentials, int projectId, int projectAttachmentFolderId)
		{
			const string METHOD_NAME = "Document_DeleteFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to delete document folders
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteDocuments);
			}

			try
			{
				//Now delete the document folder after making sure the folder is actually in the specified project
				AttachmentManager attachmentManager = new AttachmentManager();
				ProjectAttachmentFolder attachmentFolder = attachmentManager.RetrieveFolderById(projectAttachmentFolderId);
				if (attachmentFolder.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}
				attachmentManager.DeleteFolder(projectId, projectAttachmentFolderId);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Retrieves a list of all the document folders in the current project
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <returns>List of document types</returns>
		public List<RemoteDocumentFolder> Document_RetrieveFolders(RemoteCredentials credentials, int projectId)
		{
			const string METHOD_NAME = "Document_RetrieveFolders";
			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//There are no specific permissions required to view document folders as long as you are a member of the project
			try
			{
				//Call the business object to actually retrieve the project attachment dataset
				AttachmentManager attachmentManager = new AttachmentManager();
				List<ProjectAttachmentFolderHierarchy> attachmentFolders = attachmentManager.RetrieveFoldersByProjectId(projectId);

				//Populate the API data object and return
				//We have to access the sorted dataview to get them in the right order
				List<RemoteDocumentFolder> remoteDocumentFolders = new List<RemoteDocumentFolder>();
				foreach (ProjectAttachmentFolderHierarchy attachmentFolder in attachmentFolders)
				{
					//Create and populate the row
					RemoteDocumentFolder remoteDocumentFolder = new RemoteDocumentFolder();
					PopulationFunctions.PopulateDocumentFolder(remoteDocumentFolder, attachmentFolder);
					remoteDocumentFolders.Add(remoteDocumentFolder);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteDocumentFolders;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of all the document folders directly under the specified parent folder
		/// </summary>
		/// <param name="parentFolderId">The id of the parent folder (null == root)</param>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <returns>List of document types</returns>
		public List<RemoteDocumentFolder> Document_RetrieveFoldersByParentFolderId(RemoteCredentials credentials, int projectId, int? parentFolderId)
		{
			const string METHOD_NAME = "Document_RetrieveFoldersByParentFolderId";
			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//There are no specific permissions required to view document folders as long as you are a member of the project
			try
			{
				//Call the business object to actually retrieve the project attachment dataset
				AttachmentManager attachmentManager = new AttachmentManager();
				List<ProjectAttachmentFolder> attachmentFolders = attachmentManager.RetrieveFoldersByParentId(projectId, parentFolderId);

				//Populate the API data object and return
				//We have to access the sorted dataview to get them in the right order
				List<RemoteDocumentFolder> remoteDocumentFolders = new List<RemoteDocumentFolder>();
				foreach (ProjectAttachmentFolder attachmentFolder in attachmentFolders)
				{
					//Create and populate the row
					RemoteDocumentFolder remoteDocumentFolder = new RemoteDocumentFolder();
					PopulationFunctions.PopulateDocumentFolder(remoteDocumentFolder, attachmentFolder);
					remoteDocumentFolders.Add(remoteDocumentFolder);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteDocumentFolders;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>Retrieves the folder by the specified ID.</summary>
		/// <param name="folderId">The id of the folder being retrieved</param>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <returns>RemoteDocumentFolder</returns>
		public RemoteDocumentFolder Document_RetrieveFolderById(RemoteCredentials credentials, int projectId, int folderId)
		{
			const string METHOD_NAME = "Document_RetrieveFolderById";
			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}
			//There are no specific permissions required to view document folders as long as you are a member of the project

			try
			{
				//Call the business object to actually retrieve the project attachment dataset
				ProjectAttachmentFolder folder = new AttachmentManager().RetrieveFolderById(folderId);

				//Copy over the remote document.
				RemoteDocumentFolder remoteDocumentFolder = new RemoteDocumentFolder();
				PopulationFunctions.PopulateDocumentFolder(remoteDocumentFolder, folder);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				return remoteDocumentFolder;
			}
			catch (Exception ex)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, ex);
				throw ConvertExceptions(ex);
			}
		}

		/// <summary>
		/// Retrieves a single project document by its id
		/// </summary>
		/// <param name="attachmentId">The id of the attachment to retrieve</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="credentials">The credentials for the API</param>
		/// <returns>The document data object</returns>
		/// <example>
		/// remoteDocument = spiraImportExport.Document_RetrieveById(credentials, projectId, attachmentId3);
		/// </example>
		/// <remarks>
		/// 1) For files it does not include the raw file data, you need to use Document_OpenById
		/// 2) It also retrieves the list of document versions
		/// </remarks>
		public RemoteDocument Document_RetrieveById(RemoteCredentials credentials, int projectId, int attachmentId)
		{
			const string METHOD_NAME = "Document_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we can view documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Call the business object to actually retrieve the project attachment dataset
				AttachmentManager attachmentManager = new AttachmentManager();
				ProjectAttachmentView projectAttachment = attachmentManager.RetrieveForProjectById2(projectId, attachmentId);
				ArtifactCustomProperty artifactCustomProperty = new CustomPropertyManager().ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, attachmentId, DataModel.Artifact.ArtifactTypeEnum.Document, true);

				//Populate the API data object
				RemoteDocument remoteDocument = new RemoteDocument();
				PopulationFunctions.PopulateDocument(remoteDocument, projectAttachment);
				PopulationFunctions.PopulateCustomProperties(remoteDocument, artifactCustomProperty);

				//Now get the list of versions and populate
				List<AttachmentVersionView> attachmentVersions = attachmentManager.RetrieveVersions(attachmentId);
				remoteDocument.Versions = new List<RemoteDocumentVersion>();
				foreach (AttachmentVersionView attachmentVersion in attachmentVersions)
				{
					RemoteDocumentVersion remoteDocumentVersion = new RemoteDocumentVersion();
					PopulationFunctions.PopulateDocumentVersion(remoteDocumentVersion, attachmentVersion);
					remoteDocument.Versions.Add(remoteDocumentVersion);
				}

				//Finally get the list of artifacts this document is attached to
				List<ArtifactAttachmentView> artifactAttachments = new ArtifactLinkManager().RetrieveByAttachmentId(projectId, attachmentId);
				if (artifactAttachments != null && artifactAttachments.Count > 0)
				{
					remoteDocument.AttachedArtifacts = new List<RemoteLinkedArtifact>();
					foreach (ArtifactAttachmentView artifactAttachment in artifactAttachments)
					{
						RemoteLinkedArtifact remoteLinkedArtifact = new RemoteLinkedArtifact();
						PopulationFunctions.PopulateArtifactAttachment(remoteLinkedArtifact, artifactAttachment);
						remoteDocument.AttachedArtifacts.Add(remoteLinkedArtifact);
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteDocument;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, Resources.Messages.Services_DocumentNotFound);
				Logger.Flush();
				return null;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a filtered list of documents/attachments in a project attached to a specific artifact
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <param name="artifactId">The id of the artifact we want the attachments for</param>
		/// <param name="artifactTypeId">
		/// The id of the type of artifact we want to retrieve the documents for:
		/// (Requirement = 1,
		///	TestCase = 2,
		/// Incident = 3,
		///	Release = 4,
		///	TestRun = 5,
		///	Task = 6,
		/// TestStep = 7,
		/// TestSet = 8)
		/// </param>
		/// <returns>List of documents</returns>
		/// <example>
		/// remoteFilter = new RemoteFilter();
		/// remoteFilter.PropertyName = "Filename";
		/// remoteFilter.StringValue = "test_data2";
		/// remoteSort.PropertyName = "AttachmentId";
		/// remoteSort.SortAscending = true;
		/// remoteDocuments = spiraImportExport.Document_RetrieveForArtifact(credentials, projectId, (int)DataModel.Artifact.ArtifactTypeEnum.TestCase, testCaseId1, new RemoteFilter[] { remoteFilter }, remoteSort);
		/// </example>
		public List<RemoteDocument> Document_RetrieveForArtifact(RemoteCredentials credentials, int projectId, int artifactTypeId, int artifactId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort)
		{
			const string METHOD_NAME = "Document_RetrieveForArtifact";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view the artifact type in question
			if (!IsAuthorized(credentials, projectId, (Artifact.ArtifactTypeEnum)artifactTypeId, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}
			DataModel.Artifact.ArtifactTypeEnum artifactType = (DataModel.Artifact.ArtifactTypeEnum)artifactTypeId;

			//Make sure we can view documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Extract the filters from the provided API object
				Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

				//Call the business object to actually retrieve the project attachment dataset
				AttachmentManager attachmentManager = new AttachmentManager();
				List<ProjectAttachmentView> attachments = attachmentManager.RetrieveByArtifactId(projectId, artifactId, artifactType, remoteSort.PropertyName, remoteSort.SortAscending, 1, Int32.MaxValue, filters, 0);
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Document, false);

				//Populate the API data object and return
				List<RemoteDocument> remoteDocuments = new List<RemoteDocument>();
				foreach (ProjectAttachmentView projectAttachment in attachments)
				{
					//Create and populate the row
					RemoteDocument remoteDocument = new RemoteDocument();
					PopulationFunctions.PopulateDocument(remoteDocument, projectAttachment);
					PopulationFunctions.PopulateCustomProperties(remoteDocument, projectAttachment, customProperties);
					remoteDocuments.Add(remoteDocument);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteDocuments;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>Adds an existing attachment to the specified artifact.</summary>
		/// <param name="artifactTypeId">The id of the type of artifact we want to retrieve the documents for:
		/// (Requirement = 1,
		///	TestCase = 2,
		/// Incident = 3,
		///	Release = 4,
		///	TestRun = 5,
		///	Task = 6,
		/// TestStep = 7,
		/// TestSet = 8)</param>
		/// <param name="artifactId">The id of the artifact we want the attachments for</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="attachmentId"></param>
		public void Document_AddToArtifactId(RemoteCredentials credentials, int projectId, int artifactTypeId, int artifactId, int attachmentId)
		{
			const string METHOD_NAME = CLASS_NAME + "Document_AddToArtifactId";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to modify or create the artifact type in question (could be either)
			DataModel.Artifact.ArtifactTypeEnum artifactType = (DataModel.Artifact.ArtifactTypeEnum)artifactTypeId;
			if (!IsAuthorized(credentials, projectId, artifactType, Project.PermissionEnum.Modify) && !IsAuthorized(credentials, projectId, (Artifact.ArtifactTypeEnum)artifactTypeId, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyArtifact);
			}

			//Make sure we can view documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				new AttachmentManager().InsertArtifactAssociation(projectId, attachmentId, artifactId, artifactType);
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}

			Logger.LogExitingEvent(METHOD_NAME);
		}

		/// <summary>
		/// Adds a new document (file) into the system and associates it with the provided artifact (optional)
		/// and project folder/type (optional)
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteDocument">The new document object (primary key will be empty)</param>
		/// <param name="binaryData">A byte-array containing the attachment itself in binary form</param>
		/// <returns>
		/// The populated document object - including the primary key and default values for project attachment type
		/// and project folder if they were not specified
		/// </returns>
		/// <example>
		/// byte[] attachmentData = unicodeEncoding.GetBytes("Test Attachment Data To Be Stored");
		/// RemoteDocument remoteDocument = new RemoteDocument();
		/// remoteDocument.FilenameOrUrl = "test_data.xls";
		/// remoteDocument.Description = "Sample Test Case Attachment";
		/// remoteDocument.AuthorId = userId2;
		/// remoteDocument.ArtifactId = testCaseId1;
		/// remoteDocument.ArtifactTypeId = (int)DataModel.Artifact.ArtifactTypeEnum.TestCase;
		/// attachmentId1 = spiraImportExport.Document_AddFile(credentials, remoteDocument, attachmentData).AttachmentId.Value;
		/// </example>
		public RemoteDocument Document_AddFile(RemoteCredentials credentials, RemoteDocument remoteDocument, byte[] binaryData)
		{
			const string METHOD_NAME = "Document_AddFile";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a Attachment ID specified
			if (remoteDocument.AttachmentId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_AttachmentIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteDocument.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to add documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedAddDocuments);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Default to the authenticated user if no author provided
				int authorId = userId;
				if (remoteDocument.AuthorId.HasValue)
				{
					authorId = remoteDocument.AuthorId.Value;
				}

				//Handle any nullable values safely
				string description = null;
				string version = null;
				string tags = null;
				if (!String.IsNullOrEmpty(remoteDocument.Description))
				{
					description = remoteDocument.Description;
				}
				if (!String.IsNullOrEmpty(remoteDocument.CurrentVersion))
				{
					version = remoteDocument.CurrentVersion;
				}
				if (!String.IsNullOrEmpty(remoteDocument.Tags))
				{
					tags = remoteDocument.Tags;
				}

				int? documentStatusId = null;
				//If the template setting allows bulk edit of status, set the status, otherwise leave it null (so manager will use the default)
				if (remoteDocument.DocumentStatusId.HasValue)
				{
					ProjectTemplateSettings projectTemplateSettings = new ProjectTemplateSettings(projectTemplateId);
					if (projectTemplateSettings.Workflow_BulkEditCanChangeStatus)
					{
						documentStatusId = remoteDocument.DocumentStatusId.Value;
					}
				}

				//Now insert the attachment
				remoteDocument.ProjectId = projectId;
				AttachmentManager attachmentManager = new AttachmentManager();
				remoteDocument.AttachmentId = attachmentManager.Insert(
				   remoteDocument.ProjectId,
				   remoteDocument.FilenameOrUrl,
				   description,
				   authorId,
				   binaryData,
				   null,
				   Artifact.ArtifactTypeEnum.None,
				   version,
				   tags,
				   remoteDocument.DocumentTypeId,
				   remoteDocument.ProjectAttachmentFolderId,
				   documentStatusId
				   );

				//Link to any specified artifacts
				if (remoteDocument.AttachedArtifacts != null && remoteDocument.AttachedArtifacts.Count > 0)
				{
					foreach (RemoteLinkedArtifact attachedArtifact in remoteDocument.AttachedArtifacts)
					{
						attachmentManager.InsertArtifactAssociation(projectId, remoteDocument.AttachmentId.Value, attachedArtifact.ArtifactId, (Artifact.ArtifactTypeEnum)attachedArtifact.ArtifactTypeId);
						//If this is for a test run, need to update the test run's temporary GUID URL for any embedded images
						if (attachedArtifact.ArtifactTypeId == (int)Artifact.ArtifactTypeEnum.TestRun && TestRunManager.IsDescriptionGuidUrl(remoteDocument.Description))
						{
							new TestRunManager().TestRun_UpdateAttachmentImgUrls(projectId, attachedArtifact.ArtifactId, remoteDocument.Description, remoteDocument.AttachmentId.Value);
						}
					}
				}

				//Now we need to populate any custom properties
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				ArtifactCustomProperty artifactCustomProperty = null;
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteDocument, remoteDocument.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Document, remoteDocument.AttachmentId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Send a notification
				attachmentManager.SendCreationNotification(projectId, remoteDocument.AttachmentId.Value, artifactCustomProperty, null);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDocument;
		}

		/// <summary>
		/// Adds a new document (url) into the system and associates it with the provided artifact (optional)
		/// and project folder/type (optional)
		/// </summary>
		/// <param name="remoteDocument">The new document object (primary key will be empty). PopulationFunctions.Populate the FilenameOrUrl field with the URL</param>
		/// <param name="credentials">The API credentials</param>
		/// <returns>
		/// The populated document object - including the primary key and default values for project attachment type
		/// and project folder if they were not specified
		/// </returns>
		/// <example>
		/// remoteDocument = new RemoteDocument();
		/// remoteDocument.FilenameOrUrl = "http://www.tempuri.org/test123.htm";
		/// remoteDocument.Description = "Sample Test Case URL";
		/// remoteDocument.AuthorId = userId2;
		/// remoteDocument.ArtifactId = testCaseId2;
		/// remoteDocument.ArtifactTypeId = (int)DataModel.Artifact.ArtifactTypeEnum.TestCase;
		/// attachmentId3 = spiraImportExport.Document_AddUrl(credentials, remoteDocument).AttachmentId.Value;
		/// </example>
		public RemoteDocument Document_AddUrl(RemoteCredentials credentials, RemoteDocument remoteDocument)
		{
			const string METHOD_NAME = "Document_AddUrl";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a Attachment ID specified
			if (remoteDocument.AttachmentId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_AttachmentIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteDocument.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to add documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedAddDocuments);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Default to the authenticated user if no author provided
				int authorId = userId;
				if (remoteDocument.AuthorId.HasValue)
				{
					authorId = remoteDocument.AuthorId.Value;
				}

				//Handle any nullable values safely
				string description = null;
				string version = null;
				string tags = null;
				if (!String.IsNullOrEmpty(remoteDocument.Description))
				{
					description = remoteDocument.Description;
				}
				if (!String.IsNullOrEmpty(remoteDocument.CurrentVersion))
				{
					version = remoteDocument.CurrentVersion;
				}
				if (!String.IsNullOrEmpty(remoteDocument.Tags))
				{
					tags = remoteDocument.Tags;
				}

				int? documentStatusId = null;
				//If the remote artifact contains a status AND the template setting allows bulk edit of status, set the status, otherwise leave it null (so manager will use the default)
				if (remoteDocument.DocumentStatusId.HasValue)
				{
					ProjectTemplateSettings projectTemplateSettings = new ProjectTemplateSettings(projectTemplateId);
					if (projectTemplateSettings.Workflow_BulkEditCanChangeStatus)
					{
						documentStatusId = remoteDocument.DocumentStatusId.Value;
					}
				}

				//Now insert the attachment
				remoteDocument.ProjectId = projectId;
				AttachmentManager attachmentManager = new AttachmentManager();
				remoteDocument.AttachmentId = attachmentManager.Insert(
				   remoteDocument.ProjectId,
				   remoteDocument.FilenameOrUrl,
				   description,
				   authorId,
				   null,
				   Artifact.ArtifactTypeEnum.None,
				   version,
				   tags,
				   remoteDocument.DocumentTypeId,
				   remoteDocument.ProjectAttachmentFolderId,
				   documentStatusId
				   );

				//Link to any specified artifacts
				if (remoteDocument.AttachedArtifacts != null && remoteDocument.AttachedArtifacts.Count > 0)
				{
					foreach (RemoteLinkedArtifact attachedArtifact in remoteDocument.AttachedArtifacts)
					{
						attachmentManager.InsertArtifactAssociation(projectId, remoteDocument.AttachmentId.Value, attachedArtifact.ArtifactId, (Artifact.ArtifactTypeEnum)attachedArtifact.ArtifactTypeId);
					}
				}

				//Now we need to populate any custom properties
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				ArtifactCustomProperty artifactCustomProperty = null;
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteDocument, remoteDocument.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Document, remoteDocument.AttachmentId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Send a notification
				attachmentManager.SendCreationNotification(projectId, remoteDocument.AttachmentId.Value, artifactCustomProperty, null);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDocument;
		}

		/// <summary>
		/// Adds a new version to a file attachment in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="remoteDocumentVersion">The version data object</param>
		/// <param name="binaryData">A byte-array containing the attachment itself in binary form</param>
		/// <param name="makeCurrent">Should we make this the current version</param>
		/// <returns>The version data object with the primary key populated</returns>
		public RemoteDocumentVersion Document_AddFileVersion(RemoteCredentials credentials, int projectId, RemoteDocumentVersion remoteDocumentVersion, byte[] binaryData, bool makeCurrent)
		{
			const string METHOD_NAME = "Document_AddFileVersion";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a Attachment Version ID specified
			if (remoteDocumentVersion.AttachmentVersionId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_AttachmentVersionIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to add documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedAddDocuments);
			}

			try
			{
				//Retrieve the attachment and make sure that they are of the same type
				AttachmentManager attachmentManager = new AttachmentManager();

				//Default to the authenticated user if no author provided
				int authorId = userId;
				if (remoteDocumentVersion.AuthorId.HasValue)
				{
					authorId = remoteDocumentVersion.AuthorId.Value;
				}

				//Handle any nullable values safely
				string description = null;
				string version = null;
				if (!String.IsNullOrEmpty(remoteDocumentVersion.Description))
				{
					description = remoteDocumentVersion.Description;
				}
				if (!String.IsNullOrEmpty(remoteDocumentVersion.VersionNumber))
				{
					version = remoteDocumentVersion.VersionNumber;
				}

				//Now insert the attachment version
				remoteDocumentVersion.AttachmentVersionId = attachmentManager.InsertVersion(
				   projectId,
				   remoteDocumentVersion.AttachmentId,
				   remoteDocumentVersion.FilenameOrUrl,
				   description,
				   authorId,
				   binaryData,
				   version,
				   makeCurrent
				   );
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDocumentVersion;
		}

		/// <summary>
		/// Adds a new version to a URL attachment in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="remoteDocumentVersion">The version data object</param>
		/// <param name="makeCurrent">Should we make this the current version</param>
		/// <returns>The version data object with the primary key populated</returns>
		public RemoteDocumentVersion Document_AddUrlVersion(RemoteCredentials credentials, int projectId, RemoteDocumentVersion remoteDocumentVersion, bool makeCurrent)
		{
			const string METHOD_NAME = "Document_AddUrlVersion";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a Attachment Version ID specified
			if (remoteDocumentVersion.AttachmentVersionId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_AttachmentVersionIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to add documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedAddDocuments);
			}

			try
			{
				//Retrieve the attachment to make sure it exists
				AttachmentManager attachmentManager = new AttachmentManager();
				Attachment attachment = attachmentManager.RetrieveById(remoteDocumentVersion.AttachmentId);

				//Default to the authenticated user if no author provided
				int authorId = userId;
				if (remoteDocumentVersion.AuthorId.HasValue)
				{
					authorId = remoteDocumentVersion.AuthorId.Value;
				}

				//Handle any nullable values safely
				string description = null;
				string version = null;
				if (!String.IsNullOrEmpty(remoteDocumentVersion.Description))
				{
					description = remoteDocumentVersion.Description;
				}
				if (!String.IsNullOrEmpty(remoteDocumentVersion.VersionNumber))
				{
					version = remoteDocumentVersion.VersionNumber;
				}

				//Now insert the attachment version
				remoteDocumentVersion.AttachmentVersionId = attachmentManager.InsertVersion(
				   projectId,
				   remoteDocumentVersion.AttachmentId,
				   remoteDocumentVersion.FilenameOrUrl,
				   description,
				   authorId,
				   version,
				   makeCurrent
				   );
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDocumentVersion;
		}

		/// <summary>
		/// Returns the actual binary content of a specific version of an attachment in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="attachmentVersionId">The id of the attachment version to be retrieved</param>
		/// <returns>An array of bytes representing the attachment content</returns>
		/// <example>
		/// byte[] attachmentData = spiraImportExport.Document_OpenVersion(credentials, projectId, attachmentId1, attachmentVersionId);
		/// </example>
		public byte[] Document_OpenVersion(RemoteCredentials credentials, int projectId, int attachmentVersionId)
		{
			const string METHOD_NAME = "Document_OpenVersion";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we can view documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				//Call the business object to actually retrieve the attachment data
				AttachmentManager attachmentManager = new AttachmentManager();
				FileStream stream = attachmentManager.OpenByVersionId(attachmentVersionId);

				//Extract the data from the stream in byte form
				byte[] attachmentBytes = new byte[stream.Length];
				stream.Read(attachmentBytes, 0, (int)stream.Length);

				//Return the array of bytes
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return attachmentBytes;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, Resources.Messages.Services_DocumentNotFound);
				Logger.Flush();
				return null;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes an attachment version from the project completely
		/// </summary>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="attachmentVersionId">The id of the attachment version to delete</param>
		/// <remarks>
		/// To delete a version you must have modify permissions for documents. You can't delete the current version.
		/// </remarks>
		public void Document_DeleteVersion(RemoteCredentials credentials, int projectId, int attachmentVersionId)
		{
			const string METHOD_NAME = "Document_DeleteVersion";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to modify documents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Document, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyDocuments);
			}

			try
			{
				//Now delete the attachment version
				AttachmentManager attachmentManager = new AttachmentManager();
				attachmentManager.DeleteVersion(projectId, attachmentVersionId, userId);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		#endregion Document Methods

		#region User Methods

		/// <summary>Creates a new user in the system and adds them to the current project as the specified role</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="password">The new password for the user (leave empty if an LDAP user)</param>
		/// <param name="passwordQuestion">The new password retrieval question for the user (leave empty if an LDAP user)</param>
		/// <param name="passwordAnswer">The new password retrieval answer for the user (leave empty if an LDAP user)</param>
		/// <param name="remoteUser">The new user object (primary key will be empty)</param>
		/// <param name="projectRoleId">The project role for the user (leave as null to not add user to current project)</param>
		/// <param name="projectId">The id of the project (leave null to not add user to the current project)</param>
		/// <returns>The populated user object - including the primary key</returns>
		public RemoteUser User_Create(RemoteCredentials credentials, RemoteUser remoteUser, string password, string passwordQuestion, string passwordAnswer, int? projectId, int? projectRoleId)
		{
			const string METHOD_NAME = "User_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a user id specified
			if (remoteUser.UserId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_UserIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int authenticatedUserId = credentials.UserId;

			//Make sure we are connected to a project if a role is specified
			if (projectId.HasValue && projectRoleId.HasValue && !IsAuthorized(credentials, projectId.Value))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to create users (i.e. is a system admin)
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateUsers);
			}

			//Make sure we have a populated first and last name so that we don't have the user created without a valid profile
			if (String.IsNullOrEmpty(remoteUser.FirstName) || String.IsNullOrEmpty(remoteUser.LastName))
			{
				throw CreateFault("DataValidationError", Resources.Messages.Services_FirstOrLastNameNotProvided);
			}

			try
			{
				//If a user already exists with the ID, simply return that back instead
				Business.ProjectManager projectManager = new Business.ProjectManager();
				MembershipUser membershipUser = Membership.GetUser(remoteUser.UserName);
				if (membershipUser != null)
				{
					int existingUserId = (int)membershipUser.ProviderUserKey;
					remoteUser.UserId = existingUserId;

					//Now add the user to the current project as the specified role
					if (projectId.HasValue && projectRoleId.HasValue)
					{
						//Ignore any duplicate key errors
						try
						{
							projectManager.InsertUserMembership(existingUserId, projectId.Value, projectRoleId.Value);
						}
						catch (ProjectDuplicateMembershipRecordException)
						{
							//Ignore this error
						}
						catch (EntityConstraintViolationException)
						{
							//Ignore error due to duplicate row
						}
					}

					return remoteUser;
				}

				//Next create the user, if it exists already ignore the exception
				MembershipCreateStatus status;
				SpiraMembershipProvider membershipProvider = (SpiraMembershipProvider)Membership.Provider;
				membershipUser = membershipProvider.CreateUser(remoteUser.UserName, password, remoteUser.EmailAddress, passwordQuestion, passwordAnswer, remoteUser.Approved, remoteUser.LdapDn, remoteUser.RssToken, out status);
				if (status == MembershipCreateStatus.Success)
				{
					if (membershipUser == null)
					{
						string message = "Unable to create user - " + status.ToString();
						Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, message);
						Logger.Flush();
						throw CreateFault(status.ToString(), message);
					}

					//Now we need to add the profile information
					ProfileEx profile = new ProfileEx(remoteUser.UserName);
					profile.FirstName = remoteUser.FirstName;
					profile.LastName = remoteUser.LastName;
					profile.MiddleInitial = remoteUser.MiddleInitial;
					if (projectRoleId.HasValue)
					{
						profile.LastOpenedProjectId = projectId;
					}
					profile.IsEmailEnabled = true;
					profile.Department = remoteUser.Department;
					profile.IsAdmin = remoteUser.Admin;
					profile.Save();
				}
				else if (status == MembershipCreateStatus.DuplicateUserName)
				{
					//If we get this error we need to instead return the user record already in the system
					membershipUser = Membership.GetUser(remoteUser.UserName);
				}
				else
				{
					string message = "Unable to create user - " + status.ToString();
					Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, message);
					Logger.Flush();
					throw CreateFault(status.ToString(), message);
				}

				//Now populate the user id onto the object
				int userId = (int)membershipUser.ProviderUserKey;
				remoteUser.UserId = userId;

				//Now add the user to the current project as the specified role
				//Ignore any duplicate key errors
				if (projectId.HasValue && projectRoleId.HasValue)
				{
					try
					{
						projectManager.InsertUserMembership(userId, projectId.Value, projectRoleId.Value);
					}
					catch (ProjectDuplicateMembershipRecordException)
					{
						//Ignore this error
					}
					catch (EntityConstraintViolationException)
					{
						//Ignore error due to duplicate row
					}
				}
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteUser;
		}

		/// <summary>Retrieves a single user in the system</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="userId">The id of the user</param>
		/// <returns>The user object</returns>
		public RemoteUser User_RetrieveById(RemoteCredentials credentials, int userId)
		{
			const string METHOD_NAME = "User_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			else
			{
				//Retrieve the user dataset
				Business.UserManager userManager = new Business.UserManager();

				//If the user was not found, just return null
				try
				{
					User user = userManager.GetUserById(userId);

					//Populate the API data object and return
					RemoteUser remoteUser = new RemoteUser();
					PopulationFunctions.PopulateUser(remoteUser, user, credentials.IsSystemAdmin);

					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();
					return remoteUser;
				}
				catch (ArtifactNotExistsException)
				{
					Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested user");
					Logger.Flush();
					return null;
				}
			}
		}

		/// <summary>
		/// Updates an existing user in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteUser">The updated user</param>
		public void User_Update(RemoteCredentials credentials, RemoteUser remoteUser)
		{
			const string METHOD_NAME = "User_Updates";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have a user id specified
			if (!remoteUser.UserId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNull", Resources.Messages.Services_UserIdIsNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int authenticatedUserId = credentials.UserId;

			//Make sure we have permissions to modify users (i.e. is a system admin or this is the user's own profile)
			if (!credentials.IsSystemAdmin && remoteUser.UserId.Value != authenticatedUserId)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyUsers);
			}

			//Retrieve the user dataset
			Business.UserManager userManager = new Business.UserManager();

			try
			{
				//Get the user with profile
				User user = userManager.GetUserById(remoteUser.UserId.Value);

				//Update from the API object
				UpdateFunctions.UpdateUser(user, remoteUser);
				userManager.Update(user);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested user");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Retrieves a list of all the active users in the system (all projects)
		/// <param name="credentials">The API credentials</param>
		/// </summary>
		public List<RemoteUser> User_Retrieve(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "User_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we have permissions to retrieve all users (i.e. is a system admin)
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewAllUsers);
			}

			//Retrieve the user dataset
			Business.UserManager userManager = new Business.UserManager();

			try
			{
				List<User> users = userManager.GetUsers(true);

				//Populate the API data objects and return
				List<RemoteUser> remoteUsers = new List<RemoteUser>();
				foreach (User user in users)
				{
					RemoteUser remoteUser = new RemoteUser();
					PopulationFunctions.PopulateUser(remoteUser, user, true);
					remoteUsers.Add(remoteUser);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteUsers;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>Retrieves a single user in the system by user-name</summary>
		/// <param name="userName">The login of the user</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="includeInactive">Should we include inactive</param>
		/// <returns>The user object</returns>
		public RemoteUser User_RetrieveByUserName(RemoteCredentials credentials, string userName, bool includeInactive)
		{
			const string METHOD_NAME = "User_RetrieveByUserName";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			else
			{
				//Retrieve the user dataset
				Business.UserManager userManager = new Business.UserManager();

				//If the user was not found, just return null
				try
				{
					User user = userManager.GetUserByLogin(userName, false, includeInactive);

					//Populate the API data object and return
					RemoteUser remoteUser = new RemoteUser();
					PopulationFunctions.PopulateUser(remoteUser, user, credentials.IsSystemAdmin);

					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();
					return remoteUser;
				}
				catch (ArtifactNotExistsException)
				{
					Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested user");
					Logger.Flush();
					return null;
				}
			}
		}

		/// <summary>Tries to delete the specified user ID. Note that this function will fail if any other foreign keys (fields) in other tables are assigned to the user that is specified.) Must be connected to the API as the root Administrator.</summary>
		/// <param name="userId">The user ID to delete.</param>
		/// <param name="credentials">The API credentials</param>
		public void User_Delete(RemoteCredentials credentials, int userId)
		{
			const string METHOD_NAME = CLASS_NAME + "User_Delete";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we have permissions to delete users (i.e. is a system admin)
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			try
			{
				bool success = new Business.UserManager().DeleteUser(userId, false);
				if (!success)
				{
					throw CreateFault("DeleteUserFailed", "Failed to delete user.");
				}
			}
			catch (Exception ex)
			{
				Logger.LogErrorEvent(METHOD_NAME, ex, "Trying to delete specified user #" + userId.ToString());
				throw CreateFault(ex.GetType().ToString(), "Unable to delete user.");
			}

			Logger.LogExitingEvent(METHOD_NAME);
		}

		#endregion User Methods

		#region Incident Methods

		/// <summary>Returns the number of incidents that match the filter.</summary>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <returns>The number of items.</returns>
		public long Incident_Count(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters)
		{
			const string METHOD_NAME = CLASS_NAME + "Incident_Count";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the incident dataset
			long retNum = new IncidentManager().Count(projectId, filters, 0, false);

			Logger.LogExitingEvent(METHOD_NAME);
			return retNum;
		}

		/// <summary>
		/// Retrieves a list of incidents in the system that match the provided filter/sort
		/// </summary>
		/// <param name="projectId">The id of the project</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of incidents</returns>
		public List<RemoteIncident> Incident_Retrieve(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = "Incident_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the incident dataset
			IncidentManager incidentManager = new IncidentManager();
			List<IncidentView> incidents = incidentManager.Retrieve(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Incident, false);

			//Populate the API data object and return
			List<RemoteIncident> remoteIncidents = new List<RemoteIncident>();
			foreach (IncidentView incident in incidents)
			{
				//Create and populate the row
				RemoteIncident remoteIncident = new RemoteIncident();
				PopulationFunctions.PopulateIncident(remoteIncident, incident);
				PopulationFunctions.PopulateCustomProperties(remoteIncident, incident, customProperties);
				remoteIncidents.Add(remoteIncident);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteIncidents;
		}

		/// <summary>
		/// Retrieves a list of incidents in the system that are linked to a specific test run step
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="testRunStepId">The id of the test run step</param>
		/// <returns>List of incidents</returns>
		public List<RemoteIncident> Incident_RetrieveByTestRunStep(RemoteCredentials credentials, int projectId, int testRunStepId)
		{
			const string METHOD_NAME = "Incident_RetrieveByTestRunStep";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Call the business object to actually retrieve the incident dataset
			IncidentManager incidentManager = new IncidentManager();
			List<IncidentView> incidents = incidentManager.RetrieveByTestRunStepId(testRunStepId);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Incident, false);

			//For performance reasons we just return the provided test run step, not all of the ones
			List<int> testRunStepIds = new List<int>() { testRunStepId };

			//Populate the API data object and return
			List<RemoteIncident> remoteIncidents = new List<RemoteIncident>();
			foreach (IncidentView incident in incidents)
			{
				//Create and populate the row, making sure that the incidents belong to the appropriate project (for security reasons)
				if (incident.ProjectId == projectId)
				{
					RemoteIncident remoteIncident = new RemoteIncident();
					PopulationFunctions.PopulateIncident(remoteIncident, incident, testRunStepIds);
					PopulationFunctions.PopulateCustomProperties(remoteIncident, incident, customProperties);
					remoteIncidents.Add(remoteIncident);
				}
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteIncidents;
		}

		/// <summary>
		/// Retrieves a list of incidents in the system that are linked to a specific test step
		/// (either directly or indirectly through test runs)
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="testStepId">The id of the test step</param>
		/// <returns>List of incidents</returns>
		public List<RemoteIncident> Incident_RetrieveByTestStep(RemoteCredentials credentials, int projectId, int testStepId)
		{
			const string METHOD_NAME = "Incident_RetrieveByTestStep";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Call the business object to actually retrieve the incident dataset
			IncidentManager incidentManager = new IncidentManager();
			List<IncidentView> incidents = incidentManager.RetrieveByTestStepId(testStepId);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Incident, false);

			//Populate the API data object and return
			List<RemoteIncident> remoteIncidents = new List<RemoteIncident>();
			foreach (IncidentView incident in incidents)
			{
				//Create and populate the row, making sure that the incidents belong to the appropriate project (for security reasons)
				if (incident.ProjectId == projectId)
				{
					RemoteIncident remoteIncident = new RemoteIncident();
					PopulationFunctions.PopulateIncident(remoteIncident, incident);
					PopulationFunctions.PopulateCustomProperties(remoteIncident, incident, customProperties);
					remoteIncidents.Add(remoteIncident);
				}
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteIncidents;
		}

		/// <summary>
		/// Retrieves a list of incidents in the system that are linked to a specific test case
		/// (either through test runs or test steps)
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <param name="openOnly">Do we only want incidents that are in one of the 'open' statuses</param>
		/// <returns>List of incidents</returns>
		public List<RemoteIncident> Incident_RetrieveByTestCase(RemoteCredentials credentials, int projectId, int testCaseId, bool openOnly)
		{
			const string METHOD_NAME = "Incident_RetrieveByTestCase";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Call the business object to actually retrieve the incident dataset
			IncidentManager incidentManager = new IncidentManager();
			List<IncidentView> incidents = incidentManager.RetrieveByTestCaseId(testCaseId, openOnly);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Incident, false);

			//Populate the API data object and return
			List<RemoteIncident> remoteIncidents = new List<RemoteIncident>();
			foreach (IncidentView incident in incidents)
			{
				//Create and populate the row, making sure that the incidents belong to the appropriate project (for security reasons)
				if (incident.ProjectId == projectId)
				{
					RemoteIncident remoteIncident = new RemoteIncident();
					PopulationFunctions.PopulateIncident(remoteIncident, incident);
					PopulationFunctions.PopulateCustomProperties(remoteIncident, incident, customProperties);
					remoteIncidents.Add(remoteIncident);
				}
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteIncidents;
		}

		/// <summary>
		/// Retrieves all new incidents added in the system since the date specified
		/// </summary>
		/// <param name="projectId">The id of the project</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="startRow">The starting row</param>
		/// <param name="numberOfRows">The maximum number of rows to return</param>
		/// <param name="creationDate">The date after which the incident needs to have been created</param>
		/// <returns>List of incidents</returns>
		public List<RemoteIncident> Incident_RetrieveNew(RemoteCredentials credentials, int projectId, DateTime creationDate, int startRow, int numberOfRows)
		{
			const string METHOD_NAME = "Incident_RetrieveNew";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Call the business object to actually retrieve the incident dataset
			IncidentManager incidentManager = new IncidentManager();
			Hashtable filters = new Hashtable();
			Common.DateRange dateRange = new Common.DateRange();
			dateRange.StartDate = creationDate;
			dateRange.ConsiderTimes = true;
			filters.Add("CreationDate", dateRange);
			List<IncidentView> incidents = incidentManager.Retrieve(projectId, "CreationDate", true, startRow, numberOfRows, filters, 0);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Incident, false);

			//Populate the API data object and return
			List<RemoteIncident> remoteIncidents = new List<RemoteIncident>();
			foreach (IncidentView incident in incidents)
			{
				//Create and populate the row
				RemoteIncident remoteIncident = new RemoteIncident();
				PopulationFunctions.PopulateIncident(remoteIncident, incident);
				PopulationFunctions.PopulateCustomProperties(remoteIncident, incident, customProperties);
				remoteIncidents.Add(remoteIncident);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteIncidents;
		}

		/// <summary>
		/// Retrieves all open incidents owned by the currently authenticated user
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <returns>List of incidents</returns>
		public List<RemoteIncident> Incident_RetrieveForOwner(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Incident_RetrieveForOwner";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//We assume if they are specified as owner, they have permissions since we can't easily
			//check cross-project permissions in one query
			try
			{
				//Call the business object to actually retrieve the incident dataset
				IncidentManager incidentManager = new IncidentManager();
				List<IncidentView> incidents = incidentManager.RetrieveOpenByOwnerId(userId, null, null);

				//Get the custom property definitions - for all projects
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(Artifact.ArtifactTypeEnum.Incident);

				//Populate the API data object and return
				List<RemoteIncident> remoteIncidents = new List<RemoteIncident>();
				foreach (IncidentView incident in incidents)
				{
					//Create and populate the row
					RemoteIncident remoteIncident = new RemoteIncident();
					PopulationFunctions.PopulateIncident(remoteIncident, incident);
					PopulationFunctions.PopulateCustomProperties(remoteIncident, incident, customProperties);
					remoteIncidents.Add(remoteIncident);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteIncidents;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the incident resolutions for an incident
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The Id of the project</param>
		/// <param name="incidentId">The id of the incident</param>
		/// <returns>List of incident comments</returns>
		public List<RemoteComment> Incident_RetrieveComments(RemoteCredentials credentials, int projectId, int incidentId)
		{
			const string METHOD_NAME = "Incident_RetrieveComments";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Call the business object to actually retrieve the incident resolutions
			IncidentManager incidentManager = new IncidentManager();
			try
			{
				Incident incident = incidentManager.RetrieveById(incidentId, true);

				//Sort the resolutions by oldest first
				List<IncidentResolution> resolutions = incident.Resolutions.OrderBy(r => r.CreationDate).ToList();

				//Populate the API data object and return
				List<RemoteComment> remoteIncidentResolutions = new List<RemoteComment>();
				foreach (IncidentResolution resolution in resolutions)
				{
					//Create and populate the row
					RemoteComment remoteIncidentResolution = new RemoteComment();
					remoteIncidentResolution.CommentId = resolution.IncidentResolutionId;
					remoteIncidentResolution.ArtifactId = resolution.IncidentId;
					remoteIncidentResolution.UserId = resolution.CreatorId;
					remoteIncidentResolution.Text = resolution.Resolution;
					remoteIncidentResolution.CreationDate = resolution.CreationDate;
					remoteIncidentResolution.IsDeleted = false;
					remoteIncidentResolution.UserName = resolution.Creator.FullName;
					remoteIncidentResolutions.Add(remoteIncidentResolution);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteIncidentResolutions;
			}
			catch (ArtifactNotExistsException)
			{
				//Can't locate the incident so return back no resolutions
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Adds new incident comments to incidents in the system
		/// </summary>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteComments">List of new comments to add</param>
		/// <returns>The list of comments with the ArtifactId populated</returns>
		public List<RemoteComment> Incident_AddComments(RemoteCredentials credentials, int projectId, List<RemoteComment> remoteComments)
		{
			const string METHOD_NAME = "Incident_AddComments";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to modify incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyIncidents);
			}

			//Iterate through the provided resolutions, inserting them as needed
			IncidentManager incidentManager = new IncidentManager();
			foreach (RemoteComment remoteComment in remoteComments)
			{
				//If the creator is not specified, use the current user
				int creatorId = userId;
				if (remoteComment.UserId.HasValue)
				{
					creatorId = remoteComment.UserId.Value;
				}
				DateTime creationDate = DateTime.UtcNow;
				if (remoteComment.CreationDate.HasValue)
				{
					creationDate = remoteComment.CreationDate.Value;
				}

				remoteComment.CommentId = incidentManager.InsertResolution(
				   remoteComment.ArtifactId,
				   remoteComment.Text,
				   creationDate,
				   creatorId,
				   true
				   );
			}

			//Finally return the populated incident comment list
			return remoteComments;
		}

		/// <summary>
		/// Retrieves a single incident in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="incidentId">The id of the incident</param>
		/// <returns>Incident object</returns>
		public RemoteIncident Incident_RetrieveById(RemoteCredentials credentials, int projectId, int incidentId)
		{
			const string METHOD_NAME = "Incident_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Call the business object to actually retrieve the incident dataset
			IncidentManager incidentManager = new IncidentManager();

			//If the incident was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				IncidentView incident = incidentManager.RetrieveById2(incidentId);

				//Make sure that the project ids match
				if (incident.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Get the custom properties
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, incidentId, DataModel.Artifact.ArtifactTypeEnum.Incident, true);

				//Also get the linked test run steps
				List<int> testRunStepIds = null;
				List<TestRunStepIncidentView> testRunStepIncidents = incidentManager.Incident_RetrieveTestRunSteps(incidentId);
				if (testRunStepIncidents != null && testRunStepIncidents.Count > 0)
				{
					testRunStepIds = testRunStepIncidents.Select(t => t.TestRunStepId).ToList();
				}

				//Populate the API data object and return
				RemoteIncident remoteIncident = new RemoteIncident();
				PopulationFunctions.PopulateIncident(remoteIncident, incident, testRunStepIds);
				PopulationFunctions.PopulateCustomProperties(remoteIncident, artifactCustomProperty);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteIncident;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, Resources.Messages.Services_IncidentNotFound);
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Updates an incident in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteIncident">The updated incident object</param>
		public void Incident_Update(RemoteCredentials credentials, RemoteIncident remoteIncident)
		{
			const string METHOD_NAME = "Incident_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have an incident id specified
			if (!remoteIncident.IncidentId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_IncidentIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteIncident.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Make sure we have permissions to update incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyIncidents);
			}

			//First retrieve the existing datarow
			try
			{
				IncidentManager incidentManager = new IncidentManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				Incident incident = incidentManager.RetrieveById(remoteIncident.IncidentId.Value, false, false, true);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteIncident.IncidentId.Value, DataModel.Artifact.ArtifactTypeEnum.Incident, true);

				//Make sure that the project ids match
				if (incident.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
				UpdateFunctions.UpdateIncidentData(incident, remoteIncident, projectTemplateId);
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteIncident, remoteIncident.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Incident, remoteIncident.IncidentId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}

				//Get copies of everything..
				Artifact notificationArt = incident.Clone();
				ArtifactCustomProperty notificationCust = artifactCustomProperty.Clone();

				//Call the business object to actually update the incident dataset and the custom properties
				incidentManager.Update(incident, userId);
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//If the test run step is not linked already, add
				if (remoteIncident.TestRunStepIds != null && remoteIncident.TestRunStepIds.Count > 0)
				{
					foreach (int testRunStepId in remoteIncident.TestRunStepIds)
					{
						if (!incident.TestRunSteps.Any(t => t.TestRunStepId == testRunStepId))
						{
							incidentManager.Incident_AssociateToTestRunStep(projectId, testRunStepId, new List<int>() { remoteIncident.IncidentId.Value }, userId);
						}
					}
				}

				//Call notifications..
				try
				{
					new NotificationManager().SendNotificationForArtifact(notificationArt, notificationCust, null);
				}
				catch (Exception ex)
				{
					Logger.LogErrorEvent(METHOD_NAME, ex, "Sending message for Incident " + incident.ArtifactToken + ".");
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested incident");
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Deletes a incident in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="incidentId">The id of the incident</param>
		public void Incident_Delete(RemoteCredentials credentials, int projectId, int incidentId)
		{
			const string METHOD_NAME = "Incident_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				IncidentManager incidentManager = new IncidentManager();
				Incident incident = incidentManager.RetrieveById(incidentId, false);

				//Make sure that the project ids match
				if (incident.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually mark the item as deleted
				incidentManager.MarkAsDeleted(projectId, incidentId, userId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested incident");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Creates a new incident in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteIncident">The new incident object (primary key will be empty)</param>
		/// <returns>The populated incident object - including the primary key</returns>
		public RemoteIncident Incident_Create(RemoteCredentials credentials, RemoteIncident remoteIncident)
		{
			const string METHOD_NAME = "Incident_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have an incident id specified
			if (remoteIncident.IncidentId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_IncidentIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteIncident.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to create incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateIncidents);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Default to the authenticated user if we have no opener provided
				int openerId = userId;
				if (remoteIncident.OpenerId.HasValue)
				{
					openerId = remoteIncident.OpenerId.Value;
				}

				//Always use the current project
				remoteIncident.ProjectId = projectId;

				//If we don't have a valid creation date, set it to the current date
				DateTime creationDate = DateTime.UtcNow;
				if (remoteIncident.CreationDate.HasValue)
				{
					creationDate = remoteIncident.CreationDate.Value;
				}

				int? incidentStatusId = null;
				//If the remote artifact contains a status AND the template setting allows bulk edit of status, set the status, otherwise leave it null (so manager will use the default)
				if (remoteIncident.IncidentStatusId.HasValue)
				{
					ProjectTemplateSettings projectTemplateSettings = new ProjectTemplateSettings(projectTemplateId);
					if (projectTemplateSettings.Workflow_BulkEditCanChangeStatus)
					{
						incidentStatusId = remoteIncident.IncidentStatusId.Value;
					}
				}

				//First insert the new incident record itself, capturing and populating the id
				IncidentManager incidentManager = new IncidentManager();
				remoteIncident.IncidentId = incidentManager.Insert(
				   projectId,
				   remoteIncident.PriorityId,
				   remoteIncident.SeverityId,
				   openerId,
				   remoteIncident.OwnerId,
				   remoteIncident.TestRunStepIds,
				   remoteIncident.Name,
				   remoteIncident.Description,
				   remoteIncident.DetectedReleaseId,
				   remoteIncident.ResolvedReleaseId,
				   remoteIncident.VerifiedReleaseId,
				   remoteIncident.IncidentTypeId,
				   incidentStatusId,
				   creationDate,
				   remoteIncident.StartDate,
				   remoteIncident.ClosedDate,
				   remoteIncident.EstimatedEffort,
				   remoteIncident.ActualEffort,
				   remoteIncident.RemainingEffort,
				   remoteIncident.FixedBuildId,
				   remoteIncident.ComponentIds,
				   userId
				   );

				//Now we need to populate any custom properties
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				ArtifactCustomProperty artifactCustomProperty = null;
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteIncident, remoteIncident.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Incident, remoteIncident.IncidentId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Send a notification
				incidentManager.SendCreationNotification(remoteIncident.IncidentId.Value, artifactCustomProperty, null);

				//Finally return the populated incident object
				return remoteIncident;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Adds a new incident severity to the current project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="remoteIncidentSeverity">The new severity record</param>
		/// <returns>The severity object with the primary key populated</returns>
		/// <remarks>The color should be provide in RRGGBB hex format</remarks>
		public RemoteIncidentSeverity Incident_AddSeverity(RemoteCredentials credentials, int projectTemplateId, RemoteIncidentSeverity remoteIncidentSeverity)
		{
			const string METHOD_NAME = "Incident_AddSeverity";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Now insert the incident severity
				IncidentManager incidentManager = new IncidentManager();
				remoteIncidentSeverity.SeverityId = incidentManager.InsertIncidentSeverity(projectTemplateId, remoteIncidentSeverity.Name, remoteIncidentSeverity.Color, remoteIncidentSeverity.Active);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteIncidentSeverity;
		}

		/// <summary>
		/// Adds a new incident type to the current project template
		/// </summary>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteIncidentType">The new incident type object</param>
		/// <returns>The incident type object with its primary key populated</returns>
		public RemoteIncidentType Incident_AddType(RemoteCredentials credentials, int projectTemplateId, RemoteIncidentType remoteIncidentType)
		{
			const string METHOD_NAME = "Incident_AddType";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Now insert the incident type
				IncidentManager incidentManager = new IncidentManager();
				remoteIncidentType.IncidentTypeId = incidentManager.InsertIncidentType(projectTemplateId, remoteIncidentType.Name, null, remoteIncidentType.Issue, remoteIncidentType.Risk, false, remoteIncidentType.Active);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteIncidentType;
		}

		/// <summary>
		/// Adds a new incident status to the current project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="remoteIncidentStatus">The incident status object</param>
		/// <returns>The incident status object with the primary key populated</returns>
		public RemoteIncidentStatus Incident_AddStatus(RemoteCredentials credentials, int projectTemplateId, RemoteIncidentStatus remoteIncidentStatus)
		{
			const string METHOD_NAME = "Incident_AddStatus";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Now insert the incident status
				IncidentManager incidentManager = new IncidentManager();
				remoteIncidentStatus.IncidentStatusId = incidentManager.IncidentStatus_Insert(projectTemplateId, remoteIncidentStatus.Name, remoteIncidentStatus.Open, false, remoteIncidentStatus.Active);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteIncidentStatus;
		}

		/// <summary>
		/// Adds a new incident priority to the current project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="remoteIncidentPriority">The new priority record</param>
		/// <returns>The priority object with the primary key populated</returns>
		/// <remarks>The color should be provide in RRGGBB hex format</remarks>
		public RemoteIncidentPriority Incident_AddPriority(RemoteCredentials credentials, int projectTemplateId, RemoteIncidentPriority remoteIncidentPriority)
		{
			const string METHOD_NAME = "Incident_AddPriority";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we're authorized
			bool isAuthorized = new TemplateManager().IsAuthorizedToEditTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.WebPartBase_NotAuthorizedToEditProjectTemplate, projectTemplateId));
			}

			try
			{
				//Now insert the incident priority
				IncidentManager incidentManager = new IncidentManager();
				remoteIncidentPriority.PriorityId = incidentManager.InsertIncidentPriority(projectTemplateId, remoteIncidentPriority.Name, remoteIncidentPriority.Color, remoteIncidentPriority.Active);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteIncidentPriority;
		}

		/// <summary>
		/// Retrieves a list of the active incident priorities for the current project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <returns>The list of active incident priorities for the current project</returns>
		public List<RemoteIncidentPriority> Incident_RetrievePriorities(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Incident_RetrievePriorities";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			try
			{
				//Call the business object to actually retrieve the incident dataset
				IncidentManager incidentManager = new IncidentManager();
				List<IncidentPriority> incidentPriorities = incidentManager.RetrieveIncidentPriorities(projectTemplateId, true);

				//Now populate the list of API data objects
				List<RemoteIncidentPriority> remoteIncidentPriorities = new List<RemoteIncidentPriority>();
				foreach (IncidentPriority priority in incidentPriorities)
				{
					RemoteIncidentPriority remoteIncidentPriority = new RemoteIncidentPriority();
					remoteIncidentPriorities.Add(remoteIncidentPriority);
					//Populate fields
					remoteIncidentPriority.PriorityId = priority.PriorityId;
					remoteIncidentPriority.Name = priority.Name;
					remoteIncidentPriority.Color = priority.Color;
					remoteIncidentPriority.Active = priority.IsActive;
					remoteIncidentPriority.Score = priority.Score;
				}
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteIncidentPriorities;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Retrieves a list of the active incident severities for the current project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <returns>The list of active incident severities for the current project</returns>
		public List<RemoteIncidentSeverity> Incident_RetrieveSeverities(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Incident_RetrieveSeverities";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			try
			{
				//Call the business object to actually retrieve the incident dataset
				IncidentManager incidentManager = new IncidentManager();
				List<IncidentSeverity> incidentSeverities = incidentManager.RetrieveIncidentSeverities(projectTemplateId, true);

				//Now populate the list of API data objects
				List<RemoteIncidentSeverity> remoteIncidentSeverities = new List<RemoteIncidentSeverity>();
				foreach (IncidentSeverity severity in incidentSeverities)
				{
					RemoteIncidentSeverity remoteIncidentSeverity = new RemoteIncidentSeverity();
					remoteIncidentSeverities.Add(remoteIncidentSeverity);
					//Populate fields
					remoteIncidentSeverity.SeverityId = severity.SeverityId;
					remoteIncidentSeverity.Name = severity.Name;
					remoteIncidentSeverity.Color = severity.Color;
					remoteIncidentSeverity.Active = severity.IsActive;
					remoteIncidentSeverity.Score = severity.Score;
				}
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteIncidentSeverities;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Retrieves a list of the active incident types for the current project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of active incident types for the current project</returns>
		public List<RemoteIncidentType> Incident_RetrieveTypes(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Incident_RetrieveTypes";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			try
			{
				//Call the business object to actually retrieve the incident dataset
				IncidentManager incidentManager = new IncidentManager();
				List<IncidentType> incidentTypes = incidentManager.RetrieveIncidentTypes(projectTemplateId, true);

				//Now populate the list of API data objects
				List<RemoteIncidentType> remoteIncidentTypes = new List<RemoteIncidentType>();
				foreach (IncidentType type in incidentTypes)
				{
					RemoteIncidentType remoteIncidentType = new RemoteIncidentType();
					remoteIncidentTypes.Add(remoteIncidentType);
					//Populate fields
					remoteIncidentType.IncidentTypeId = type.IncidentTypeId;
					remoteIncidentType.Name = type.Name;
					remoteIncidentType.Risk = type.IsRisk;
					remoteIncidentType.Issue = type.IsIssue;
					remoteIncidentType.Active = type.IsActive;
					remoteIncidentType.WorkflowId = type.WorkflowId;
				}
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteIncidentTypes;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Retrieves a list of the active incident statuses for the current project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <returns>The list of active incident statuses for the current project</returns>
		public List<RemoteIncidentStatus> Incident_RetrieveStatuses(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Incident_RetrieveStatuses";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			try
			{
				//Call the business object to actually retrieve the incident dataset
				IncidentManager incidentManager = new IncidentManager();
				List<IncidentStatus> incidentStati = incidentManager.IncidentStatus_Retrieve(projectTemplateId, true);

				//Now populate the list of API data objects
				List<RemoteIncidentStatus> remoteIncidentStatuses = new List<RemoteIncidentStatus>();
				foreach (IncidentStatus status in incidentStati)
				{
					RemoteIncidentStatus remoteIncidentStatus = new RemoteIncidentStatus();
					remoteIncidentStatuses.Add(remoteIncidentStatus);
					//Populate fields
					remoteIncidentStatus.IncidentStatusId = status.IncidentStatusId;
					remoteIncidentStatus.Name = status.Name;
					remoteIncidentStatus.Open = status.IsOpenStatus;
					remoteIncidentStatus.Active = status.IsActive;
				}
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteIncidentStatuses;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Retrieves the default incident status for the current project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <returns>The default status</returns>
		public RemoteIncidentStatus Incident_RetrieveDefaultStatus(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Incident_RetrieveDefaultStatus";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			try
			{
				//Call the business object to actually retrieve the incident data
				IncidentManager incidentManager = new IncidentManager();
				IncidentStatus status = incidentManager.IncidentStatus_RetrieveDefault(projectTemplateId);

				//Now populate the list of API data objects
				RemoteIncidentStatus remoteIncidentStatus = new RemoteIncidentStatus();
				//Populate fields
				remoteIncidentStatus.IncidentStatusId = status.IncidentStatusId;
				remoteIncidentStatus.Name = status.Name;
				remoteIncidentStatus.Open = status.IsOpenStatus;
				remoteIncidentStatus.Active = status.IsActive;

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteIncidentStatus;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Retrieves the default incident type for the current project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <returns>The default incident type</returns>
		public RemoteIncidentType Incident_RetrieveDefaultType(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Incident_RetrieveDefaultType";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			try
			{
				//Call the business object to actually retrieve the incident data
				IncidentManager incidentManager = new IncidentManager();
				int typeId = incidentManager.GetDefaultIncidentType(projectTemplateId);
				IncidentType type = incidentManager.RetrieveIncidentTypeById(typeId);

				//Now populate the list of API data objects
				RemoteIncidentType remoteIncidentType = new RemoteIncidentType();

				//Populate fields
				remoteIncidentType.IncidentTypeId = type.IncidentTypeId;
				remoteIncidentType.Name = type.Name;
				remoteIncidentType.Risk = type.IsRisk;
				remoteIncidentType.Issue = type.IsIssue;
				remoteIncidentType.Active = type.IsActive;
				remoteIncidentType.WorkflowId = type.WorkflowId;

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				return remoteIncidentType;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Will retrieve available transitions for the specied status ID for the currently logged-on user.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="currentTypeId">The current incident type</param>
		/// <param name="currentStatusId">The current incident status</param>
		/// <param name="isDetector">Is the user the detector of the incident</param>
		/// <param name="isOwner">Is the user the owner of the incident</param>
		/// <returns>The list of workflow transitions</returns>
		public List<RemoteWorkflowTransition> Incident_RetrieveWorkflowTransitions(RemoteCredentials credentials, int projectId, int currentTypeId, int currentStatusId, bool isDetector, bool isOwner)
		{
			const string METHOD_NAME = "Incident_RetrieveWorkflowTransitions";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Incident, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;
			List<RemoteWorkflowTransition> retList = new List<RemoteWorkflowTransition>();

			//Get the use's role in the project.
			ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
			if (projectUser == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}
			int roleId = projectUser.ProjectRoleId;

			//Get the workflow ID for the specified status.
			int workflowId = -1;
			List<IncidentType> incidentTypes = new IncidentManager().RetrieveIncidentTypes(projectTemplateId, false);
			for (int i = 0; (i < incidentTypes.Count && workflowId < 0); i++)
			{
				if (incidentTypes[i].IncidentTypeId == currentTypeId)
				{
					workflowId = incidentTypes[i].WorkflowId;
				}
			}

			WorkflowManager workflowManager = new Business.WorkflowManager();
			List<WorkflowTransition> workflowTransitions = workflowManager.WorkflowTransition_RetrieveByInputStatus(workflowId, currentStatusId, roleId, isDetector, isOwner);

			foreach (WorkflowTransition transition in workflowTransitions)
			{
				RemoteWorkflowTransition wrkTransition = new RemoteWorkflowTransition();
				PopulationFunctions.PopulateWorkflowTransition(wrkTransition, transition);
				retList.Add(wrkTransition);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves the list of incident fields and their workflow status for a given type and status/step.
		/// </summary>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="currentTypeId">The current incident type</param>
		/// <param name="currentStatusId">The current incident status</param>
		/// <returns>The list of incident fields</returns>
		public List<RemoteWorkflowField> Incident_RetrieveWorkflowFields(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "Incident_RetrieveWorkflowFields";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowField> retList = new List<RemoteWorkflowField>();

			//Get the workflow ID for the specified status.
			int workflowId = -1;
			List<IncidentType> incidentTypes = new IncidentManager().RetrieveIncidentTypes(projectTemplateId, false);
			for (int i = 0; (i < incidentTypes.Count && workflowId < 0); i++)
			{
				if (incidentTypes[i].IncidentTypeId == currentTypeId)
				{
					workflowId = incidentTypes[i].WorkflowId;
				}
			}

			//Pull fields.
			List<WorkflowField> workflowFields = new WorkflowManager().Workflow_RetrieveFieldStates(workflowId, currentStatusId);

			foreach (WorkflowField workflowField in workflowFields)
			{
				RemoteWorkflowField remoteWorkflowField = new RemoteWorkflowField();
				PopulationFunctions.PopulateWorkflowField(remoteWorkflowField, workflowField);
				retList.Add(remoteWorkflowField);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves the list of incident custom properties and their workflow state for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="currentTypeId">The current incident type</param>
		/// <param name="currentStatusId">The current incident status</param>
		/// <returns>The list of incident custom property states</returns>
		public List<RemoteWorkflowCustomProperty> Incident_RetrieveWorkflowCustomProperties(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "Incident_RetrieveWorkflowCustomProperties";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}
			List<RemoteWorkflowCustomProperty> retList = new List<RemoteWorkflowCustomProperty>();

			//Get the workflow ID for the specified status.
			int workflowId = -1;
			List<IncidentType> incidentTypes = new IncidentManager().RetrieveIncidentTypes(projectTemplateId, false);
			for (int i = 0; (i < incidentTypes.Count && workflowId < 0); i++)
			{
				if (incidentTypes[i].IncidentTypeId == currentTypeId)
				{
					workflowId = incidentTypes[i].WorkflowId;
				}
			}

			//Pull custom properties
			List<WorkflowCustomProperty> workflowCustomProperties = new WorkflowManager().Workflow_RetrieveCustomPropertyStates(workflowId, currentStatusId);

			foreach (WorkflowCustomProperty workflowCustomProperty in workflowCustomProperties)
			{
				RemoteWorkflowCustomProperty remoteWorkflowCustomProperty = new RemoteWorkflowCustomProperty();
				PopulationFunctions.PopulateWorkflowCustomProperty(remoteWorkflowCustomProperty, workflowCustomProperty);
				retList.Add(remoteWorkflowCustomProperty);
			}

			return retList;
		}

		#endregion Incident Methods

		#region Release Methods

		/// <summary>Returns the number of releases that match the filter.</summary>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <returns>The number of items.</returns>
		public long Release_Count(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters)
		{
			const string METHOD_NAME = CLASS_NAME + "Release_Count";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewReleases);
			}

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the incident dataset
			long retNum = new ReleaseManager().Count(-1, projectId, filters, 0, false);

			Logger.LogExitingEvent(METHOD_NAME);
			return retNum;
		}

		/// <summary>
		/// Retrieves the list of release statuses in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <returns>The list of release statuses</returns>
		public List<RemoteReleaseStatus> Release_RetrieveStatuses(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Release_RetrieveStatuses";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Call the business object to actually retrieve the release statuses
			ReleaseManager releaseManager = new ReleaseManager();

			try
			{
				List<ReleaseStatus> releaseStati = releaseManager.RetrieveStatuses();

				//Populate the API data objects and return
				List<RemoteReleaseStatus> remoteReleaseStati = new List<RemoteReleaseStatus>();
				foreach (ReleaseStatus releaseStatus in releaseStati)
				{
					RemoteReleaseStatus remoteReleaseStatus = new RemoteReleaseStatus();
					PopulationFunctions.PopulateReleaseStatus(remoteReleaseStatus, releaseStatus);
					remoteReleaseStati.Add(remoteReleaseStatus);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteReleaseStati;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of release types in the system, with the workflows for the specific project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <returns>The list of release types </returns>
		public List<RemoteReleaseType> Release_RetrieveTypes(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Release_RetrieveTypes";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;


			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Call the business object to actually retrieve the release types
			ReleaseManager releaseManager = new ReleaseManager();
			ReleaseWorkflowManager workflowManager = new ReleaseWorkflowManager();

			try
			{
				List<ReleaseType> releaseTypes = releaseManager.RetrieveTypes();

				//Populate the API data objects and return
				List<RemoteReleaseType> remoteReleaseTypes = new List<RemoteReleaseType>();
				foreach (ReleaseType releaseType in releaseTypes)
				{
					RemoteReleaseType remoteReleaseType = new RemoteReleaseType();
					PopulationFunctions.PopulateReleaseType(remoteReleaseType, releaseType);
					remoteReleaseTypes.Add(remoteReleaseType);

					//Also get the associated workflow for this project
					remoteReleaseType.WorkflowId = workflowManager.Workflow_GetForReleaseType(projectTemplateId, releaseType.ReleaseTypeId);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteReleaseTypes;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of release fields and their workflow status for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The id of the project template</param>
		/// <param name="currentTypeId">The current release type</param>
		/// <param name="currentStatusId">The current release status</param>
		/// <returns>The list of release fields</returns>
		public List<RemoteWorkflowField> Release_RetrieveWorkflowFields(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "Release_RetrieveWorkflowFields";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowField> retList = new List<RemoteWorkflowField>();

			//Get the workflow ID for the specified type.
			ReleaseWorkflowManager workflowManager = new ReleaseWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForReleaseType(projectTemplateId, currentTypeId);

			//Pull fields.
			List<ReleaseWorkflowField> workflowFields = workflowManager.Workflow_RetrieveFieldStates(workflowId, currentStatusId);

			foreach (ReleaseWorkflowField workflowField in workflowFields)
			{
				RemoteWorkflowField remoteWorkflowField = new RemoteWorkflowField();
				PopulationFunctions.PopulateWorkflowField(remoteWorkflowField, workflowField);
				retList.Add(remoteWorkflowField);
			}

			return retList;
		}

		/// <summary>
		/// Will retrieve available transitions for the specied status ID for the currently logged-on user.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="currentTypeId">The current release type</param>
		/// <param name="currentStatusId">The current release status</param>
		/// <param name="isCreator">Is the user the creator of the release</param>
		/// <param name="isOwner">Is the user the owner of the release</param>
		/// <returns>The list of workflow transitions</returns>
		public List<RemoteWorkflowTransition> Release_RetrieveWorkflowTransitions(RemoteCredentials credentials, int projectId, int currentTypeId, int currentStatusId, bool isCreator, bool isOwner)
		{
			const string METHOD_NAME = "Release_RetrieveWorkflowTransitions";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewReleases);
			}

			List<RemoteWorkflowTransition> retList = new List<RemoteWorkflowTransition>();

			//Get the use's role in the project.
			ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
			if (projectUser == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}
			int roleId = projectUser.ProjectRoleId;

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Get the workflow ID for the specified type.
			ReleaseWorkflowManager workflowManager = new ReleaseWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForReleaseType(projectTemplateId, currentTypeId);

			List<ReleaseWorkflowTransition> workflowTransitions = workflowManager.WorkflowTransition_RetrieveByInputStatus(workflowId, currentStatusId, roleId, isCreator, isOwner);

			foreach (ReleaseWorkflowTransition transition in workflowTransitions)
			{
				RemoteWorkflowTransition wrkTransition = new RemoteWorkflowTransition();
				PopulationFunctions.PopulateWorkflowTransition(wrkTransition, transition);
				retList.Add(wrkTransition);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves the list of release custom properties and their workflow state for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current release type</param>
		/// <param name="currentStatusId">The current release status</param>
		/// <returns>The list of release custom property states</returns>
		public List<RemoteWorkflowCustomProperty> Release_RetrieveWorkflowCustomProperties(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "Release_RetrieveWorkflowCustomProperties";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;


			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowCustomProperty> retList = new List<RemoteWorkflowCustomProperty>();

			//Get the workflow ID for the specified type.
			ReleaseWorkflowManager workflowManager = new ReleaseWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForReleaseType(projectTemplateId, currentTypeId);

			//Pull custom properties
			List<ReleaseWorkflowCustomProperty> workflowCustomProperties = workflowManager.Workflow_RetrieveCustomPropertyStates(workflowId, currentStatusId);

			foreach (ReleaseWorkflowCustomProperty workflowCustomProperty in workflowCustomProperties)
			{
				RemoteWorkflowCustomProperty remoteWorkflowCustomProperty = new RemoteWorkflowCustomProperty();
				PopulationFunctions.PopulateWorkflowCustomProperty(remoteWorkflowCustomProperty, workflowCustomProperty);
				retList.Add(remoteWorkflowCustomProperty);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves all the releases and iterations belonging to the current project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="activeOnly">Do we want just active releases?</param>
		/// <returns>List of releases</returns>
		public List<RemoteRelease> Release_Retrieve(RemoteCredentials credentials, int projectId, bool activeOnly)
		{
			const string METHOD_NAME = "Release_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewReleases);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Call the business object to actually retrieve the release dataset
			ReleaseManager releaseManager = new ReleaseManager();
			List<ReleaseView> releases = releaseManager.RetrieveByProjectId(projectId, activeOnly);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Release, false);

			//Populate the API data object and return
			List<RemoteRelease> remoteReleases = new List<RemoteRelease>();
			foreach (ReleaseView release in releases)
			{
				//Create and populate the row
				RemoteRelease remoteRelease = new RemoteRelease();
				PopulationFunctions.PopulateRelease(remoteRelease, release);
				PopulationFunctions.PopulateCustomProperties(remoteRelease, release, customProperties);
				remoteReleases.Add(remoteRelease);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteReleases;
		}

		/// <summary>
		/// Retrieves a list of releases in the system that match the provided filter
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of releases</returns>
		public List<RemoteRelease> Release_Retrieve2(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = "Release_Retrieve2";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewReleases);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the release dataset
			ReleaseManager releaseManager = new ReleaseManager();
			List<ReleaseView> releases = releaseManager.RetrieveByProjectId(Business.UserManager.UserInternal, projectId, startingRow, numberOfRows, filters, 0);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Release, false);

			//Populate the API data object and return
			List<RemoteRelease> remoteReleases = new List<RemoteRelease>();
			foreach (ReleaseView release in releases)
			{
				//Create and populate the row
				RemoteRelease remoteRelease = new RemoteRelease();
				PopulationFunctions.PopulateRelease(remoteRelease, release);
				PopulationFunctions.PopulateCustomProperties(remoteRelease, release, customProperties);
				remoteReleases.Add(remoteRelease);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteReleases;
		}

		/// <summary>
		/// Retrieves a single release in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="releaseId">The id of the release</param>
		/// <returns>Release object</returns>
		public RemoteRelease Release_RetrieveById(RemoteCredentials credentials, int projectId, int releaseId)
		{
			const string METHOD_NAME = "Release_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewReleases);
			}

			//Call the business object to actually retrieve the release dataset
			ReleaseManager releaseManager = new ReleaseManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the release was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				ReleaseView release = releaseManager.RetrieveById2(projectId, releaseId);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, releaseId, DataModel.Artifact.ArtifactTypeEnum.Release, true);

				//Make sure that the project ids match
				if (release.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteRelease remoteRelease = new RemoteRelease();
				PopulationFunctions.PopulateRelease(remoteRelease, release);
				if (artifactCustomProperty != null)
				{
					PopulationFunctions.PopulateCustomProperties(remoteRelease, artifactCustomProperty);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRelease;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested release");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Updates a release in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteRelease">The updated release object</param>
		public void Release_Update(RemoteCredentials credentials, RemoteRelease remoteRelease)
		{
			const string METHOD_NAME = "Release_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have an release id specified
			if (!remoteRelease.ReleaseId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_ReleaseIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteRelease.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyReleases);
			}

			//First retrieve the existing datarow
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				ReleaseManager releaseManager = new ReleaseManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				Release release = releaseManager.RetrieveById3(projectId, remoteRelease.ReleaseId.Value);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteRelease.ReleaseId.Value, DataModel.Artifact.ArtifactTypeEnum.Release, true);

				//Make sure that the project ids match
				if (release.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Get copies of everything..
				Artifact notificationArt = release.Clone();
				ArtifactCustomProperty notificationCust = artifactCustomProperty.Clone();

				//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
				UpdateFunctions.UpdateReleaseData(release, remoteRelease, projectTemplateId);
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteRelease, remoteRelease.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Release, remoteRelease.ReleaseId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}

				//Call the business object to actually update the release dataset and the custom properties
				releaseManager.Update(new List<Release>() { release }, userId, projectId);
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Call notifications..
				try
				{
					new NotificationManager().SendNotificationForArtifact(notificationArt, notificationCust, null);
				}
				catch (Exception ex)
				{
					Logger.LogErrorEvent(METHOD_NAME, ex, "Sending message for ReleaseId #" + release.ReleaseId + ".");
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested release");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Indents a release one position
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="releaseId">The id of the release to indent</param>
		public void Release_Indent(RemoteCredentials credentials, int projectId, int releaseId)
		{
			const string METHOD_NAME = "Release_Indent";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyReleases);
			}

			//First retrieve the release to make sure it exists and is in the authorized project
			try
			{
				ReleaseManager releaseManager = new ReleaseManager();
				ReleaseView sourceRelease = releaseManager.RetrieveById(Business.UserManager.UserInternal, projectId, releaseId);

				//Make sure that the project ids match
				if (sourceRelease.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually perform the indent
				releaseManager.Indent(userId, projectId, releaseId);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested release");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Outdents a release one position
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="releaseId">The id of the release to outdent</param>
		public void Release_Outdent(RemoteCredentials credentials, int projectId, int releaseId)
		{
			const string METHOD_NAME = "Release_Outdent";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyReleases);
			}

			//First retrieve the release to make sure it exists and is in the authorized project
			try
			{
				ReleaseManager releaseManager = new ReleaseManager();
				ReleaseView sourceRelease = releaseManager.RetrieveById(Business.UserManager.UserInternal, projectId, releaseId);

				//Make sure that the project ids match
				if (sourceRelease.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually perform the outdent
				releaseManager.Outdent(userId, projectId, releaseId);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested release");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Moves a release to another location in the hierarchy
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="releaseId">The id of the release we want to move</param>
		/// <param name="destinationReleaseId">The id of the release it's to be inserted before in the list (or null to be at the end)</param>
		public void Release_Move(RemoteCredentials credentials, int projectId, int releaseId, int? destinationReleaseId)
		{
			const string METHOD_NAME = "Release_Move";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyReleases);
			}

			//First retrieve the releases to make sure they exists and are in the authorized project
			try
			{
				ReleaseManager releaseManager = new ReleaseManager();
				ReleaseView sourceRelease = releaseManager.RetrieveById2(projectId, releaseId);

				//Make sure that the project ids match
				if (sourceRelease.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}
				if (destinationReleaseId.HasValue)
				{
					ReleaseView destRelease = releaseManager.RetrieveById2(projectId, destinationReleaseId.Value);
					if (destRelease.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}
				}

				//Call the business object to actually perform the move
				releaseManager.Move(userId, projectId, releaseId, destinationReleaseId);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested release");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Deletes a release in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="releaseId">The id of the release</param>
		public void Release_Delete(RemoteCredentials credentials, int projectId, int releaseId)
		{
			const string METHOD_NAME = "Release_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				ReleaseManager releaseManager = new ReleaseManager();
				ReleaseView release = releaseManager.RetrieveById2(projectId, releaseId);

				//Make sure that the project ids match
				if (release.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually mark the item as deleted
				releaseManager.MarkAsDeleted(userId, projectId, releaseId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested release");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Maps a release to a test case, so that the test case is needs to be tested for that release
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="remoteReleaseTestCaseMapping">The release and test case mapping entry</param>
		/// <remarks>If the mapping record already exists no error is raised</remarks>
		public void Release_AddTestMapping(RemoteCredentials credentials, int projectId, RemoteReleaseTestCaseMapping remoteReleaseTestCaseMapping)
		{
			const string METHOD_NAME = "Release_AddTestMapping";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			try
			{
				//Add the test case we want to use for mapping
				Business.TestCaseManager testCaseManager = new Business.TestCaseManager();
				List<int> testCaseIds = new List<int>();
				testCaseIds.Add(remoteReleaseTestCaseMapping.TestCaseId);
				testCaseManager.AddToRelease(projectId, remoteReleaseTestCaseMapping.ReleaseId, testCaseIds, userId);
			}
			catch (EntityConstraintViolationException)
			{
				//Ignore error due to duplicate row
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Maps a release to a test case, so that the test case is needs to be tested for that release
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="remoteReleaseTestCaseMappings">The release and test case mapping entries</param>
		/// <remarks>
		/// 1) If the mapping record already exists no error is raised
		/// 2) This version of the function supports an array of mappings and is faster for multiple adds
		/// </remarks>
		public void Release_AddTestMapping2(RemoteCredentials credentials, int projectId, RemoteReleaseTestCaseMapping[] remoteReleaseTestCaseMappings)
		{
			const string METHOD_NAME = "Release_AddTestMapping2";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			try
			{
				//Add the test case we want to use for mapping
				Business.TestCaseManager testCaseManager = new Business.TestCaseManager();
				List<int> releases = new List<int>();

				//First see how many releases we have
				foreach (RemoteReleaseTestCaseMapping remoteReleaseTestCaseMapping in remoteReleaseTestCaseMappings)
				{
					if (!releases.Contains(remoteReleaseTestCaseMapping.ReleaseId))
					{
						releases.Add(remoteReleaseTestCaseMapping.ReleaseId);
					}
				}

				//Iterate for each release and add the mappings
				foreach (int releaseId in releases)
				{
					List<int> testCaseIds = new List<int>();
					foreach (RemoteReleaseTestCaseMapping remoteReleaseTestCaseMapping in remoteReleaseTestCaseMappings)
					{
						if (remoteReleaseTestCaseMapping.ReleaseId == releaseId)
						{
							testCaseIds.Add(remoteReleaseTestCaseMapping.TestCaseId);
						}
					}
					testCaseManager.AddToRelease(projectId, releaseId, testCaseIds, userId);
				}
			}
			catch (EntityConstraintViolationException)
			{
				//Ignore error due to duplicate row
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Removes a mapping entry for a specific release and test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="remoteReleaseTestCaseMapping">The release and test case mapping entry</param>
		public void Release_RemoveTestMapping(RemoteCredentials credentials, int projectId, RemoteReleaseTestCaseMapping remoteReleaseTestCaseMapping)
		{
			const string METHOD_NAME = "Release_RemoveTestMapping";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			try
			{
				//Restore the test case we want to remove coverage for
				Business.TestCaseManager testCaseManager = new Business.TestCaseManager();
				List<int> testCaseIds = new List<int>();
				testCaseIds.Add(remoteReleaseTestCaseMapping.TestCaseId);
				testCaseManager.RemoveFromRelease(projectId, remoteReleaseTestCaseMapping.ReleaseId, testCaseIds, userId);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Creates a new release in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteRelease">The new release object (primary key will be empty)</param>
		/// <param name="parentReleaseId">Do we want to insert the release under a parent release</param>
		/// <returns>The populated release object - including the primary key</returns>
		public RemoteRelease Release_Create(RemoteCredentials credentials, RemoteRelease remoteRelease, Nullable<int> parentReleaseId)
		{
			const string METHOD_NAME = "Release_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have an release id specified
			if (remoteRelease.ReleaseId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_ReleaseIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteRelease.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create releases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateReleases);
			}

			//Always use the current project
			remoteRelease.ProjectId = projectId;

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Set a default creator if one not specified
				int creatorId = userId;
				if (remoteRelease.CreatorId.HasValue)
				{
					creatorId = remoteRelease.CreatorId.Value;
				}

				int releaseStatusId = remoteRelease.ReleaseStatusId;
				//If the template setting does not allow bulk edit of status, set the status to the default
				ProjectTemplateSettings projectTemplateSettings = new ProjectTemplateSettings(projectTemplateId);
				if (!projectTemplateSettings.Workflow_BulkEditCanChangeStatus)
				{
					releaseStatusId = (int)Release.ReleaseStatusEnum.Planned;
				}

				//If we have a passed in parent release, then we need to insert the release as a child item
				ReleaseManager releaseManager = new ReleaseManager();
				if (parentReleaseId.HasValue)
				{
					//We use user internal, since this web service shouldn't have to worry about what's collapsed
					ReleaseView release = releaseManager.RetrieveById2(projectId, parentReleaseId.Value);
					if (release == null)
					{
						throw CreateFault("ArtifactNotFound", Resources.Messages.Services_ReleaseNotFound);
					}
					List<ReleaseView> childReleases = releaseManager.RetrieveChildren(Business.UserManager.UserInternal, projectId, release.IndentLevel, false);

					//See if we have any existing child releases
					if (childReleases.Count > 0)
					{
						//Get the indent level of the last existing child
						string indentLevel = childReleases[childReleases.Count - 1].IndentLevel;

						//Now get the next indent level and use for that for the new item
						indentLevel = HierarchicalList.IncrementIndentLevel(indentLevel);

						//Now insert the release at the specified position
						remoteRelease.ReleaseId = releaseManager.Insert(
							userId,
							projectId,
							creatorId,
							remoteRelease.Name,
							remoteRelease.Description,
							remoteRelease.VersionNumber,
							indentLevel,
							(Release.ReleaseStatusEnum)releaseStatusId,
							(Release.ReleaseTypeEnum)remoteRelease.ReleaseTypeId,
							remoteRelease.StartDate,
							remoteRelease.EndDate,
							remoteRelease.ResourceCount,
							remoteRelease.DaysNonWorking,
							remoteRelease.OwnerId
							);
					}
					else
					{
						//We have no children so get the indent level of the parent and increment that
						//i.e. insert after the parent, then we can do an indent
						string indentLevel = HierarchicalList.IncrementIndentLevel(release.IndentLevel);

						//Now insert the release at the specified position
						remoteRelease.ReleaseId = releaseManager.Insert(
							userId,
							projectId,
							creatorId,
							remoteRelease.Name,
							remoteRelease.Description,
							remoteRelease.VersionNumber,
							indentLevel,
							(Release.ReleaseStatusEnum)releaseStatusId,
							(Release.ReleaseTypeEnum)remoteRelease.ReleaseTypeId,
							remoteRelease.StartDate,
							remoteRelease.EndDate,
							remoteRelease.ResourceCount,
							remoteRelease.DaysNonWorking,
							remoteRelease.OwnerId
							);

						//Finally perform an indent
						releaseManager.Indent(userId, projectId, remoteRelease.ReleaseId.Value);
					}
				}
				else
				{
					//Now insert the release at the end of the list
					remoteRelease.ReleaseId = releaseManager.Insert(
					   userId,
					   projectId,
					   creatorId,
					   remoteRelease.Name,
					   remoteRelease.Description,
					   remoteRelease.VersionNumber,
					   (int?)null,
					   (Release.ReleaseStatusEnum)releaseStatusId,
					   (Release.ReleaseTypeEnum)remoteRelease.ReleaseTypeId,
					   remoteRelease.StartDate,
					   remoteRelease.EndDate,
					   remoteRelease.ResourceCount,
					   remoteRelease.DaysNonWorking,
					   remoteRelease.OwnerId,
					   true);
				}

				//Now we need to populate any custom properties
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				ArtifactCustomProperty artifactCustomProperty = null;
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteRelease, remoteRelease.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Release, remoteRelease.ReleaseId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Send a notification
				releaseManager.SendCreationNotification(remoteRelease.ReleaseId.Value, artifactCustomProperty, null);

				//Finally return the populated release object
				return remoteRelease;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>Retrieves comments for a specified release.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="releaseId">The ID of the Release/Iteratyion to retrieve comments for.</param>
		/// <returns>An array of comments associated with the specified release.</returns>
		public List<RemoteComment> Release_RetrieveComments(RemoteCredentials credentials, int projectId, int releaseId)
		{
			List<RemoteComment> retList = new List<RemoteComment>();

			if (releaseId > 0)
			{
				retList = this.CommentRetrieve(credentials, projectId, releaseId, DataModel.Artifact.ArtifactTypeEnum.Release);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves the mapped test cases for a specific release
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="releaseId">The id of the release</param>
		/// <returns>The list of mapped test cases</returns>
		public List<RemoteReleaseTestCaseMapping> Release_RetrieveTestMapping(RemoteCredentials credentials, int projectId, int releaseId)
		{
			const string METHOD_NAME = "Release_RetrieveTestMapping";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to retrieve test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			try
			{
				//Retrieve the list of mapped test cases and convert to API object
				Business.TestCaseManager testCaseManager = new Business.TestCaseManager();
				List<RemoteReleaseTestCaseMapping> remoteReleaseTestCaseMappings = new List<RemoteReleaseTestCaseMapping>();
				List<TestCase> mappedTestCases = testCaseManager.RetrieveMappedByReleaseId(projectId, releaseId);
				foreach (TestCase testCase in mappedTestCases)
				{
					RemoteReleaseTestCaseMapping remoteReleaseTestCaseMapping = new RemoteReleaseTestCaseMapping();
					remoteReleaseTestCaseMapping.ReleaseId = releaseId;
					remoteReleaseTestCaseMapping.TestCaseId = testCase.TestCaseId;
					remoteReleaseTestCaseMappings.Add(remoteReleaseTestCaseMapping);
				}
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteReleaseTestCaseMappings;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>Creates a new comment for a release.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="remoteComment">The remote comment.</param>
		/// <returns>The RemoteComment with the comment's new ID specified.</returns>
		public RemoteComment Release_CreateComment(RemoteCredentials credentials, int projectId, RemoteComment remoteComment)
		{
			RemoteComment retComment = this.CreateComment(credentials, projectId, remoteComment, DataModel.Artifact.ArtifactTypeEnum.Release);

			//Send Notification..
			//Pull the release.
			int releaseId = -1;
			try
			{
				ReleaseView release = new ReleaseManager().RetrieveById2(null, remoteComment.ArtifactId, true);
				releaseId = release.ReleaseId;
				if (release != null)
					new NotificationManager().SendNotificationForArtifact(release, null, remoteComment.Text);
			}
			catch (Exception ex)
			{
				Logger.LogErrorEvent(CLASS_NAME + "Release_CreateComment()", ex, "Sending message for Release #" + releaseId + ".");
			}

			return retComment;
		}

		#endregion Release Methods

		#region Requirement Methods

		/// <summary>Returns the number of requirements that match the filter.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <returns>The number of items.</returns>
		public long Requirement_Count(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters)
		{
			const string METHOD_NAME = CLASS_NAME + "Requirement_Count";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the incident dataset
			long retNum = new RequirementManager().Count(-1, projectId, filters, 0, false);

			Logger.LogExitingEvent(METHOD_NAME);
			return retNum;
		}

		/// <summary>
		/// Creates a new requirement record in the current project using the position offset method
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteRequirement">The new requirement object (primary key will be empty)</param>
		/// <param name="indentPosition">The number of columns to indent the requirement by (positive for indent, negative for outdent)</param>
		/// <returns>The populated requirement object - including the primary key</returns>
		/// <remarks>This version is use when you want to specify the relative indentation level</remarks>
		/// <example>
		/// 	spiraImportExport.Connection_Authenticate("aant", "aant");
		///		spiraImportExport.Connection_ConnectToProject(projectId1);
		///		//Lets add a nested tree of requirements
		///		//First the summary item
		///		RemoteRequirement remoteRequirement = new RemoteRequirement();
		///		remoteRequirement.StatusId = 1;
		///		remoteRequirement.Name = "Functionality Area";
		///		remoteRequirement.Description = String.Empty;
		///		remoteRequirement.AuthorId = userId1;
		///		remoteRequirement = spiraImportExport.Requirement_Create1(remoteRequirement, 0);
		///		requirementId1 = remoteRequirement.RequirementId.Value;
		///		//Detail Item 1
		///		remoteRequirement = new RemoteRequirement();
		///		remoteRequirement.StatusId = 2;
		///		remoteRequirement.ImportanceId = 1;
		///		remoteRequirement.ReleaseId = releaseId1;
		///		remoteRequirement.Name = "Requirement 1";
		///		remoteRequirement.Description = "Requirement Description 1";
		///		remoteRequirement.AuthorId = userId1;
		///		remoteRequirement = spiraImportExport.Requirement_Create1(credentials, remoteRequirement, 1);
		///		requirementId2 = remoteRequirement.RequirementId.Value;
		/// </example>
		public RemoteRequirement Requirement_Create1(RemoteCredentials credentials, RemoteRequirement remoteRequirement, int indentPosition)
		{
			const string METHOD_NAME = "Requirement_Create1";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a requirement id specified
			if (remoteRequirement.RequirementId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_RequirementIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteRequirement.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to create requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateRequirements);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Default to the authenticated user if we have no author provided
			int authorId = userId;
			if (remoteRequirement.AuthorId.HasValue)
			{
				authorId = remoteRequirement.AuthorId.Value;
			}

			//Default to the requested status if not value is provided
			Requirement.RequirementStatusEnum requirementStatus = Requirement.RequirementStatusEnum.Requested;
			if (remoteRequirement.StatusId.HasValue)
			{
				//If the template setting allows bulk edit of status, set the status
				ProjectTemplateSettings projectTemplateSettings = new ProjectTemplateSettings(projectTemplateId);
				if (projectTemplateSettings.Workflow_BulkEditCanChangeStatus)
				{
					requirementStatus = (Requirement.RequirementStatusEnum)(remoteRequirement.StatusId.Value);
				}
			}

			//The current project is always used
			remoteRequirement.ProjectId = projectId;

			//If we have a passed in parent requirement, then we need to insert the requirement as a child item
			Business.RequirementManager requirementManager = new Business.RequirementManager();

			//Now insert the requirement at the end of the list
			remoteRequirement.RequirementId = requirementManager.Insert(
			   userId,
			   projectId,
			   remoteRequirement.ReleaseId,
			   remoteRequirement.ComponentId,
			   (int?)null,
			   requirementStatus,
			   remoteRequirement.RequirementTypeId,
			   authorId,
			   remoteRequirement.OwnerId,
			   remoteRequirement.ImportanceId,
			   remoteRequirement.Name,
			   remoteRequirement.Description,
			   remoteRequirement.EstimatePoints,
			   userId,
			   false
			   );

			//Now we need to indent it or outdent it the correct number of times
			if (indentPosition > 0)
			{
				for (int i = 0; i < indentPosition; i++)
				{
					requirementManager.Indent(userId, projectId, remoteRequirement.RequirementId.Value);
				}
			}
			if (indentPosition < 0)
			{
				for (int i = 0; i > indentPosition; i--)
				{
					requirementManager.Outdent(userId, projectId, remoteRequirement.RequirementId.Value);
				}
			}

			//Now we need to populate any custom properties
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();
			ArtifactCustomProperty artifactCustomProperty = null;
			Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteRequirement, remoteRequirement.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, remoteRequirement.RequirementId.Value, projectTemplateId);
			if (validationMessages != null && validationMessages.Count > 0)
			{
				//Throw a validation exception
				throw CreateValidationException(validationMessages);
			}
			customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

			//Send a notification
			requirementManager.SendCreationNotification(remoteRequirement.RequirementId.Value, artifactCustomProperty, null);

			//Finally return the populated requirement object
			return remoteRequirement;
		}

		/// <summary>
		/// Creates a new requirement in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteRequirement">The new requirement object (primary key will be empty)</param>
		/// <param name="parentRequirementId">Do we want to insert the requirement under a parent requirement</param>
		/// <returns>The populated requirement object - including the primary key</returns>
		/// <remarks>This version is use when you want to specify the location by parent requirement</remarks>
		/// <example>
		/// remoteRequirement = new RemoteRequirement();
		///	remoteRequirement.ReleaseId = releaseId1;
		///	remoteRequirement.StatusId = 3;
		///	remoteRequirement.ImportanceId = 1;
		///	remoteRequirement.Name = "Test Child 1";
		///	remoteRequirement.Description = String.Empty;
		///	remoteRequirement.AuthorId = userId1;
		///	remoteRequirement = spiraImportExport.Requirement_Create2(credentials, remoteRequirement, requirementId5);
		///	int requirementId6 = remoteRequirement.RequirementId.Value;
		/// </example>
		public RemoteRequirement Requirement_Create2(RemoteCredentials credentials, RemoteRequirement remoteRequirement, Nullable<int> parentRequirementId)
		{
			const string METHOD_NAME = "Requirement_Create2";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a requirement id specified
			if (remoteRequirement.RequirementId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_RequirementIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteRequirement.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateRequirements);
			}

			//Default to the authenticated user if we have no author provided
			int authorId = userId;
			if (remoteRequirement.AuthorId.HasValue)
			{
				authorId = remoteRequirement.AuthorId.Value;
			}

			//The current project is always used
			remoteRequirement.ProjectId = projectId;

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			Business.RequirementManager requirementManager = new Business.RequirementManager();

			//Default to the requested status if not value is provided
			Requirement.RequirementStatusEnum requirementStatus = Requirement.RequirementStatusEnum.Requested;
			if (remoteRequirement.StatusId.HasValue)
			{
				//If the template setting allows bulk edit of status, set the status
				ProjectTemplateSettings projectTemplateSettings = new ProjectTemplateSettings(projectTemplateId);
				if (projectTemplateSettings.Workflow_BulkEditCanChangeStatus)
				{
					requirementStatus = (Requirement.RequirementStatusEnum)(remoteRequirement.StatusId.Value);
				}
			}

			//If we have a passed in parent requirement, then we need to insert the requirement as a child item
			if (parentRequirementId.HasValue)
			{
				//Now insert the requirement under the current item.
				remoteRequirement.RequirementId = requirementManager.InsertChild(
					userId,
					projectId,
					remoteRequirement.ReleaseId,
					remoteRequirement.ComponentId,
					parentRequirementId.Value,
					requirementStatus,
					remoteRequirement.RequirementTypeId,
					authorId,
					remoteRequirement.OwnerId,
					remoteRequirement.ImportanceId,
					remoteRequirement.Name,
					remoteRequirement.Description,
					remoteRequirement.EstimatePoints,
					userId
				   );
			}
			else
			{
				//Now insert the requirement at the end of the list
				remoteRequirement.RequirementId = requirementManager.Insert(
					userId,
					projectId,
					remoteRequirement.ReleaseId,
					remoteRequirement.ComponentId,
					(int?)null,
					requirementStatus,
					null,
					authorId,
					remoteRequirement.OwnerId,
					remoteRequirement.ImportanceId,
					remoteRequirement.Name,
					remoteRequirement.Description,
					remoteRequirement.EstimatePoints,
					userId
				   );
			}

			//Now we need to populate any custom properties
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();
			ArtifactCustomProperty artifactCustomProperty = null;
			Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteRequirement, remoteRequirement.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, remoteRequirement.RequirementId.Value, projectTemplateId);
			if (validationMessages != null && validationMessages.Count > 0)
			{
				//Throw a validation exception
				throw CreateValidationException(validationMessages);
			}
			customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

			//Send a notification
			requirementManager.SendCreationNotification(remoteRequirement.RequirementId.Value, artifactCustomProperty, null);

			//Finally return the populated requirement object
			return remoteRequirement;
		}

		/// <summary>
		/// Indents a requirement one position
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementId">The id of the requirement to indent</param>
		public void Requirement_Indent(RemoteCredentials credentials, int projectId, int requirementId)
		{
			const string METHOD_NAME = "Requirement_Indent";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyRequirements);
			}

			//First retrieve the requirement to make sure it exists and is in the authorized project
			try
			{
				RequirementManager requirementManager = new RequirementManager();
				RequirementView sourceRequirement = requirementManager.RetrieveById2(projectId, requirementId);

				//Make sure that the project ids match
				if (sourceRequirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually perform the indent
				requirementManager.Indent(userId, projectId, requirementId);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested requirement");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Outdents a requirement one position
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementId">The id of the requirement to outdent</param>
		public void Requirement_Outdent(RemoteCredentials credentials, int projectId, int requirementId)
		{
			const string METHOD_NAME = "Requirement_Outdent";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyRequirements);
			}

			//First retrieve the requirement to make sure it exists and is in the authorized project
			try
			{
				RequirementManager requirementManager = new RequirementManager();
				RequirementView sourceRequirement = requirementManager.RetrieveById2(projectId, requirementId);

				//Make sure that the project ids match
				if (sourceRequirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually perform the outdent
				requirementManager.Outdent(userId, projectId, requirementId);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested requirement");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Moves a requirement to another location in the hierarchy
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementId">The id of the requirement we want to move</param>
		/// <param name="destinationRequirement">The id of the requirement it's to be inserted before in the list (or null to be at the end)</param>
		public void Requirement_Move(RemoteCredentials credentials, int projectId, int requirementId, int? destinationRequirementId)
		{
			const string METHOD_NAME = "Requirement_Move";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyRequirements);
			}

			//First retrieve the requirements to make sure they exists and are in the authorized project
			try
			{
				RequirementManager requirementManager = new RequirementManager();
				RequirementView sourceRequirement = requirementManager.RetrieveById2(projectId, requirementId);

				//Make sure that the project ids match
				if (sourceRequirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}
				if (destinationRequirementId.HasValue)
				{
					RequirementView destRequirement = requirementManager.RetrieveById2(projectId, destinationRequirementId.Value);
					if (destRequirement.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}
				}

				//Call the business object to actually perform the move
				requirementManager.Move(userId, projectId, requirementId, destinationRequirementId);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested requirement");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Maps a requirement to a test case, so that the test case 'covers' the requirement
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteReqTestCaseMapping">The requirement and test case mapping entry</param>
		/// <remarks>If the coverage record already exists no error is raised</remarks>
		public void Requirement_AddTestCoverage(RemoteCredentials credentials, int projectId, RemoteRequirementTestCaseMapping remoteReqTestCaseMapping)
		{
			const string METHOD_NAME = "Requirement_AddTestCoverage";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			try
			{
				//Add the test case we want to use for coverage
				Business.TestCaseManager testCaseManager = new Business.TestCaseManager();
				List<int> testCaseIds = new List<int>();
				testCaseIds.Add(remoteReqTestCaseMapping.TestCaseId);
				testCaseManager.AddToRequirement(projectId, remoteReqTestCaseMapping.RequirementId, testCaseIds, userId);
			}
			catch (EntityConstraintViolationException)
			{
				//Ignore error due to duplicate row
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Removes a coverage mapping entry for a specific requirement and test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteReqTestCaseMapping">The requirement and test case mapping entry</param>
		public void Requirement_RemoveTestCoverage(RemoteCredentials credentials, int projectId, RemoteRequirementTestCaseMapping remoteReqTestCaseMapping)
		{
			const string METHOD_NAME = "Requirement_RemoveTestCoverage";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			try
			{
				//Restore the test case we want to remove coverage for
				Business.TestCaseManager testCaseManager = new Business.TestCaseManager();
				List<int> testCaseIds = new List<int>();
				testCaseIds.Add(remoteReqTestCaseMapping.TestCaseId);
				testCaseManager.RemoveFromRequirement(projectId, remoteReqTestCaseMapping.RequirementId, testCaseIds, userId);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Retrieves the test coverage for a specific requirement
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementId">The id of the requirement</param>
		/// <returns>The list of mapped test cases</returns>
		public List<RemoteRequirementTestCaseMapping> Requirement_RetrieveTestCoverage(RemoteCredentials credentials, int projectId, int requirementId)
		{
			const string METHOD_NAME = "Requirement_RetrieveTestCoverage";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to retrieve test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			try
			{
				//Retrieve the list of mapped test cases and convert to API object
				Business.TestCaseManager testCaseManager = new Business.TestCaseManager();
				List<RemoteRequirementTestCaseMapping> remoteRequirementTestCaseMappings = new List<RemoteRequirementTestCaseMapping>();
				List<TestCase> mappedTestCases = testCaseManager.RetrieveCoveredByRequirementId(projectId, requirementId);
				foreach (TestCase testCase in mappedTestCases)
				{
					RemoteRequirementTestCaseMapping remoteRequirementTestCaseMapping = new RemoteRequirementTestCaseMapping();
					remoteRequirementTestCaseMapping.RequirementId = requirementId;
					remoteRequirementTestCaseMapping.TestCaseId = testCase.TestCaseId;
					remoteRequirementTestCaseMappings.Add(remoteRequirementTestCaseMapping);
				}
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRequirementTestCaseMappings;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Retrieves all requirements owned by the currently authenticated user
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>List of requirements</returns>
		public List<RemoteRequirement> Requirement_RetrieveForOwner(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Requirement_RetrieveForOwner";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//We assume if they are specified as owner, they have permissions since we can't easily
			//check cross-project permissions in one query
			try
			{
				//Call the business object to actually retrieve the requirement dataset
				RequirementManager requirementManager = new RequirementManager();
				List<RequirementView> requirements = requirementManager.RetrieveByOwnerId(userId, null, null, false);

				//Get the custom property definitions - for all projects
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(Artifact.ArtifactTypeEnum.Requirement);

				//Populate the API data object and return
				List<RemoteRequirement> remoteRequirements = new List<RemoteRequirement>();
				foreach (RequirementView requirement in requirements)
				{
					//Create and populate the row
					RemoteRequirement remoteRequirement = new RemoteRequirement();
					PopulationFunctions.PopulateRequirement(remoteRequirement, requirement);
					PopulationFunctions.PopulateCustomProperties(remoteRequirement, requirement, customProperties);
					remoteRequirements.Add(remoteRequirement);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRequirements;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a single requirement in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementId">The id of the requirement</param>
		/// <returns>Requirement object</returns>
		/// <remarks>Includes any steps</remarks>
		public RemoteRequirement Requirement_RetrieveById(RemoteCredentials credentials, int projectId, int requirementId)
		{
			const string METHOD_NAME = "Requirement_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRequirements);
			}

			//Call the business object to actually retrieve the requirement dataset
			RequirementManager requirementManager = new RequirementManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the requirement was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				RequirementView requirement = requirementManager.RetrieveById2(projectId, requirementId);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, requirementId, DataModel.Artifact.ArtifactTypeEnum.Requirement, true);

				//Make sure that the project ids match
				if (requirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteRequirement remoteRequirement = new RemoteRequirement();
				PopulationFunctions.PopulateRequirement(remoteRequirement, requirement);
				if (artifactCustomProperty != null)
				{
					PopulationFunctions.PopulateCustomProperties(remoteRequirement, artifactCustomProperty);
				}

				//Populate any requirement steps
				List<RequirementStep> requirementSteps = requirementManager.RetrieveSteps(requirementId);
				if (requirementSteps.Count > 0)
				{
					remoteRequirement.Steps = new List<RemoteRequirementStep>();
					foreach (RequirementStep requirementStep in requirementSteps)
					{
						RemoteRequirementStep remoteRequirementStep = new RemoteRequirementStep();
						PopulationFunctions.PopulateRequirementStep(remoteRequirementStep, requirementStep);
						remoteRequirement.Steps.Add(remoteRequirementStep);
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRequirement;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested requirement");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Retrieves a list of requirements in the system that match the provided filter
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of requirements</returns>
		public List<RemoteRequirement> Requirement_Retrieve(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = "Requirement_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRequirements);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Extract the filters from the provided API object
				Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

				//Call the business object to actually retrieve the requirement dataset
				RequirementManager requirementManager = new RequirementManager();
				List<RequirementView> requirements = requirementManager.Retrieve(Business.UserManager.UserInternal, projectId, startingRow, numberOfRows, filters, 0);

				//Get the custom property definitions
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Requirement, false);

				//Populate the API data object and return
				List<RemoteRequirement> remoteRequirements = new List<RemoteRequirement>();
				foreach (RequirementView requirement in requirements)
				{
					//Create and populate the row
					RemoteRequirement remoteRequirement = new RemoteRequirement();
					PopulationFunctions.PopulateRequirement(remoteRequirement, requirement);
					PopulationFunctions.PopulateCustomProperties(remoteRequirement, requirement, customProperties);
					remoteRequirements.Add(remoteRequirement);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRequirements;
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes a requirement in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementId">The id of the requirement</param>
		public void Requirement_Delete(RemoteCredentials credentials, int projectId, int requirementId)
		{
			const string METHOD_NAME = "Requirement_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				RequirementManager requirementManager = new RequirementManager();
				RequirementView requirement = requirementManager.RetrieveById2(projectId, requirementId);

				//Make sure that the project ids match
				if (requirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually mark the item as deleted
				requirementManager.MarkAsDeleted(userId, projectId, requirementId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested requirement");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Updates a requirement in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteRequirement">The updated requirement object</param>
		public void Requirement_Update(RemoteCredentials credentials, RemoteRequirement remoteRequirement)
		{
			const string METHOD_NAME = "Requirement_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have a requirement id specified
			if (!remoteRequirement.RequirementId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_RequirementIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteRequirement.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyRequirements);
			}

			//First retrieve the existing datarow
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				RequirementManager requirementManager = new RequirementManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				Requirement requirement = requirementManager.RetrieveById3(projectId, remoteRequirement.RequirementId.Value);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteRequirement.RequirementId.Value, DataModel.Artifact.ArtifactTypeEnum.Requirement, true);

				//Make sure that the project ids match
				if (requirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
				UpdateFunctions.UpdateRequirementData(requirement, remoteRequirement, projectTemplateId);

				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteRequirement, remoteRequirement.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, remoteRequirement.RequirementId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}
				//Get copies of everything..
				Artifact notificationArt = requirement.Clone();
				ArtifactCustomProperty notificationCust = artifactCustomProperty.Clone();

				//Call the business object to actually update the requirement dataset and the custom properties
				requirementManager.Update(userId, projectId, new List<Requirement>() { requirement });
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Call notifications..
				try
				{
					new NotificationManager().SendNotificationForArtifact(notificationArt, notificationCust, null);
				}
				catch (Exception ex)
				{
					Logger.LogErrorEvent(METHOD_NAME, ex, "Sending message for Requirement #" + requirement.RequirementId + ".");
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested requirement");
				Logger.Flush();
			}
		}

		/// <summary>Retrieves comments for a specified requirement.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="RequirementId">The ID of the Requirement to retrieve comments for.</param>
		/// <returns>An array of comments associated with the specified requirement.</returns>
		public List<RemoteComment> Requirement_RetrieveComments(RemoteCredentials credentials, int projectId, int RequirementId)
		{
			List<RemoteComment> retList = new List<RemoteComment>();

			if (RequirementId > 0)
			{
				retList = this.CommentRetrieve(credentials, projectId, RequirementId, DataModel.Artifact.ArtifactTypeEnum.Requirement);
			}

			return retList;
		}

		/// <summary>Creates a new comment for a requirement.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteComment">The remote comment.</param>
		/// <returns>The RemoteComment with the comment's new ID specified.</returns>
		public RemoteComment Requirement_CreateComment(RemoteCredentials credentials, int projectId, RemoteComment remoteComment)
		{
			RemoteComment retComment = this.CreateComment(credentials, projectId, remoteComment, DataModel.Artifact.ArtifactTypeEnum.Requirement);

			//Send Notification..
			//Pull the requirement.
			int reqNum = -1;
			try
			{
				RequirementView req = new RequirementManager().RetrieveById2(null, remoteComment.ArtifactId, true);
				reqNum = req.RequirementId;
				if (req != null)
					new NotificationManager().SendNotificationForArtifact(req, null, remoteComment.Text);
			}
			catch (Exception ex)
			{
				Logger.LogErrorEvent(CLASS_NAME + "Requirement_CreateComment()", ex, "Sending message for Requirement #" + reqNum + ".");
			}

			return retComment;
		}

		/// <summary>
		/// Retrieves the list of requirement statuses in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of requirement statuses</returns>
		public List<RemoteRequirementStatus> Requirement_RetrieveStatuses(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Requirement_RetrieveStatuses";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Call the business object to actually retrieve the requirement statuses
			RequirementManager requirementManager = new RequirementManager();

			try
			{
				List<RequirementStatus> requirementStati = requirementManager.RetrieveStatuses();

				//Populate the API data objects and return
				List<RemoteRequirementStatus> remoteRequirementStati = new List<RemoteRequirementStatus>();
				foreach (RequirementStatus requirementStatus in requirementStati)
				{
					RemoteRequirementStatus remoteRequirementStatus = new RemoteRequirementStatus();
					PopulationFunctions.PopulateRequirementStatus(remoteRequirementStatus, requirementStatus);
					remoteRequirementStati.Add(remoteRequirementStatus);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRequirementStati;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of requirement importances in the project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of requirement importances </returns>
		public List<RemoteRequirementImportance> Requirement_RetrieveImportances(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Requirement_RetrieveImportances";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Call the business object to actually retrieve the requirement importances
			RequirementManager requirementManager = new RequirementManager();

			try
			{
				List<Importance> importances = requirementManager.RequirementImportance_Retrieve(projectTemplateId);

				//Populate the API data objects and return
				List<RemoteRequirementImportance> remoteRequirementPriorities = new List<RemoteRequirementImportance>();
				foreach (Importance importance in importances)
				{
					RemoteRequirementImportance remoteRequirementImportance = new RemoteRequirementImportance();
					PopulationFunctions.PopulateRequirementImportance(remoteRequirementImportance, importance);
					remoteRequirementPriorities.Add(remoteRequirementImportance);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRequirementPriorities;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of requirement types in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of requirement types </returns>
		public List<RemoteRequirementType> Requirement_RetrieveTypes(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Requirement_RetrieveTypes";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Call the business object to actually retrieve the requirement types
			RequirementManager requirementManager = new RequirementManager();
			RequirementWorkflowManager workflowManager = new RequirementWorkflowManager();

			try
			{
				List<RequirementType> requirementTypes = requirementManager.RequirementType_Retrieve(projectTemplateId, false);

				//Populate the API data objects and return
				List<RemoteRequirementType> remoteRequirementTypes = new List<RemoteRequirementType>();
				foreach (RequirementType requirementType in requirementTypes)
				{
					RemoteRequirementType remoteRequirementType = new RemoteRequirementType();
					PopulationFunctions.PopulateRequirementType(remoteRequirementType, requirementType);
					remoteRequirementTypes.Add(remoteRequirementType);

					//Also get the associated workflow for this project
					remoteRequirementType.WorkflowId = workflowManager.Workflow_GetForRequirementType(requirementType.RequirementTypeId);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRequirementTypes;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of requirement fields and their workflow status for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current requirement type</param>
		/// <param name="currentStatusId">The current requirement status</param>
		/// <returns>The list of requirement fields</returns>
		public List<RemoteWorkflowField> Requirement_RetrieveWorkflowFields(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "Requirement_RetrieveWorkflowFields";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowField> retList = new List<RemoteWorkflowField>();

			//Get the workflow ID for the specified type.
			RequirementWorkflowManager workflowManager = new RequirementWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForRequirementType(currentTypeId);

			//Pull fields.
			List<RequirementWorkflowField> workflowFields = workflowManager.Workflow_RetrieveFieldStates(workflowId, currentStatusId);

			foreach (RequirementWorkflowField workflowField in workflowFields)
			{
				RemoteWorkflowField remoteWorkflowField = new RemoteWorkflowField();
				PopulationFunctions.PopulateWorkflowField(remoteWorkflowField, workflowField);
				retList.Add(remoteWorkflowField);
			}

			return retList;
		}

		/// <summary>
		/// Will retrieve available transitions for the specied status ID for the currently logged-on user.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current requirement type</param>
		/// <param name="currentStatusId">The current requirement status</param>
		/// <param name="isCreator">Is the user the creator of the requirement</param>
		/// <param name="isOwner">Is the user the owner of the requirement</param>
		/// <returns>The list of workflow transitions</returns>
		public List<RemoteWorkflowTransition> Requirement_RetrieveWorkflowTransitions(RemoteCredentials credentials, int projectId, int currentTypeId, int currentStatusId, bool isCreator, bool isOwner)
		{
			const string METHOD_NAME = "Requirement_RetrieveWorkflowTransitions";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRequirements);
			}

			List<RemoteWorkflowTransition> retList = new List<RemoteWorkflowTransition>();

			//Get the use's role in the project.
			ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
			if (projectUser == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}
			int roleId = projectUser.ProjectRoleId;

			//Get the workflow ID for the specified type.
			RequirementWorkflowManager workflowManager = new RequirementWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForRequirementType(currentTypeId);

			List<RequirementWorkflowTransition> workflowTransitions = workflowManager.WorkflowTransition_RetrieveByInputStatus(workflowId, currentStatusId, roleId, isCreator, isOwner);

			foreach (RequirementWorkflowTransition transition in workflowTransitions)
			{
				RemoteWorkflowTransition wrkTransition = new RemoteWorkflowTransition();
				PopulationFunctions.PopulateWorkflowTransition(wrkTransition, transition);
				retList.Add(wrkTransition);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves the list of requirement custom properties and their workflow state for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current requirement type</param>
		/// <param name="currentStatusId">The current requirement status</param>
		/// <returns>The list of requirement custom property states</returns>
		public List<RemoteWorkflowCustomProperty> Requirement_RetrieveWorkflowCustomProperties(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "Requirement_RetrieveWorkflowCustomProperties";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowCustomProperty> retList = new List<RemoteWorkflowCustomProperty>();

			//Get the workflow ID for the specified type.
			RequirementWorkflowManager workflowManager = new RequirementWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForRequirementType(currentTypeId);

			//Pull custom properties
			List<RequirementWorkflowCustomProperty> workflowCustomProperties = workflowManager.Workflow_RetrieveCustomPropertyStates(workflowId, currentStatusId);

			foreach (RequirementWorkflowCustomProperty workflowCustomProperty in workflowCustomProperties)
			{
				RemoteWorkflowCustomProperty remoteWorkflowCustomProperty = new RemoteWorkflowCustomProperty();
				PopulationFunctions.PopulateWorkflowCustomProperty(remoteWorkflowCustomProperty, workflowCustomProperty);
				retList.Add(remoteWorkflowCustomProperty);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves a list of requirement steps
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementId">The id of the requirement</param>
		/// <returns>The list of steps</returns>
		public List<RemoteRequirementStep> Requirement_RetrieveSteps(RemoteCredentials credentials, int projectId, int requirementId)
		{
			const string METHOD_NAME = "Requirement_RetrieveSteps";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRequirements);
			}

			try
			{
				RequirementManager requirementManager = new RequirementManager();
				RequirementView requirement = requirementManager.RetrieveById2(projectId, requirementId);

				//Make sure that the project ids match
				if (requirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the requirement steps
				List<RequirementStep> requirementSteps = requirementManager.RetrieveSteps(requirementId);
				List<RemoteRequirementStep> remoteRequirementSteps = new List<RemoteRequirementStep>();
				foreach (RequirementStep requirementStep in requirementSteps)
				{
					RemoteRequirementStep remoteRequirementStep = new RemoteRequirementStep();
					PopulationFunctions.PopulateRequirementStep(remoteRequirementStep, requirementStep);
					remoteRequirementSteps.Add(remoteRequirementStep);
				}

				return remoteRequirementSteps;
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a single requirement step by its ID
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementStepId">The id of the requirement step</param>
		/// <returns>The requirement step</returns>
		public RemoteRequirementStep Requirement_RetrieveStepById(RemoteCredentials credentials, int projectId, int requirementStepId)
		{
			const string METHOD_NAME = "Requirement_RetrieveStepById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRequirements);
			}

			try
			{
				//Get the requirement step with requirement/project info
				RequirementManager requirementManager = new RequirementManager();
				RequirementStep requirementStep = requirementManager.RetrieveStepById(requirementStepId, false, true);

				//Make sure that the project ids match
				if (requirementStep.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the requirement step
				RemoteRequirementStep remoteRequirementStep = new RemoteRequirementStep();
				PopulationFunctions.PopulateRequirementStep(remoteRequirementStep, requirementStep);

				return remoteRequirementStep;
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Adds a requirement step to a requirement
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteRequirementStep">The new step to add</param>
		/// <param name="existingRequirementStepId">The id of the existing step to insert before (null = end of the list)</param>
		/// <param name="creatorId">The id of the user adding the step (null = use authenticated user)</param>
		/// <returns>The step with the id added</returns>
		public RemoteRequirementStep Requirement_AddStep(RemoteCredentials credentials, int projectId, RemoteRequirementStep remoteRequirementStep, int? existingRequirementStepId, int? creatorId)
		{
			const string METHOD_NAME = "Requirement_AddStep";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to modify requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRequirements);
			}

			try
			{
				RequirementManager requirementManager = new RequirementManager();
				RequirementView requirement = requirementManager.RetrieveById2(projectId, remoteRequirementStep.RequirementId);

				//Make sure that the project ids match
				if (requirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Now add the step
				remoteRequirementStep.RequirementStepId = requirementManager.InsertStep(
					projectId,
					remoteRequirementStep.RequirementId,
					existingRequirementStepId,
					remoteRequirementStep.Description,
					(creatorId.HasValue) ? creatorId.Value : userId,
					remoteRequirementStep.CreationDate
					);

				//Return object
				return remoteRequirementStep;
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates an existing requirement step
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteRequirementStep">The step to update</param>
		public void Requirement_UpdateStep(RemoteCredentials credentials, int projectId, RemoteRequirementStep remoteRequirementStep)
		{
			const string METHOD_NAME = "Requirement_UpdateStep";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure the id is populated
			if (!remoteRequirementStep.RequirementStepId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("RequirementStepIdMissing", Resources.Messages.Services_RequirementStepIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to modify requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRequirements);
			}

			try
			{
				RequirementManager requirementManager = new RequirementManager();
				RequirementView requirement = requirementManager.RetrieveById2(projectId, remoteRequirementStep.RequirementId);

				//Make sure that the project ids match
				if (requirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Now retrieve the step and update
				RequirementStep requirementStep = requirementManager.RetrieveStepById(remoteRequirementStep.RequirementStepId.Value);
				if (requirementStep != null && requirementStep.RequirementId == requirement.RequirementId)
				{
					requirementStep.StartTracking();
					requirementStep.Description = remoteRequirementStep.Description;
					requirementStep.ConcurrencyDate = remoteRequirementStep.ConcurrencyDate;
					requirementManager.UpdateStep(projectId, requirementStep, userId);
				}
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Moves a requirement step in the list
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementId">The id of the requirement</param>
		/// <param name="sourceRequirementStepId">The id of the step to move</param>
		/// <param name="destinationRequirementStepId">The id of the step to move in front of, pass null to move to the end of the list</param>
		public void Requirement_MoveStep(RemoteCredentials credentials, int projectId, int requirementId, int sourceRequirementStepId, int? destinationRequirementStepId)
		{
			const string METHOD_NAME = "Requirement_MoveStep";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to modify requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRequirements);
			}

			try
			{
				RequirementManager requirementManager = new RequirementManager();
				RequirementView requirement = requirementManager.RetrieveById2(projectId, requirementId);

				//Make sure that the test case is in the authorized project
				if (requirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Get the list of test steps
				List<RequirementStep> requirementSteps = requirementManager.RetrieveSteps(requirementId);

				//Make sure that both test step ids are in the test case
				bool sourceRequirementStepFound = false;
				bool destRequirementStepFound = false;
				foreach (RequirementStep requirementStep in requirementSteps)
				{
					if (requirementStep.RequirementStepId == sourceRequirementStepId)
					{
						sourceRequirementStepFound = true;
					}
					if (!destinationRequirementStepId.HasValue || requirementStep.RequirementStepId == destinationRequirementStepId.Value)
					{
						destRequirementStepFound = true;
					}
				}
				if (!sourceRequirementStepFound)
				{
					throw CreateFault("RequirementStepNotInRequirement", "The source requirement step id cannot be found in the requirement");
				}
				if (!destRequirementStepFound)
				{
					throw CreateFault("RequirementStepNotInRequirement", "The destination requirement step id cannot be found in the requirement");
				}

				//Call the business object to actually perform the move
				requirementManager.MoveStep(requirementId, sourceRequirementStepId, destinationRequirementStepId, userId);
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes a requirement step in the list
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementId">The id of the requirement</param>
		/// <param name="requirementStepId">The id of the step to delete</param>
		public void Requirement_DeleteStep(RemoteCredentials credentials, int projectId, int requirementId, int requirementStepId)
		{
			const string METHOD_NAME = "Requirement_DeleteStep";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to modify requirements
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Requirement, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRequirements);
			}

			try
			{
				RequirementManager requirementManager = new RequirementManager();
				RequirementView requirement = requirementManager.RetrieveById2(projectId, requirementId);

				//Make sure that the test case is in the authorized project
				if (requirement.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Get the list of test steps
				List<RequirementStep> requirementSteps = requirementManager.RetrieveSteps(requirementId);

				//Make sure the step is in the requirement, otherwise ignore
				if (requirementSteps.Any(r => r.RequirementStepId == requirementStepId))
				{
					//Call the business object to actually perform the delete
					requirementManager.DeleteStep(projectId, requirementStepId, userId);
				}
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Adds a test step to a requirement
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteReqTestStepMapping">The new mapping entry</param>
		public void Requirement_AddTestStepCoverage(RemoteCredentials credentials, int projectId, RemoteRequirementTestStepMapping remoteReqTestStepMapping)
		{
			const string METHOD_NAME = "Requirement_AddTestStepCoverage";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test steps
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			try
			{
				//Add the test step we want to use for coverage
				RequirementManager requirementManager = new RequirementManager();
				List<int> requirementIds = new List<int>();
				requirementIds.Add(remoteReqTestStepMapping.RequirementId);
				requirementManager.RequirementTestStep_AddToTestStep(projectId, userId, remoteReqTestStepMapping.TestStepId, requirementIds, true);
			}
			catch (EntityConstraintViolationException)
			{
				//Ignore error due to duplicate row
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Retrieves the list of test steps associated with a requirement
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="requirementId">The id of the requirement</param>
		/// <returns>The list of mappings</returns>
		public List<RemoteRequirementTestStepMapping> Requirement_RetrieveTestStepCoverage(RemoteCredentials credentials, int projectId, int requirementId)
		{
			const string METHOD_NAME = "Requirement_RetrieveTestStepCoverage";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to retrieve test steps
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			try
			{
				//Retrieve the list of mapped test steps and convert to API object
				RequirementManager requirementManager = new RequirementManager();
				List<RemoteRequirementTestStepMapping> remoteRequirementTestStepMappings = new List<RemoteRequirementTestStepMapping>();
				List<TestStep> mappedTestSteps = requirementManager.RequirementTestStep_RetrieveByRequirementId(projectId, requirementId);
				foreach (TestStep testStep in mappedTestSteps)
				{
					RemoteRequirementTestStepMapping remoteRequirementTestStepMapping = new RemoteRequirementTestStepMapping();
					remoteRequirementTestStepMapping.RequirementId = requirementId;
					remoteRequirementTestStepMapping.TestStepId = testStep.TestStepId;
					remoteRequirementTestStepMappings.Add(remoteRequirementTestStepMapping);
				}
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRequirementTestStepMappings;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Removes a test step from a requirement
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteReqTestStepMapping">The mapping entry to remove</param>
		public void Requirement_RemoveTestStepCoverage(RemoteCredentials credentials, int projectId, RemoteRequirementTestStepMapping remoteReqTestStepMapping)
		{
			const string METHOD_NAME = "Requirement_AddTestStepCoverage";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test steps
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			try
			{
				//Add the test step we want to use for coverage
				RequirementManager requirementManager = new RequirementManager();
				List<int> requirementIds = new List<int>();
				requirementIds.Add(remoteReqTestStepMapping.RequirementId);
				requirementManager.RequirementTestStep_RemoveFromTestStep(projectId, remoteReqTestStepMapping.TestStepId, requirementIds);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		#endregion Requirement Methods

		#region Test Step Methods

		/// <summary>
		/// Retrieves a list of the requirement ids mapped against a specific test step
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testStepId">The ID of the test step</param>
		/// <returns></returns>
		public List<RemoteRequirementTestStepMapping> TestStep_RetrieveRequirementCoverage(RemoteCredentials credentials, int projectId, int testStepId)
		{
			const string METHOD_NAME = "TestStep_RetrieveRequirementCoverage";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to retrieve test steps
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			try
			{
				//Retrieve the list of mapped requirements and convert to API object
				RequirementManager requirementManager = new RequirementManager();
				List<RemoteRequirementTestStepMapping> remoteRequirementTestStepMappings = new List<RemoteRequirementTestStepMapping>();
				List<RequirementView> mappedRequirements = requirementManager.RequirementTestStep_RetrieveByTestStepId(User.UserInternal, projectId, testStepId);
				foreach (RequirementView requirement in mappedRequirements)
				{
					RemoteRequirementTestStepMapping remoteRequirementTestStepMapping = new RemoteRequirementTestStepMapping();
					remoteRequirementTestStepMapping.RequirementId = testStepId;
					remoteRequirementTestStepMapping.TestStepId = requirement.RequirementId;
					remoteRequirementTestStepMappings.Add(remoteRequirementTestStepMapping);
				}
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRequirementTestStepMappings;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		#endregion

		#region Test Case Methods

		/// <summary>Returns the number of test cases that match the filter.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="releaseId">The id of the release, null = All Releases</param>
		/// <returns>The number of items.</returns>
		public long TestCase_Count(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, int? releaseId)
		{
			const string METHOD_NAME = CLASS_NAME + "TestCase_Count";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the test case count
			long retNum;
			if (releaseId.HasValue)
			{
				retNum = new TestCaseManager().CountByRelease(projectId, releaseId.Value, filters, 0, TestCaseManager.TEST_CASE_FOLDER_ID_ALL_TEST_CASES);
			}
			else
			{
				retNum = new TestCaseManager().Count(projectId, filters, 0, TestCaseManager.TEST_CASE_FOLDER_ID_ALL_TEST_CASES);
			}

			Logger.LogExitingEvent(METHOD_NAME);
			return retNum;
		}

		/// <summary>Gives a count of items within the given folder that match the filters.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">Filters for the child items.</param>
		/// <param name="testCaseFolderId">The TestCase folder to count in. (null = root folder)</param>
		/// <param name="releaseId">The id of the release, null = All Releases</param>
		/// <returns>A number of all items (folder objects and test cases) in the given parent folder ID.</returns>
		public long TestCase_CountForFolder(RemoteCredentials credentials, int projectId, int? testCaseFolderId, List<RemoteFilter> remoteFilters, int? releaseId)
		{
			const string METHOD_NAME = CLASS_NAME + "TestCase_CountForFolder";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the incident dataset
			long retNum;
			if (releaseId.HasValue)
			{
				retNum = new TestCaseManager().CountByRelease(projectId, releaseId.Value, filters, 0, testCaseFolderId);
			}
			else
			{
				retNum = new TestCaseManager().Count(projectId, filters, 0, testCaseFolderId);
			}

			Logger.LogExitingEvent(METHOD_NAME);
			return retNum;
		}

		/// <summary>
		/// Creates a new test case folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestCaseFolder">The new test case folder object (primary key will be empty)</param>
		/// <returns>The populated test case folder object - including the primary key</returns>
		public RemoteTestCaseFolder TestCase_CreateFolder(RemoteCredentials credentials, RemoteTestCaseFolder remoteTestCaseFolder)
		{
			const string METHOD_NAME = "TestCase_CreateFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a test folder id specified
			if (remoteTestCaseFolder.TestCaseFolderId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TestCaseIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestCaseFolder.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestFolders);
			}

			//Always use the current project
			remoteTestCaseFolder.ProjectId = projectId;

			//Instantiate the test case business class
			Business.TestCaseManager testCaseManager = new Business.TestCaseManager();

			//Now insert the test folder under the parent
			remoteTestCaseFolder.TestCaseFolderId = testCaseManager.TestCaseFolder_Create(
				remoteTestCaseFolder.Name,
				remoteTestCaseFolder.ProjectId,
				remoteTestCaseFolder.Description,
				remoteTestCaseFolder.ParentTestCaseFolderId
				).TestCaseFolderId;


			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTestCaseFolder;
		}

		/// <summary>
		/// Creates a new test case in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestCase">The new test case object (primary key will be empty)</param>
		/// <returns>The populated test case object - including the primary key</returns>
		public RemoteTestCase TestCase_Create(RemoteCredentials credentials, RemoteTestCase remoteTestCase)
		{
			const string METHOD_NAME = "TestCase_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a test case id specified
			if (remoteTestCase.TestCaseId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TestCaseIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestCase.ProjectId;


			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to create test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestCases);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Default to the authenticated user if we have no author provided
			int authorId = userId;
			if (remoteTestCase.AuthorId.HasValue)
			{
				authorId = remoteTestCase.AuthorId.Value;
			}
			//Always use the current project
			remoteTestCase.ProjectId = projectId;

			//Instantiate the test case business class
			Business.TestCaseManager testCaseManager = new Business.TestCaseManager();

			//By default, use the default test case status of draft
			TestCase.TestCaseStatusEnum testCaseStatus = TestCase.TestCaseStatusEnum.Draft;
			ProjectTemplateSettings projectTemplateSettings = new ProjectTemplateSettings(projectTemplateId);
			//If bulk edit allows editing of status AND a status of not zero passed in use the passed in status
			if (projectTemplateSettings.Workflow_BulkEditCanChangeStatus && remoteTestCase.TestCaseStatusId > 0)
			{
				testCaseStatus = (TestCase.TestCaseStatusEnum)remoteTestCase.TestCaseStatusId;
			}

			//Insert test case inside the folder
			//We don't set the automation engine or attachment since that is done by a separate function
			remoteTestCase.TestCaseId = testCaseManager.Insert(
				userId,
				projectId,
				authorId,
				remoteTestCase.OwnerId,
				remoteTestCase.Name,
				remoteTestCase.Description,
				remoteTestCase.TestCaseTypeId,
				testCaseStatus,
				remoteTestCase.TestCasePriorityId,
				remoteTestCase.TestCaseFolderId,
				remoteTestCase.EstimatedDuration,
				null,
				null,
				true,
				false,
				remoteTestCase.ComponentIds
				);

			//Now we need to populate any custom properties
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();
			ArtifactCustomProperty artifactCustomProperty = null;
			Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTestCase, remoteTestCase.ProjectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, remoteTestCase.TestCaseId.Value, projectTemplateId);
			if (validationMessages != null && validationMessages.Count > 0)
			{
				//Throw a validation exception
				throw CreateValidationException(validationMessages);
			}
			customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

			//Send a notification
			testCaseManager.SendCreationNotification(remoteTestCase.TestCaseId.Value, artifactCustomProperty, null);

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTestCase;
		}

		/// <summary>
		/// Retrieves a list of testCases in the project (all folders) that match the provided filter
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="releaseId">The id of the release, null = all releases</param>
		/// <param name="remoteSort">The sort to use</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of testCases</returns>
		public List<RemoteTestCase> TestCase_Retrieve(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows, int? releaseId)
		{
			const string METHOD_NAME = "TestCase_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view testCases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the testCase dataset
			TestCaseManager testCaseManager = new TestCaseManager();

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestCase, false);

			//See if we have a release specified or not
			List<RemoteTestCase> remoteTestCases = new List<RemoteTestCase>();
			if (releaseId.HasValue)
			{
				List<TestCaseReleaseView> testCases = testCaseManager.RetrieveByReleaseId(projectId, releaseId.Value, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0, TestCaseManager.TEST_CASE_FOLDER_ID_ALL_TEST_CASES);

				//Populate the API data object and return
				foreach (TestCaseReleaseView testCase in testCases)
				{
					//Create and populate the row
					RemoteTestCase remoteTestCase = new RemoteTestCase();
					PopulationFunctions.PopulateTestCase(remoteTestCase, testCase);
					PopulationFunctions.PopulateCustomProperties(remoteTestCase, testCase, customProperties);
					remoteTestCases.Add(remoteTestCase);
				}
			}
			else
			{
				List<TestCaseView> testCases = testCaseManager.Retrieve(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0, TestCaseManager.TEST_CASE_FOLDER_ID_ALL_TEST_CASES);

				//Populate the API data object and return
				foreach (TestCaseView testCase in testCases)
				{
					//Create and populate the row
					RemoteTestCase remoteTestCase = new RemoteTestCase();
					PopulationFunctions.PopulateTestCase(remoteTestCase, testCase);
					PopulationFunctions.PopulateCustomProperties(remoteTestCase, testCase, customProperties);
					remoteTestCases.Add(remoteTestCase);
				}
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTestCases;
		}

		/// <summary>
		/// Retrieves all testCases owned by the currently authenticated user
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>List of testCases</returns>
		public List<RemoteTestCase> TestCase_RetrieveForOwner(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "TestCase_RetrieveForOwner";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//We assume if they are specified as owner, they have permissions since we can't easily
			//check cross-project permissions in one query
			try
			{
				//Call the business object to actually retrieve the testCase dataset
				TestCaseManager testCaseManager = new TestCaseManager();
				List<TestCaseView> testCases = testCaseManager.RetrieveByOwnerId(userId, null);

				//Get the custom property definitions - for all projects
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(Artifact.ArtifactTypeEnum.TestCase);

				//Populate the API data object and return
				List<RemoteTestCase> remoteTestCases = new List<RemoteTestCase>();
				foreach (TestCaseView testCase in testCases)
				{
					//Create and populate the row
					RemoteTestCase remoteTestCase = new RemoteTestCase();
					PopulationFunctions.PopulateTestCase(remoteTestCase, testCase);
					PopulationFunctions.PopulateCustomProperties(remoteTestCase, testCase, customProperties);
					remoteTestCases.Add(remoteTestCase);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestCases;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves all of the test case folders in the project with their hierarchy
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>List of test case folders</returns>
		public List<RemoteTestCaseFolder> TestCase_RetrieveFolders(RemoteCredentials credentials, int projectId)
		{
			const string METHOD_NAME = "TestCase_RetrieveFolders";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test case dataset
			TestCaseManager testCaseManager = new TestCaseManager();

			//If the test case folder was not found, just return null
			try
			{
				List<RemoteTestCaseFolder> remoteTestCaseFolders = new List<RemoteTestCaseFolder>();

				List<TestCaseFolderHierarchyView> testCaseFolders = testCaseManager.TestCaseFolder_GetList(projectId);

				foreach (TestCaseFolderHierarchyView testCaseFolder in testCaseFolders)
				{
					//Populate the API data objects and return
					RemoteTestCaseFolder remoteTestCaseFolder = new RemoteTestCaseFolder();
					PopulationFunctions.PopulateTestCaseFolder(remoteTestCaseFolder, testCaseFolder);
					remoteTestCaseFolders.Add(remoteTestCaseFolder);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestCaseFolders;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of folders by the parent folder
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="parentTestCaseFolderId">The id of the parent folder, or null = root</param>
		/// <param name="releaseId">The id of the current release, or null = all releases</param>
		/// <returns>The list of folders</returns>
		public List<RemoteTestCaseFolder> TestCase_RetrieveFoldersByParent(RemoteCredentials credentials, int projectId, int? parentTestCaseFolderId, int? releaseId)
		{
			const string METHOD_NAME = "TestCase_RetrieveFoldersByParent";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test case dataset
			TestCaseManager testCaseManager = new TestCaseManager();

			//If the test case folder was not found, just return null
			try
			{
				List<RemoteTestCaseFolder> remoteTestCaseFolders = new List<RemoteTestCaseFolder>();

				//See if we have a release specified
				if (releaseId.HasValue)
				{
					List<TestCaseFolderReleaseView> testCaseFolders = testCaseManager.TestCaseFolder_GetByParentIdForRelease(projectId, parentTestCaseFolderId, releaseId.Value);

					foreach (TestCaseFolderReleaseView testCaseFolder in testCaseFolders)
					{
						//Populate the API data objects and return
						RemoteTestCaseFolder remoteTestCaseFolder = new RemoteTestCaseFolder();
						PopulationFunctions.PopulateTestCaseFolder(remoteTestCaseFolder, testCaseFolder);
						remoteTestCaseFolders.Add(remoteTestCaseFolder);
					}
				}
				else
				{
					List<TestCaseFolder> testCaseFolders = testCaseManager.TestCaseFolder_GetByParentId(projectId, parentTestCaseFolderId);

					foreach (TestCaseFolder testCaseFolder in testCaseFolders)
					{
						//Populate the API data objects and return
						RemoteTestCaseFolder remoteTestCaseFolder = new RemoteTestCaseFolder();
						PopulationFunctions.PopulateTestCaseFolder(remoteTestCaseFolder, testCaseFolder);
						remoteTestCaseFolders.Add(remoteTestCaseFolder);
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestCaseFolders;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of testCases in the project (all folders) that match the provided filter
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="releaseId">The id of the release, null = all releases</param>
		/// <param name="remoteSort">The sort to use</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <param name="testCaseFolderId">The id of the folder, null = root</param>
		/// <returns>List of testCases</returns>
		public List<RemoteTestCase> TestCase_RetrieveByFolder(RemoteCredentials credentials, int projectId, int? testCaseFolderId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows, int? releaseId)
		{
			const string METHOD_NAME = "TestCase_RetrieveByFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view testCases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the testCase dataset
			TestCaseManager testCaseManager = new TestCaseManager();

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestCase, false);

			//See if we have a release specified or not
			List<RemoteTestCase> remoteTestCases = new List<RemoteTestCase>();
			if (releaseId.HasValue)
			{
				List<TestCaseReleaseView> testCases = testCaseManager.RetrieveByReleaseId(projectId, releaseId.Value, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0, testCaseFolderId);

				//Populate the API data object and return
				foreach (TestCaseReleaseView testCase in testCases)
				{
					//Create and populate the row
					RemoteTestCase remoteTestCase = new RemoteTestCase();
					PopulationFunctions.PopulateTestCase(remoteTestCase, testCase);
					PopulationFunctions.PopulateCustomProperties(remoteTestCase, testCase, customProperties);
					remoteTestCases.Add(remoteTestCase);
				}
			}
			else
			{
				List<TestCaseView> testCases = testCaseManager.Retrieve(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0, testCaseFolderId);

				//Populate the API data object and return
				foreach (TestCaseView testCase in testCases)
				{
					//Create and populate the row
					RemoteTestCase remoteTestCase = new RemoteTestCase();
					PopulationFunctions.PopulateTestCase(remoteTestCase, testCase);
					PopulationFunctions.PopulateCustomProperties(remoteTestCase, testCase, customProperties);
					remoteTestCases.Add(remoteTestCase);
				}
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTestCases;
		}

		/// <summary>
		/// Retrieves a single test case in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <returns>Test Case object</returns>
		/// <remarks>
		/// This also populates the test steps collection if you have the appropriate permissions
		/// </remarks>
		public RemoteTestCase TestCase_RetrieveById(RemoteCredentials credentials, int projectId, int testCaseId)
		{
			const string METHOD_NAME = "TestCase_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test case dataset
			TestCaseManager testCaseManager = new TestCaseManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the test case was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				TestCaseView testCase = testCaseManager.RetrieveById(projectId, testCaseId);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, testCaseId, DataModel.Artifact.ArtifactTypeEnum.TestCase, true);

				//Make sure that the project ids match
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteTestCase remoteTestCase = new RemoteTestCase();
				PopulationFunctions.PopulateTestCase(remoteTestCase, testCase);
				if (artifactCustomProperty != null)
				{
					PopulationFunctions.PopulateCustomProperties(remoteTestCase, artifactCustomProperty);
				}

				//See if this user has the permissions to view test steps
				//Make sure we have permissions to view test steps
				if (IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.View))
				{
					//Get the custom property definitions
					List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestStep, false);

					//Get the test steps
					List<TestStepView> testSteps = testCaseManager.RetrieveStepsForTestCase(testCaseId);

					//Populate the test step API data objects and return
					//The TestStepRow already includes the custom properties, so no need to get them from the
					//CustomProperty business object (unlike the test case itself)
					remoteTestCase.TestSteps = new List<RemoteTestStep>();
					foreach (TestStepView testStep in testSteps)
					{
						RemoteTestStep remoteTestStep = new RemoteTestStep();
						PopulationFunctions.PopulateTestStep(remoteTestStep, testStep, testCase.ProjectId);
						PopulationFunctions.PopulateCustomProperties(remoteTestStep, testStep, customProperties);
						remoteTestCase.TestSteps.Add(remoteTestStep);
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestCase;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test case");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Retrieves a single test folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseFolderId">The id of the test folder</param>
		/// <returns>Test Case Folder object</returns>
		public RemoteTestCaseFolder TestCase_RetrieveFolderById(RemoteCredentials credentials, int projectId, int testCaseFolderId)
		{
			const string METHOD_NAME = "TestCase_RetrieveFolderById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test case dataset
			TestCaseManager testCaseManager = new TestCaseManager();

			//If the test case folder was not found, just return null
			try
			{
				TestCaseFolder testCaseFolder = testCaseManager.TestCaseFolder_GetById(testCaseFolderId);
				if (testCaseFolder == null)
				{
					return null;
				}

				//Make sure that the project ids match
				if (testCaseFolder.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteTestCaseFolder remoteTestCaseFolder = new RemoteTestCaseFolder();
				PopulationFunctions.PopulateTestCaseFolder(remoteTestCaseFolder, testCaseFolder);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestCaseFolder;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves all the test cases that are part of a test set
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testSetId">The id of the test set</param>
		/// <returns>List of Test Case objects</returns>
		public List<RemoteTestCase> TestCase_RetrieveByTestSetId(RemoteCredentials credentials, int projectId, int testSetId)
		{
			const string METHOD_NAME = "TestCase_RetrieveByTestSetId";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test set test case dataset
			TestSetManager testSetManager = new TestSetManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the test case was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//We use the option to return with execution data
				List<TestSetTestCaseView> testSetTestCases = testSetManager.RetrieveTestCases3(projectId, testSetId, null);

				//Get the custom property definitions
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestCase, false);

				//Populate the API data object and return
				List<RemoteTestCase> remoteTestCases = new List<RemoteTestCase>();
				foreach (TestSetTestCaseView testSetTestCase in testSetTestCases)
				{
					RemoteTestCase remoteTestCase = new RemoteTestCase();
					remoteTestCases.Add(remoteTestCase);
					PopulationFunctions.PopulateTestCase(remoteTestCase, testSetTestCase);
					PopulationFunctions.PopulateCustomProperties(remoteTestCase, testSetTestCase, customProperties);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestCases;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test case");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Retrieves the list of defined parameters for a test case along with the associated default value
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <returns>List of parameters</returns>
		public List<RemoteTestCaseParameter> TestCase_RetrieveParameters(RemoteCredentials credentials, int projectId, int testCaseId)
		{
			const string METHOD_NAME = "TestCase_RetrieveParameters";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test case parameters
			TestCaseManager testCaseManager = new TestCaseManager();

			try
			{
				//First retrieve the test case and verify it belongs to the current project (for security reasons)
				TestCaseView testCase = testCaseManager.RetrieveById(projectId, testCaseId);
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Now retrieve the parameters
				List<TestCaseParameter> testCaseParameters = testCaseManager.RetrieveParameters(testCaseId);

				//Loop through the dataset and populate the API object
				List<RemoteTestCaseParameter> remoteTestCaseParameters = new List<RemoteTestCaseParameter>();
				foreach (TestCaseParameter testCaseParameter in testCaseParameters)
				{
					RemoteTestCaseParameter remoteTestCaseParameter = new RemoteTestCaseParameter();
					remoteTestCaseParameter.TestCaseParameterId = testCaseParameter.TestCaseParameterId;
					remoteTestCaseParameter.TestCaseId = testCaseParameter.TestCaseId;
					remoteTestCaseParameter.Name = testCaseParameter.Name;
					remoteTestCaseParameter.DefaultValue = (String.IsNullOrEmpty(testCaseParameter.DefaultValue)) ? null : testCaseParameter.DefaultValue;
					remoteTestCaseParameters.Add(remoteTestCaseParameter);
				}

				return remoteTestCaseParameters;
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}

		}

		/// <summary>
		/// Retrieves the list of parameters and provided values for a test link step
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <param name="testStepId">The id of the test step (link)</param>
		/// <returns>List of parameters</returns>
		public List<RemoteTestStepParameter> TestCase_RetrieveStepParameters(RemoteCredentials credentials, int projectId, int testCaseId, int testStepId)
		{
			const string METHOD_NAME = "TestCase_RetrieveStepParameters";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test case parameters
			TestCaseManager testCaseManager = new TestCaseManager();

			try
			{
				//First retrieve the test case and verify it belongs to the current project (for security reasons)
				//and that the test step is inside the specified test case (for security reasons)
				TestCase testCase = testCaseManager.RetrieveByIdWithSteps(projectId, testCaseId);
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}
				TestStep testStep = testCase.TestSteps.FirstOrDefault(s => s.TestStepId == testStepId);
				if (testStep == null)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Next actually retrieve the parameters
				List<TestStepParameter> testStepParameterValues = testCaseManager.RetrieveParameterValues(testStepId);

				//Loop through the dataset and populate the API object
				List<RemoteTestStepParameter> testStepParameters = new List<RemoteTestStepParameter>();
				foreach (TestStepParameter dataRow in testStepParameterValues)
				{
					RemoteTestStepParameter testStepParameter = new RemoteTestStepParameter();
					testStepParameter.Name = dataRow.Name;
					testStepParameter.Value = dataRow.Value;
					testStepParameters.Add(testStepParameter);
				}

				return testStepParameters;
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Adds new parameters with provided names and values for a test link step
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <param name="testStepId">The id of the test step (link)</param>
		/// <param name="testStepParameters">An array of parameters to add (with names and values)</param>
		public void TestCase_AddStepParameters(RemoteCredentials credentials, int projectId, int testCaseId, int testStepId, List<RemoteTestStepParameter> testStepParameters)
		{
			const string METHOD_NAME = "TestCase_AddStepParameters";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated and authorized user
			bool isAuthorized = IsAuthorizedForProject(credentials, projectId, CLASS_NAME, METHOD_NAME);

			//Make sure we have permissions to edit this test step
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestSteps);
			}


			try
			{
				//Call the business object to actually retrieve the test case parameters
				TestCaseManager testCaseManager = new TestCaseManager();

				//First retrieve the test case and verify it belongs to the current project (for security reasons)
				//and that the test step is inside the specified test case (for security reasons)
				TestCase testCase = testCaseManager.RetrieveByIdWithSteps(projectId, testCaseId);
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}
				TestStep testStep = testCase.TestSteps.FirstOrDefault(s => s.TestStepId == testStepId);
				if (testStep == null)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				PopulationFunctions.PopulateTestStepParameter(projectId, testStep, testStepParameters);
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates existing parameters with provided names and values for a test link step
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <param name="testStepId">The id of the test step (link)</param>
		/// <param name="testStepParameters">An array of parameters to update (with names and values)</param>
		public void TestCase_UpdateStepParameters(RemoteCredentials credentials, int projectId, int testCaseId, int testStepId, List<RemoteTestStepParameter> testStepParameters)
		{
			const string METHOD_NAME = "TestCase_UpdateStepParameters";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated and authorized user
			bool isAuthorized = IsAuthorizedForProject(credentials, projectId, CLASS_NAME, METHOD_NAME);

			//Make sure we have permissions to edit this test step
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestSteps);
			}

			try
			{
				//Call the business object to actually retrieve the test case parameters
				TestCaseManager testCaseManager = new TestCaseManager();

				//First retrieve the test case and verify it belongs to the current project (for security reasons)
				//and that the test step is inside the specified test case (for security reasons)
				TestCase testCase = testCaseManager.RetrieveByIdWithSteps(projectId, testCaseId);
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}
				TestStep testStep = testCase.TestSteps.FirstOrDefault(s => s.TestStepId == testStepId);
				if (testStep == null)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSteps);
				}

				UpdateFunctions.UpdateTestStepParameter(projectId, testStep, testStepParameters);
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes existing parameters with provided names and values for a test link step
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <param name="testStepId">The id of the test step (link)</param>
		/// <param name="testStepParameters">An array of parameters to delete (with names and values)</param>
		public void TestCase_DeleteStepParameters(RemoteCredentials credentials, int projectId, int testCaseId, int testStepId, List<RemoteTestStepParameter> testStepParameters)
		{
			const string METHOD_NAME = "TestCase_DeleteStepParameters";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated and authorized user
			bool isAuthorized = IsAuthorizedForProject(credentials, projectId, CLASS_NAME, METHOD_NAME);

			//Make sure we have permissions to edit this test step
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestSteps);
			}

			try
			{
				//Call the business object to actually retrieve the test case parameters
				TestCaseManager testCaseManager = new TestCaseManager();

				//First retrieve the test case and verify it belongs to the current project (for security reasons)
				//and that the test step is inside the specified test case (for security reasons)
				TestCase testCase = testCaseManager.RetrieveByIdWithSteps(projectId, testCaseId);
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}
				TestStep testStep = testCase.TestSteps.FirstOrDefault(s => s.TestStepId == testStepId);
				if (testStep == null)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSteps);
				}

				DeleteFunctions.DeleteTestStepParameter(projectId, testStep, testStepParameters);
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates a test case in the system together with its test steps (if populated)
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestCase">The updated test case object</param>
		public void TestCase_Update(RemoteCredentials credentials, RemoteTestCase remoteTestCase)
		{
			const string METHOD_NAME = "TestCase_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have a testCase id specified
			if (!remoteTestCase.TestCaseId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_TestCaseIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestCase.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			//First retrieve the existing datarow
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				TestCaseManager testCaseManager = new TestCaseManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();

				TestCase testCase = testCaseManager.RetrieveByIdWithSteps(projectId, remoteTestCase.TestCaseId.Value);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteTestCase.TestCaseId.Value, DataModel.Artifact.ArtifactTypeEnum.TestCase, true);

				//Make sure that the project ids match
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
				//First the test case report
				UpdateFunctions.UpdateTestCaseData(testCase, remoteTestCase, projectTemplateId);
				UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTestCase, remoteTestCase.ProjectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, remoteTestCase.TestCaseId.Value, projectTemplateId);
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Now the test steps records
				if (remoteTestCase.TestSteps != null)
				{
					foreach (RemoteTestStep remoteTestStep in remoteTestCase.TestSteps)
					{
						//Locate the matching row
						if (remoteTestStep.TestStepId.HasValue)
						{
							TestStep testStep = testCase.TestSteps.FirstOrDefault(s => s.TestStepId == remoteTestStep.TestStepId.Value);
							if (testStep != null)
							{
								//Get the corresponding custom properties
								ArtifactCustomProperty testStepCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteTestStep.TestStepId.Value, DataModel.Artifact.ArtifactTypeEnum.TestStep, true);
								UpdateFunctions.UpdateTestStepData(testStep, remoteTestStep);
								UpdateFunctions.UpdateCustomPropertyData(ref testStepCustomProperty, remoteTestStep, remoteTestCase.ProjectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, remoteTestStep.TestStepId.Value, projectTemplateId);

								//Save the custom properties
								customPropertyManager.ArtifactCustomProperty_Save(testStepCustomProperty, userId);
							}
						}
					}
				}

				//Extract changes for use in notifications
				Dictionary<string, object> changes = testCase.ExtractChanges();
				ArtifactCustomProperty notificationCust = artifactCustomProperty.Clone();

				//Call the business object to actually update the testCase dataset
				testCaseManager.Update(testCase, userId);

				//Call notifications..
				try
				{
					testCase.ApplyChanges(changes);
					new NotificationManager().SendNotificationForArtifact(testCase, notificationCust, null);
				}
				catch (Exception ex)
				{
					Logger.LogErrorEvent(METHOD_NAME, ex, "Sending message for " + testCase.ArtifactToken);
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test case");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Updates a test folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestCaseFolder">The updated test case folder object</param>
		public void TestCase_UpdateFolder(RemoteCredentials credentials, RemoteTestCaseFolder remoteTestCaseFolder)
		{
			const string METHOD_NAME = "TestCase_UpdateFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have a testCase folder id specified
			if (!remoteTestCaseFolder.TestCaseFolderId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_TestCaseIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestCaseFolder.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			//First retrieve the existing datarow
			try
			{
				TestCaseManager testCaseManager = new TestCaseManager();

				TestCaseFolder testCaseFolder = testCaseManager.TestCaseFolder_GetById(remoteTestCaseFolder.TestCaseFolderId.Value);
				if (testCaseFolder != null)
				{
					//Make sure that the project ids match
					if (testCaseFolder.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}

					//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
					//First the test case report
					UpdateFunctions.UpdateTestCaseFolderData(testCaseFolder, remoteTestCaseFolder);

					//Call the business object to actually update the test folder dataset
					testCaseManager.TestCaseFolder_Update(testCaseFolder);
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Moves a test step to a different position in the test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The id of the test case we're interested in</param>
		/// <param name="sourceTestStepId">The id of the test step we want to move</param>
		/// <param name="destinationTestStepId">The id of the test step we want to move it in front of (passing Null means end of the list)</param>
		public void TestCase_MoveStep(RemoteCredentials credentials, int projectId, int testCaseId, int sourceTestStepId, int? destinationTestStepId)
		{
			const string METHOD_NAME = "TestCase_MoveStep";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			//First retrieve the test case to make sure it exists and are in the authorized project
			try
			{
				TestCaseManager testCaseManager = new TestCaseManager();
				TestCase sourceTestCase = testCaseManager.RetrieveByIdWithSteps(projectId, testCaseId);

				//Make sure that the test case is in the authorized project
				if (sourceTestCase.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Make sure that both test step ids are in the test case
				bool sourceTestStepFound = false;
				bool destTestStepFound = false;
				foreach (TestStep testStep in sourceTestCase.TestSteps)
				{
					if (testStep.TestStepId == sourceTestStepId)
					{
						sourceTestStepFound = true;
					}
					if (!destinationTestStepId.HasValue || testStep.TestStepId == destinationTestStepId.Value)
					{
						destTestStepFound = true;
					}
				}
				if (!sourceTestStepFound)
				{
					throw CreateFault("TestStepNotInTestCase", "The source test step id cannot be found in the test case");
				}
				if (!destTestStepFound)
				{
					throw CreateFault("TestStepNotInTestCase", "The destination test step id cannot be found in the test case");
				}

				//Call the business object to actually perform the move
				testCaseManager.MoveStep(testCaseId, sourceTestStepId, destinationTestStepId, userId);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test case");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Moves a test case to another location in the hierarchy
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The id of the test case we want to move</param>
		/// <param name="destinationTestFolderId">The id of the folder case it's to be inserted under in the list (or null to be at the root)</param>
		public void TestCase_Move(RemoteCredentials credentials, int projectId, int testCaseId, int? destinationTestFolderId)
		{
			const string METHOD_NAME = "TestCase_Move";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			//First retrieve the test cases to make sure they exists and are in the authorized project
			try
			{
				TestCaseManager testCaseManager = new TestCaseManager();
				TestCaseView sourceTestCase = testCaseManager.RetrieveById(projectId, testCaseId);

				//Make sure that the project ids match
				if (sourceTestCase.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}
				if (destinationTestFolderId.HasValue)
				{
					TestCaseFolder destTestCaseFolder = testCaseManager.TestCaseFolder_GetById(destinationTestFolderId.Value);
					if (destTestCaseFolder == null)
					{
						throw new ArtifactNotExistsException();
					}
					if (destTestCaseFolder.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}
				}

				//Call the business object to actually perform the move
				testCaseManager.TestCase_UpdateFolder(testCaseId, destinationTestFolderId);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test case");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Deletes a test case in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <remarks>
		/// Also deletes any child test steps
		/// </remarks>
		public void TestCase_Delete(RemoteCredentials credentials, int projectId, int testCaseId)
		{
			const string METHOD_NAME = "TestCase_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				TestCaseManager testCaseManager = new TestCaseManager();
				TestCaseView testCase = testCaseManager.RetrieveById(projectId, testCaseId);

				//Make sure that the project ids match
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually mark the item as deleted
				testCaseManager.MarkAsDeleted(userId, projectId, testCaseId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test case");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Deletes a test case folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseFolderId">The id of the test case</param>
		public void TestCase_DeleteFolder(RemoteCredentials credentials, int projectId, int testCaseFolderId)
		{
			const string METHOD_NAME = "TestCase_DeleteFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				TestCaseManager testCaseManager = new TestCaseManager();
				TestCaseFolder testCaseFolder = testCaseManager.TestCaseFolder_GetById(testCaseFolderId);
				if (testCaseFolder != null)
				{
					//Make sure that the project ids match
					if (testCaseFolder.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}

					//Call the business object to actually delete the folder
					testCaseManager.TestCaseFolder_Delete(projectId, testCaseFolderId, userId);
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes a test step in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <param name="testStepId">The id of the test step</param>
		/// <remarks>Doesn't throw an exception if the step no longer exists</remarks>
		public void TestCase_DeleteStep(RemoteCredentials credentials, int projectId, int testCaseId, int testStepId)
		{
			const string METHOD_NAME = "TestCase_DeleteStep";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete test steps
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				TestCaseManager testCaseManager = new TestCaseManager();
				TestCase testCase = testCaseManager.RetrieveByIdWithSteps(projectId, testCaseId);
				if (testCase.TestSteps.Count == 0 || !testCase.TestSteps.Any(s => s.TestStepId == testStepId))
				{
					//Log a warning and just ignore if the step does not exist
					Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test step");
					return;
				}

				//Make sure that the project ids match
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually mark the item as deleted
				testCaseManager.MarkStepAsDeleted(userId, testCaseId, testStepId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test case");
				Logger.Flush();
			}
		}

		/// <summary>Adds or updates the automation test script associated with a test case</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="userId">The user making the change</param>
		/// <param name="projectId">The id of the current project</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <param name="automationEngineId">The id of the automation engine</param>
		/// <param name="urlOrFilename">The url or filename for the test script</param>
		/// <param name="description">The description of the automation script</param>
		/// <param name="binaryData">The binary data that comprises the script (only for file attachments)</param>
		/// <param name="version">The version of the test script</param>
		/// <param name="documentTypeId">The attachment type to store the script under (optional)</param>
		/// <param name="projectAttachmentFolderId">The attachment folder to store the script under (optional)</param>
		public void TestCase_AddUpdateAutomationScript(RemoteCredentials credentials, int projectId, int testCaseId, Nullable<int> automationEngineId, string urlOrFilename, string description, byte[] binaryData, string version, Nullable<int> documentTypeId, Nullable<int> projectAttachmentFolderId)
		{
			const string METHOD_NAME = "TestCase_AddUpdateAutomationScript";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			//Call the test case function to update the automation script
			TestCaseManager testCaseManager = new TestCaseManager();
			testCaseManager.AddUpdateAutomationScript(userId, projectId, testCaseId, automationEngineId, urlOrFilename, description, binaryData, version, documentTypeId, projectAttachmentFolderId);

			try
			{
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
			}
		}

		/// <summary>
		/// Returns the full token of a test case parameter from its name
		/// </summary>
		/// <param name="parameterName">The name of the parameter</param>
		/// <returns>The tokenized representation of the parameter used for search/replace</returns>
		/// <remarks>We use the same parameter format as Ant/NAnt</remarks>
		public string TestCase_CreateParameterToken(string parameterName)
		{
			return TestCaseManager.CreateParameterToken(parameterName);
		}

		/// <summary>
		/// Adds a new parameter for a test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestCaseParameter">The new test case parameter to add</param>
		/// <returns>The test case parameter object with the primary key populated</returns>
		/// <remarks>The parameter name is always made lower case</remarks>
		public RemoteTestCaseParameter TestCase_AddParameter(RemoteCredentials credentials, int projectId, RemoteTestCaseParameter remoteTestCaseParameter)
		{
			const string METHOD_NAME = "TestCase_AddParameter";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a test case parameter id already specified
			if (remoteTestCaseParameter.TestCaseParameterId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TestCaseParameterIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			try
			{
				//Instantiate the test case business class
				TestCaseManager testCaseManager = new TestCaseManager();

				//Now insert the test case parameter
				remoteTestCaseParameter.TestCaseParameterId = testCaseManager.InsertParameter(
					projectId,
				   remoteTestCaseParameter.TestCaseId,
				   remoteTestCaseParameter.Name,
				   remoteTestCaseParameter.DefaultValue
				   );

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestCaseParameter;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Updates an existing parameter for a test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="project_id">The id of the current project</param>
		/// <param name="remoteTestCaseParameter">The test case parameter to update</param>
		public void TestCase_UpdateParameter(RemoteCredentials credentials, int projectId, RemoteTestCaseParameter remoteTestCaseParameter)
		{
			const string METHOD_NAME = "TestCase_UpdateParameter";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			//Must pass in a testcaseparameter id, testcase id, and name can't be blank
			if (!remoteTestCaseParameter.TestCaseParameterId.HasValue || remoteTestCaseParameter.TestCaseParameterId <= 0 || string.IsNullOrEmpty(remoteTestCaseParameter.Name))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TestCaseParameterUpdateFields);
			}

			//First retrieve the existing datarow
			try
			{
				//Instantiate the test case business class
				TestCaseManager testCaseManager = new TestCaseManager();
				List<TestCaseParameter> testCaseParameters = testCaseManager.RetrieveParameters(remoteTestCaseParameter.TestCaseId);

				//Find the specific parameter by ID
				TestCaseParameter testCaseParameter = testCaseParameters.FirstOrDefault(p => p.TestCaseParameterId == remoteTestCaseParameter.TestCaseParameterId.Value);

				//Make sure the parameter is part of the test case
				if (testCaseParameter == null)
				{
					throw CreateFault("TestCaseParameterNotInTestCase", Resources.Messages.Services_TestCaseParameterNotInTestCase);
				}

				//Make sure that the project ids match
				TestCase testCase = testCaseManager.RetrieveById2(projectId, testCaseParameter.TestCaseId);
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Now update the test case parameter
				testCaseManager.UpdateParameter(projectId,
					(int)remoteTestCaseParameter.TestCaseParameterId.Value,
					remoteTestCaseParameter.Name,
					remoteTestCaseParameter.DefaultValue
				);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Deletes an existing parameter for a test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="project_id">The id of the current project</param>
		/// <param name="remoteTestCaseParameter">The test case parameter to deleted</param>
		public void TestCase_DeleteParameter(RemoteCredentials credentials, int projectId, RemoteTestCaseParameter remoteTestCaseParameter)
		{
			const string METHOD_NAME = "TestCase_UpdateParameter";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			//Must pass in a testcaseparameter id, testcase id, and name can't be blank
			if (!remoteTestCaseParameter.TestCaseParameterId.HasValue || remoteTestCaseParameter.TestCaseParameterId <= 0 || string.IsNullOrEmpty(remoteTestCaseParameter.Name))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TestCaseParameterDeleteFields);
			}

			//First retrieve the existing datarow
			try
			{
				//Instantiate the test case business class
				TestCaseManager testCaseManager = new TestCaseManager();
				List<TestCaseParameter> testCaseParameters = testCaseManager.RetrieveParameters(remoteTestCaseParameter.TestCaseId);

				//Find the specific parameter by ID
				TestCaseParameter testCaseParameter = testCaseParameters.FirstOrDefault(p => p.TestCaseParameterId == remoteTestCaseParameter.TestCaseParameterId.Value);

				//Make sure the parameter is part of the test case
				if (testCaseParameter == null)
				{
					throw CreateFault("TestCaseParameterNotInTestCase", Resources.Messages.Services_TestCaseParameterNotInTestCase);
				}

				//Make sure that the project ids match
				TestCase testCase = testCaseManager.RetrieveById2(projectId, testCaseParameter.TestCaseId);
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Now delete the test case parameter
				testCaseManager.DeleteParameter(projectId, (int)remoteTestCaseParameter.TestCaseParameterId.Value);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Retrieves the list of test steps for a test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The id of the test case</param>
		/// <returns>The list of test steps</returns>
		public List<RemoteTestStep> TestCase_RetrieveSteps(RemoteCredentials credentials, int projectId, int testCaseId)
		{
			const string METHOD_NAME = "TestCase_RetrieveSteps";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test steps
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test step list
			TestCaseManager testCaseManager = new TestCaseManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the test case was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Get the custom property definitions
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestStep, false);

				//Get the test steps
				List<TestStepView> testSteps = testCaseManager.RetrieveStepsForTestCase(testCaseId);

				//Populate the test step API data objects and return
				//The TestStepRow already includes the custom properties, so no need to get them from the
				//CustomProperty business object (unlike the test case itself)
				List<RemoteTestStep> remoteTestSteps = new List<RemoteTestStep>();
				foreach (TestStepView testStep in testSteps)
				{
					RemoteTestStep remoteTestStep = new RemoteTestStep();
					PopulationFunctions.PopulateTestStep(remoteTestStep, testStep, projectId);
					PopulationFunctions.PopulateCustomProperties(remoteTestStep, testStep, customProperties);
					remoteTestSteps.Add(remoteTestStep);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestSteps;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a single test step by its ID
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testStepId">The id of the test step</param>
		/// <returns>The test step</returns>
		public RemoteTestStep TestCase_RetrieveStepById(RemoteCredentials credentials, int projectId, int testStepId)
		{
			const string METHOD_NAME = "TestCase_RetrieveStepById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test steps
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test step list
			TestCaseManager testCaseManager = new TestCaseManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the test step was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Get the test step and custom property
				TestStepView testStep = testCaseManager.RetrieveStepById2(null, testStepId);
				if (testStep == null)
				{
					return null;
				}
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, testStepId, DataModel.Artifact.ArtifactTypeEnum.TestStep, true);

				//Make sure that the project ids match
				TestCaseView testCase = testCaseManager.RetrieveById(null, testStep.TestCaseId);
				if (testCase.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the test step API data objects and return
				RemoteTestStep remoteTestStep = new RemoteTestStep();
				PopulationFunctions.PopulateTestStep(remoteTestStep, testStep, projectId);
				if (artifactCustomProperty != null)
				{
					PopulationFunctions.PopulateCustomProperties(remoteTestStep, artifactCustomProperty);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestStep;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates a single test step in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestStep">The test step to update</param>
		public void TestCase_UpdateStep(RemoteCredentials credentials, RemoteTestStep remoteTestStep)
		{
			const string METHOD_NAME = "TestCase_UpdateStep";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have a test step id specified
			if (!remoteTestStep.TestStepId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_TestStepIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestStep.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test steps
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			//First retrieve the existing datarow
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				TestCaseManager testCaseManager = new TestCaseManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();

				TestStep testStep = testCaseManager.RetrieveStepById(null, remoteTestStep.TestStepId.Value);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteTestStep.TestStepId.Value, DataModel.Artifact.ArtifactTypeEnum.TestStep, true);

				//Make sure that the project ids match
				if (testStep.TestCase.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
				//First the test case report
				UpdateFunctions.UpdateTestStepData(testStep, remoteTestStep);
				UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTestStep, testStep.TestCase.ProjectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, remoteTestStep.TestStepId.Value, projectTemplateId);
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Call the business object to actually update the test step dataset
				testCaseManager.UpdateStep(testStep, userId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Adds a new test step to the specified test case
		/// </summary>
		/// <param name="remoteTestStep">The new test step object (primary key will be empty)</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The test case to add it to</param>
		/// <returns>The populated test step object - including the primary key</returns>
		public RemoteTestStep TestCase_AddStep(RemoteCredentials credentials, RemoteTestStep remoteTestStep, int testCaseId)
		{
			const string METHOD_NAME = "TestCase_AddStep";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a test step id specified
			if (remoteTestStep.TestStepId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TestStepIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestStep.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to create test steps
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestSteps);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Instantiate the test case business class
				TestCaseManager testCaseManager = new TestCaseManager();

				//Now insert the test step
				remoteTestStep.TestStepId = testCaseManager.InsertStep(
				   userId,
				   testCaseId,
				   (remoteTestStep.Position < 1) ? null : (int?)remoteTestStep.Position,
				   remoteTestStep.Description,
				   remoteTestStep.ExpectedResult,
				   remoteTestStep.SampleData
				   );

				//Now we need to populate any custom properties
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteTestStep.TestStepId.Value, DataModel.Artifact.ArtifactTypeEnum.TestStep, true);
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTestStep, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, remoteTestStep.TestStepId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}

				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestStep;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Adds a new test step that is actually a link to a test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The test case to add it to</param>
		/// <param name="linkedTestCaseId">The test case being linked to</param>
		/// <param name="parameters">Any parameters to passed to the linked test case</param>
		/// <param name="position">The position in the test step list</param>
		/// <returns>The id of the new test step</returns>
		public int TestCase_AddLink(RemoteCredentials credentials, int projectId, int testCaseId, int position, int linkedTestCaseId, List<RemoteTestStepParameter> parameters)
		{
			const string METHOD_NAME = "TestCase_AddLink";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test steps
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestStep, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestSteps);
			}

			try
			{
				//Instantiate the test case business class
				TestCaseManager testCaseManager = new TestCaseManager();

				//Convert the Soap-safe collection into a normal dictionary, handling null case
				Dictionary<string, string> parametersDictionary = new Dictionary<string, string>();
				if (parameters != null)
				{
					foreach (RemoteTestStepParameter parameter in parameters)
					{
						parametersDictionary.Add(parameter.Name, parameter.Value);
					}
				}

				//Now insert the link test step
				int testStepId = testCaseManager.InsertLink(userId, testCaseId, position, linkedTestCaseId, parametersDictionary);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return testStepId;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>Retrieves comments for a specified test case.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">The ID of the test case to retrieve comments for.</param>
		/// <returns>An array of comments associated with the specified test case.</returns>
		public List<RemoteComment> TestCase_RetrieveComments(RemoteCredentials credentials, int projectId, int testCaseId)
		{
			List<RemoteComment> retList = new List<RemoteComment>();

			if (testCaseId > 0)
			{
				retList = this.CommentRetrieve(credentials, projectId, testCaseId, DataModel.Artifact.ArtifactTypeEnum.TestCase);
			}

			return retList;
		}

		/// <summary>Creates a new comment for a test case.</summary>
		/// <param name="remoteComment">The remote comment.</param>
		/// <returns>The RemoteComment with the comment's new ID specified.</returns>
		public RemoteComment TestCase_CreateComment(RemoteCredentials credentials, int projectId, RemoteComment remoteComment)
		{
			RemoteComment retComment = this.CreateComment(credentials, projectId, remoteComment, DataModel.Artifact.ArtifactTypeEnum.TestCase);

			return retComment;
		}

		/// <summary>
		/// Retrieves the list of testCase statuses in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of testCase statuses</returns>
		public List<RemoteTestCaseStatus> TestCase_RetrieveStatuses(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "TestCase_RetrieveStatuses";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Call the business object to actually retrieve the testCase statuses
			TestCaseManager testCaseManager = new TestCaseManager();

			try
			{
				List<TestCaseStatus> testCaseStati = testCaseManager.RetrieveStatuses();

				//Populate the API data objects and return
				List<RemoteTestCaseStatus> remoteTestCaseStati = new List<RemoteTestCaseStatus>();
				foreach (TestCaseStatus testCaseStatus in testCaseStati)
				{
					RemoteTestCaseStatus remoteTestCaseStatus = new RemoteTestCaseStatus();
					PopulationFunctions.PopulateTestCaseStatus(remoteTestCaseStatus, testCaseStatus);
					remoteTestCaseStati.Add(remoteTestCaseStatus);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestCaseStati;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of testCase priorities in the project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of testCase priorities </returns>
		public List<RemoteTestCasePriority> TestCase_RetrievePriorities(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "TestCase_RetrievePriorities";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Call the business object to actually retrieve the testCase priorities
			TestCaseManager testCaseManager = new TestCaseManager();

			try
			{
				List<TestCasePriority> priorities = testCaseManager.TestCasePriority_Retrieve(projectTemplateId);

				//Populate the API data objects and return
				List<RemoteTestCasePriority> remoteTestCasePriorities = new List<RemoteTestCasePriority>();
				foreach (TestCasePriority priority in priorities)
				{
					RemoteTestCasePriority remoteTestCasePriority = new RemoteTestCasePriority();
					PopulationFunctions.PopulateTestCasePriority(remoteTestCasePriority, priority);
					remoteTestCasePriorities.Add(remoteTestCasePriority);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestCasePriorities;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of testCase types in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of testCase types </returns>
		public List<RemoteTestCaseType> TestCase_RetrieveTypes(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "TestCase_RetrieveTypes";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Call the business object to actually retrieve the testCase types
			TestCaseManager testCaseManager = new TestCaseManager();
			TestCaseWorkflowManager workflowManager = new TestCaseWorkflowManager();

			try
			{
				List<TestCaseType> testCaseTypes = testCaseManager.TestCaseType_Retrieve(projectTemplateId);

				//Populate the API data objects and return
				List<RemoteTestCaseType> remoteTestCaseTypes = new List<RemoteTestCaseType>();
				foreach (TestCaseType testCaseType in testCaseTypes)
				{
					RemoteTestCaseType remoteTestCaseType = new RemoteTestCaseType();
					PopulationFunctions.PopulateTestCaseType(remoteTestCaseType, testCaseType);
					remoteTestCaseTypes.Add(remoteTestCaseType);

					//Also get the associated workflow for this project
					remoteTestCaseType.WorkflowId = workflowManager.Workflow_GetForTestCaseType(testCaseType.TestCaseTypeId);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestCaseTypes;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of testCase fields and their workflow status for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current testCase type</param>
		/// <param name="currentStatusId">The current testCase status</param>
		/// <returns>The list of testCase fields</returns>
		public List<RemoteWorkflowField> TestCase_RetrieveWorkflowFields(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "TestCase_RetrieveWorkflowFields";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowField> retList = new List<RemoteWorkflowField>();

			//Get the workflow ID for the specified type.
			TestCaseWorkflowManager workflowManager = new TestCaseWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForTestCaseType(currentTypeId);

			//Pull fields.
			List<TestCaseWorkflowField> workflowFields = workflowManager.Workflow_RetrieveFieldStates(workflowId, currentStatusId);

			foreach (TestCaseWorkflowField workflowField in workflowFields)
			{
				RemoteWorkflowField remoteWorkflowField = new RemoteWorkflowField();
				PopulationFunctions.PopulateWorkflowField(remoteWorkflowField, workflowField);
				retList.Add(remoteWorkflowField);
			}

			return retList;
		}

		/// <summary>
		/// Will retrieve available transitions for the specied status ID for the currently logged-on user.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current testCase type</param>
		/// <param name="currentStatusId">The current testCase status</param>
		/// <param name="isCreator">Is the user the creator of the testCase</param>
		/// <param name="isOwner">Is the user the owner of the testCase</param>
		/// <returns>The list of workflow transitions</returns>
		public List<RemoteWorkflowTransition> TestCase_RetrieveWorkflowTransitions(RemoteCredentials credentials, int projectId, int currentTypeId, int currentStatusId, bool isCreator, bool isOwner)
		{
			const string METHOD_NAME = "TestCase_RetrieveWorkflowTransitions";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view testCases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			List<RemoteWorkflowTransition> retList = new List<RemoteWorkflowTransition>();

			//Get the use's role in the project.
			ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
			if (projectUser == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}
			int roleId = projectUser.ProjectRoleId;

			//Get the workflow ID for the specified type.
			TestCaseWorkflowManager workflowManager = new TestCaseWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForTestCaseType(currentTypeId);

			List<TestCaseWorkflowTransition> workflowTransitions = workflowManager.WorkflowTransition_RetrieveByInputStatus(workflowId, currentStatusId, roleId, isCreator, isOwner);

			foreach (TestCaseWorkflowTransition transition in workflowTransitions)
			{
				RemoteWorkflowTransition wrkTransition = new RemoteWorkflowTransition();
				PopulationFunctions.PopulateWorkflowTransition(wrkTransition, transition);
				retList.Add(wrkTransition);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves the list of testCase custom properties and their workflow state for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current testCase type</param>
		/// <param name="currentStatusId">The current testCase status</param>
		/// <returns>The list of testCase custom property states</returns>
		public List<RemoteWorkflowCustomProperty> TestCase_RetrieveWorkflowCustomProperties(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "TestCase_RetrieveWorkflowCustomProperties";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowCustomProperty> retList = new List<RemoteWorkflowCustomProperty>();

			//Get the workflow ID for the specified type.
			TestCaseWorkflowManager workflowManager = new TestCaseWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForTestCaseType(currentTypeId);

			//Pull custom properties
			List<TestCaseWorkflowCustomProperty> workflowCustomProperties = workflowManager.Workflow_RetrieveCustomPropertyStates(workflowId, currentStatusId);

			foreach (TestCaseWorkflowCustomProperty workflowCustomProperty in workflowCustomProperties)
			{
				RemoteWorkflowCustomProperty remoteWorkflowCustomProperty = new RemoteWorkflowCustomProperty();
				PopulationFunctions.PopulateWorkflowCustomProperty(remoteWorkflowCustomProperty, workflowCustomProperty);
				retList.Add(remoteWorkflowCustomProperty);
			}

			return retList;
		}

		#endregion Test Case Methods

		#region Test Run Methods

		/// <summary>Returns the number of test runs that match the filter.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <returns>The number of items.</returns>
		public long TestRun_Count(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters)
		{
			const string METHOD_NAME = CLASS_NAME + "TestRun_Count";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestRuns);
			}

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the incident dataset
			long retNum = new TestRunManager().Count(projectId, filters, 0);

			Logger.LogExitingEvent(METHOD_NAME);
			return retNum;
		}

		/// <summary>
		/// Creates a new test run shell from the provided test case(s)
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseIds">The list of test cases to create the run for</param>
		/// <param name="releaseId">A release to associate the test run with (optional)</param>
		/// <returns>The list of new test case run data objects</returns>
		/// <example>
		/// RemoteManualTestRun[] remoteTestRuns = spiraImportExport.TestRun_CreateFromTestCases(credentials, projectId, new int[] { testCaseId3, testCaseId4 }, iterationId1);
		/// </example>
		public List<RemoteManualTestRun> TestRun_CreateFromTestCases(RemoteCredentials credentials, int projectId, List<int> testCaseIds, Nullable<int> releaseId)
		{
			const string METHOD_NAME = "TestRun_CreateFromTestCases";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestRuns);
			}

			try
			{
				//Instantiate the test run business class
				Business.TestRunManager testRunManager = new Business.TestRunManager();

				//Actually create the new test run
				TestRunsPending testRunsPending = testRunManager.CreateFromTestCase(userId, projectId, releaseId, testCaseIds, false);

				//Populate the API data object and return
				//We don't have any custom properties to populate at this point
				List<RemoteManualTestRun> remoteTestRuns = new List<RemoteManualTestRun>();
				foreach (TestRun testRun in testRunsPending.TestRuns)
				{
					RemoteManualTestRun remoteTestRun = new RemoteManualTestRun();
					PopulationFunctions.PopulateManualTestRun(remoteTestRun, testRun, projectId);
					remoteTestRuns.Add(remoteTestRun);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestRuns;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Deletes a test run from the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testRunId">The id of the test run to delete</param>
		public void TestRun_Delete(RemoteCredentials credentials, int projectId, int testRunId)
		{
			const string METHOD_NAME = "TestRun_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				TestRunManager testRunManager = new TestRunManager();
				TestRunView testRun = testRunManager.RetrieveById(testRunId);

				//Make sure that the project ids match
				if (testRun.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually delete the item
				testRunManager.Delete(testRunId, projectId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test run");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Creates a new test run shell from the provided test set
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testSetId">The test set to create the run for</param>
		/// <returns>The list of new test case run data objects</returns>
		/// <example>
		/// RemoteManualTestRun[] remoteTestRuns = spiraImportExport.TestRun_CreateFromTestSet(credentials, projectId, testSetId1);
		/// </example>
		public List<RemoteManualTestRun> TestRun_CreateFromTestSet(RemoteCredentials credentials, int projectId, int testSetId)
		{
			const string METHOD_NAME = "TestRun_CreateFromTestSet";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to create test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestRuns);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Instantiate the test run business class
				Business.TestRunManager testRunManager = new Business.TestRunManager();

				//Actually create the new test run
				TestRunsPending testRunsPending = testRunManager.CreateFromTestSet(userId, projectId, testSetId, false);

				//Populate the API data object and return
				//We don't have any custom properties to populate at this point
				List<RemoteManualTestRun> remoteTestRuns = new List<RemoteManualTestRun>();
				foreach (TestRun testRun in testRunsPending.TestRuns)
				{
					RemoteManualTestRun remoteTestRun = new RemoteManualTestRun();
					PopulationFunctions.PopulateManualTestRun(remoteTestRun, testRun, projectId);
					remoteTestRuns.Add(remoteTestRun);
				}

				//If the test set had some list custom properties set then we should look for corresponding
				//lists in the test run and if there are matching lists we should set the values to be the same
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				ArtifactCustomProperty testSetCustomProperties = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, testSetId, DataModel.Artifact.ArtifactTypeEnum.TestSet, true);

				//Make sure we have some custom properties on the test set
				if (testSetCustomProperties != null)
				{
					//Get the custom property definitions for test runs
					List<CustomProperty> testRunCustomPropertyDefinitions = customPropertyManager.CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestRun, false);

					//Create a new custom property entity for the test run
					ArtifactCustomProperty testRunArtifactCustomProperty = customPropertyManager.ArtifactCustomProperty_CreateNew(projectId, Artifact.ArtifactTypeEnum.TestRun, -1, testRunCustomPropertyDefinitions);
					testRunArtifactCustomProperty = customPropertyManager.CustomProperty_PopulateDefaults(projectTemplateId, testRunArtifactCustomProperty);
					foreach (CustomProperty testSetCustomPropertyDefinition in testSetCustomProperties.CustomPropertyDefinitions)
					{
						//See if we have a matching property in the test run custom properties (only works for lists)
						if (testSetCustomPropertyDefinition.CustomPropertyListId.HasValue)
						{
							foreach (CustomProperty testRunCustomPropertyDefinition in testRunCustomPropertyDefinitions)
							{
								if (testRunCustomPropertyDefinition.CustomPropertyListId.HasValue && testRunCustomPropertyDefinition.CustomPropertyListId.Value == testSetCustomPropertyDefinition.CustomPropertyListId.Value)
								{
									//We have a matching custom list between the test set and test run
									//So set the value on the matching test run property
									object customPropertyValue = testSetCustomProperties.CustomProperty(testSetCustomPropertyDefinition.PropertyNumber);
									testRunArtifactCustomProperty.SetCustomProperty(testRunCustomPropertyDefinition.PropertyNumber, customPropertyValue);
								}
							}
						}
					}

					//Populate the data objects if we have a row
					if (testRunArtifactCustomProperty != null)
					{
						foreach (RemoteTestRun remoteTestRun in remoteTestRuns)
						{
							PopulationFunctions.PopulateCustomProperties(remoteTestRun, testRunArtifactCustomProperty);
						}
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestRuns;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Creates a shell set of test runs for an external automated test runner based on the provided test set id
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testSetId">The automated test set we want to execute</param>
		/// <param name="automationHostToken">The unique token that identifies this host</param>
		/// <returns>The list of test run objects</returns>
		/// <example>
		/// RemoteAutomatedTestRun[] remoteTestRuns = spiraImportExport.TestRun_CreateForAutomatedTestSet(credentials, projectId, testSetId, token);
		/// </example>
		/// <remarks>For this method the test set doesn't need an automated host to be set</remarks>
		public List<RemoteAutomatedTestRun> TestRun_CreateForAutomatedTestSet(RemoteCredentials credentials, int projectId, int testSetId, string automationHostToken)
		{
			const string METHOD_NAME = "TestRun_CreateForAutomatedTestSet";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestRuns);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Retrieve the automation host by its token
				AutomationManager automationManager = new AutomationManager();
				AutomationHostView automationHost = automationManager.RetrieveHostByToken(projectId, automationHostToken);
				int automationHostId = automationHost.AutomationHostId;

				//Retrieve the provided test set
				TestSetManager testSetManager = new TestSetManager();
				TestSetView testSet = testSetManager.RetrieveById(projectId, testSetId);

				//Make sure that this is an automated test set
				if (testSet.TestRunTypeId != (int)TestRun.TestRunTypeEnum.Automated)
				{
					throw new ApplicationException(Resources.Messages.Services_TestSetNotAutomated);
				}

				//Now we need to retieve any test set parameter values (used later)
				List<TestSetParameter> testSetParameterValues = testSetManager.RetrieveParameterValues(testSetId);

				//Create the list of automated test runs
				List<RemoteAutomatedTestRun> remoteTestRuns = new List<RemoteAutomatedTestRun>();

				TestCaseManager testCaseManager = new TestCaseManager();
				//Iterate through the test cases in the test set
				List<TestSetTestCaseView> testSetTestCases = testSetManager.RetrieveTestCases(testSetId);
				foreach (TestSetTestCaseView testSetTestCase in testSetTestCases)
				{
					//Get the actual test case record for this item and make it has an automation engine and script
					TestCaseView testCase = testCaseManager.RetrieveById(projectId, testSetTestCase.TestCaseId);
					if (testCase.AutomationEngineId.HasValue && testCase.AutomationAttachmentId.HasValue)
					{
						//Get the automation engine token
						AutomationEngine automationEngine = automationManager.RetrieveEngineById(testCase.AutomationEngineId.Value);

						//Create the new automated test run shell
						RemoteAutomatedTestRun remoteTestRun = new RemoteAutomatedTestRun();
						remoteTestRun.ProjectId = projectId;
						remoteTestRun.AutomationHostId = automationHostId;
						remoteTestRun.AutomationEngineId = testCase.AutomationEngineId;
						remoteTestRun.AutomationEngineToken = automationEngine.Token;
						remoteTestRun.AutomationAttachmentId = testCase.AutomationAttachmentId;
						remoteTestRun.TestCaseId = testCase.TestCaseId;
						remoteTestRun.TestSetId = testSet.TestSetId;
						remoteTestRun.TestSetTestCaseId = testSetTestCase.TestSetTestCaseId;
						remoteTestRun.ReleaseId = testSet.ReleaseId;
						remoteTestRun.Name = testCase.Name;
						remoteTestRun.ExecutionStatusId = (int)TestCase.ExecutionStatusEnum.NotRun;
						remoteTestRun.RunnerName = testCase.AutomationEngineName;
						remoteTestRun.TestRunTypeId = (int)TestRun.TestRunTypeEnum.Automated;
						remoteTestRun.TesterId = credentials.UserId;
						remoteTestRuns.Add(remoteTestRun);

						//Now we need to add any test set and/or test case parameter values
						List<TestSetTestCaseParameter> testSetTestCaseParameterValues = testSetManager.RetrieveTestCaseParameterValues(testSetTestCase.TestSetTestCaseId);

						//Now see if we have any default parameter values for parameters not mentioned in the test set
						List<TestCaseParameter> testCaseParameters = testCaseManager.RetrieveParameters(testSetTestCase.TestCaseId);

						//Now we need to add any test parameters
						UpdateFunctions.AddParameterValues(remoteTestRun, testCaseParameters, testSetParameterValues, testSetTestCaseParameterValues);
					}
				}

				//Also copy across any custom property list values
				UpdateFunctions.AddCustomPropertyValuesToAutomatedTestRun(projectId, projectTemplateId, testSetId, remoteTestRuns);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestRuns;
			}
			catch (ArtifactNotExistsException exception)
			{
				//Don't log this because we get too many of them when called by RemoteLaunch
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Creates a shell set of test runs for an external automated test runner based on the provided automation host token
		/// and the specified date range
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="automationHostToken">The unique token that identifies this host</param>
		/// <param name="dateRange">The range of planned dates that we want to include test sets for</param>
		/// <returns>The list of test run objects</returns>
		/// <example>
		/// DateRange dateRange = new DateRange();
		/// dateRange.StartDate = DateTime.UtcNow.AddHours(-1);
		/// dateRange.EndDate = DateTime.UtcNow.AddHours(1);
		/// RemoteAutomatedTestRun[] remoteTestRuns = spiraImportExport.TestRun_CreateForAutomationHost(credentials, projectId, automationHostToken, dateRange);
		/// </example>
		public List<RemoteAutomatedTestRun> TestRun_CreateForAutomationHost(RemoteCredentials credentials, int projectId, string automationHostToken, DataObjects.DateRange dateRange)
		{
			const string METHOD_NAME = "TestRun_CreateForAutomationHost";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestRuns);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Instantiate the business classes
				AutomationManager automationManager = new AutomationManager();
				AutomationHostView automationHost = automationManager.RetrieveHostByToken(projectId, automationHostToken);
				int automationHostId = automationHost.AutomationHostId;

				//See if we have any assigned test sets for this automation host
				TestSetManager testSetManager = new TestSetManager();
				List<TestSetView> testSets = testSetManager.RetrieveByAutomationHostId(automationHostId, GlobalFunctions.UniversalizeDate(dateRange.StartDate), GlobalFunctions.UniversalizeDate(dateRange.EndDate));

				//If we have no test sets, just return null quickly to avoid load on server
				if (testSets.Count < 1)
				{
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					return null;
				}

				//Create the list of automated test runs
				List<RemoteAutomatedTestRun> remoteTestRuns = new List<RemoteAutomatedTestRun>();

				//Iterate through the list of test sets
				TestCaseManager testCaseManager = new TestCaseManager();
				foreach (TestSetView testSet in testSets)
				{
					int testSetId = testSet.TestSetId;

					//Now we need to retieve any test set parameter values (used later)
					List<TestSetParameter> testSetParameterValues = testSetManager.RetrieveParameterValues(testSetId);

					//Iterate through the test cases in the test set
					List<TestSetTestCaseView> testSetTestCases = testSetManager.RetrieveTestCases(testSetId);
					foreach (TestSetTestCaseView testSetTestCase in testSetTestCases)
					{
						//Get the actual test case record for this item and make sure it has an automation engine and script
						TestCaseView testCase = testCaseManager.RetrieveById(projectId, testSetTestCase.TestCaseId);
						if (testCase.AutomationEngineId.HasValue && testCase.AutomationAttachmentId.HasValue)
						{
							//Get the automation engine token
							AutomationEngine automationEngine = automationManager.RetrieveEngineById(testCase.AutomationEngineId.Value);

							//Create the new automated test run shell
							RemoteAutomatedTestRun remoteTestRun = new RemoteAutomatedTestRun();
							remoteTestRun.ProjectId = projectId;
							remoteTestRun.AutomationHostId = automationHostId;
							remoteTestRun.AutomationEngineId = testCase.AutomationEngineId;
							remoteTestRun.AutomationEngineToken = automationEngine.Token;
							remoteTestRun.AutomationAttachmentId = testCase.AutomationAttachmentId;
							remoteTestRun.TestCaseId = testCase.TestCaseId;
							remoteTestRun.TestSetId = testSet.TestSetId;
							remoteTestRun.ScheduledDate = testSet.PlannedDate;
							remoteTestRun.TestSetTestCaseId = testSetTestCase.TestSetTestCaseId;
							remoteTestRun.ReleaseId = testSet.ReleaseId;
							remoteTestRun.Name = testCase.Name;
							remoteTestRun.ExecutionStatusId = (int)TestCase.ExecutionStatusEnum.NotRun;
							remoteTestRun.RunnerName = testCase.AutomationEngineName;
							remoteTestRun.TestRunTypeId = (int)TestRun.TestRunTypeEnum.Automated;
							remoteTestRun.TesterId = credentials.UserId;
							remoteTestRuns.Add(remoteTestRun);

							//Now we need to add any test set and/or test case parameter values
							List<TestSetTestCaseParameter> testSetTestCaseParameterValues = testSetManager.RetrieveTestCaseParameterValues(testSetTestCase.TestSetTestCaseId);

							//Now see if we have any default parameter values for parameters not mentioned in the test set
							List<TestCaseParameter> testCaseParameters = testCaseManager.RetrieveParameters(testSetTestCase.TestCaseId);

							//Add parameters/values, test case ones override test set ones
							UpdateFunctions.AddParameterValues(remoteTestRun, testCaseParameters, testSetParameterValues, testSetTestCaseParameterValues);
						}
					}

					//Also copy across any custom property list values
					UpdateFunctions.AddCustomPropertyValuesToAutomatedTestRun(projectId, projectTemplateId, testSetId, remoteTestRuns);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestRuns;
			}
			catch (ArtifactNotExistsException exception)
			{
				//Don't log this because we get too many of them when called by RemoteLaunch
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Creates a shell set of test runs for an external automated test runner based on the provided automation host token.
		/// This version only includes test sets that have not been started
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="automationHostToken">The unique token that identifies this host</param>
		/// <param name="dateRange">The range of planned dates that we want to include test sets for</param>
		/// <param name="includeOverdueItems">Include overdue items</param>
		/// <returns>The list of test run objects</returns>
		/// <example>
		/// RemoteAutomatedTestRun[] remoteTestRuns = spiraImportExport.TestRun_CreateForAutomationHost2(credentials, projectId, automationHostToken);
		/// </example>
		public List<RemoteAutomatedTestRun> TestRun_CreateForAutomationHost2(RemoteCredentials credentials, int projectId, string automationHostToken)
		{
			const string METHOD_NAME = "TestRun_CreateForAutomationHost2";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestRuns);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Instantiate the business classes
				AutomationManager automationManager = new AutomationManager();
				AutomationHostView automationHost = automationManager.RetrieveHostByToken(projectId, automationHostToken);
				int automationHostId = automationHost.AutomationHostId;

				//See if we have any assigned test sets for this automation host
				TestSetManager testSetManager = new TestSetManager();
				List<TestSetView> testSets = testSetManager.RetrieveByAutomationHostId(automationHostId);

				//If we have no test sets, just return null quickly to avoid load on server
				if (testSets.Count < 1)
				{
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					return null;
				}

				//Create the list of automated test runs
				List<RemoteAutomatedTestRun> remoteTestRuns = new List<RemoteAutomatedTestRun>();

				//Iterate through the list of test sets
				TestCaseManager testCaseManager = new TestCaseManager();
				foreach (TestSetView testSet in testSets)
				{
					int testSetId = testSet.TestSetId;

					//Now we need to retieve any test set parameter values (used later)
					List<TestSetParameter> testSetParameterValues = testSetManager.RetrieveParameterValues(testSetId);

					//Iterate through the test cases in the test set
					List<TestSetTestCaseView> testSetTestCases = testSetManager.RetrieveTestCases(testSetId);
					foreach (TestSetTestCaseView testSetTestCase in testSetTestCases)
					{
						//Get the actual test case record for this item and make it has an automation engine and script
						TestCaseView testCase = testCaseManager.RetrieveById(projectId, testSetTestCase.TestCaseId);
						if (testCase.AutomationEngineId.HasValue && testCase.AutomationAttachmentId.HasValue)
						{
							//Get the automation engine token
							AutomationEngine automationEngine = automationManager.RetrieveEngineById(testCase.AutomationEngineId.Value);

							//Create the new automated test run shell
							RemoteAutomatedTestRun remoteTestRun = new RemoteAutomatedTestRun();
							remoteTestRun.ProjectId = projectId;
							remoteTestRun.AutomationHostId = automationHostId;
							remoteTestRun.AutomationEngineId = testCase.AutomationEngineId;
							remoteTestRun.AutomationEngineToken = automationEngine.Token;
							remoteTestRun.AutomationAttachmentId = testCase.AutomationAttachmentId;
							remoteTestRun.TestCaseId = testCase.TestCaseId;
							remoteTestRun.TestSetId = testSet.TestSetId;
							remoteTestRun.ScheduledDate = testSet.PlannedDate;
							remoteTestRun.TestSetTestCaseId = testSetTestCase.TestSetTestCaseId;
							remoteTestRun.ReleaseId = testSet.ReleaseId;
							remoteTestRun.Name = testCase.Name;
							remoteTestRun.ExecutionStatusId = (int)TestCase.ExecutionStatusEnum.NotRun;
							remoteTestRun.RunnerName = testCase.AutomationEngineName;
							remoteTestRun.TestRunTypeId = (int)TestRun.TestRunTypeEnum.Automated;
							remoteTestRun.TesterId = credentials.UserId;
							remoteTestRuns.Add(remoteTestRun);

							//Now we need to add any test set and/or test case parameter values
							List<TestSetTestCaseParameter> testSetTestCaseParameterValues = testSetManager.RetrieveTestCaseParameterValues(testSetTestCase.TestSetTestCaseId);

							//Now see if we have any default parameter values for parameters not mentioned in the test set
							List<TestCaseParameter> testCaseParameters = testCaseManager.RetrieveParameters(testSetTestCase.TestCaseId);

							//Add parameters/values, test case ones override test set ones
							UpdateFunctions.AddParameterValues(remoteTestRun, testCaseParameters, testSetParameterValues, testSetTestCaseParameterValues);
						}
					}

					//Also copy across any custom property list values
					UpdateFunctions.AddCustomPropertyValuesToAutomatedTestRun(projectId, projectTemplateId, testSetId, remoteTestRuns);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestRuns;
			}
			catch (ArtifactNotExistsException exception)
			{
				//Don't log this because we get too many of them when called by RemoteLaunch
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of test runs for a specific test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testCaseId">the id of the test case</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of test runs</returns>
		/// <remarks>Doesn't include the test run steps</remarks>
		public List<RemoteTestRun> TestRun_RetrieveByTestCaseId(RemoteCredentials credentials, int projectId, int testCaseId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows)
		{
			//Add the test case filter
			if (remoteFilters == null)
			{
				remoteFilters = new List<RemoteFilter>();
			}
			remoteFilters.Add(new RemoteFilter() { PropertyName = "TestCaseId", IntValue = testCaseId });

			return this.TestRun_Retrieve(credentials, projectId, remoteFilters, remoteSort, startingRow, numberOfRows);
		}

		/// <summary>
		/// Retrieves a list of test runs in the system that match the provided filter/sort
		/// </summary>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>List of test runs</returns>
		/// <remarks>Doesn't include the test run steps</remarks>
		public List<RemoteTestRun> TestRun_Retrieve(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = "TestRun_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view testRuns
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestRuns);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the testRun dataset
			//Doesn't include the test run steps
			TestRunManager testRunManager = new TestRunManager();
			List<TestRunView> testRuns = testRunManager.Retrieve(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestRun, false);

			//Populate the API data object and return
			List<RemoteTestRun> remoteTestRuns = new List<RemoteTestRun>();
			foreach (TestRunView testRun in testRuns)
			{
				//Create and populate the row
				RemoteTestRun remoteTestRun = new RemoteTestRun();
				PopulationFunctions.PopulateTestRun(remoteTestRun, testRun, projectId);
				PopulationFunctions.PopulateCustomProperties(remoteTestRun, testRun, customProperties);
				remoteTestRuns.Add(remoteTestRun);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTestRuns;
		}

		/// <summary>Retrieves a list of automated test runs in the system that match the provided filter/sort</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of test runs</returns>
		/// <remarks>Doesn't include the test run steps</remarks>
		public List<RemoteAutomatedTestRun> TestRun_RetrieveAutomated(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = CLASS_NAME + "TestRun_RetrieveAutomated";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view testRuns
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestRuns);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object and add the automated filter.
			if (remoteFilters == null)
				remoteFilters = new List<RemoteFilter>();
			remoteFilters.Add(new RemoteFilter() { IntValue = (int)TestRun.TestRunTypeEnum.Automated, PropertyName = "TestRunTypeId" });
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the testRun dataset
			List<TestRunView> testRuns = new TestRunManager().Retrieve(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestRun, false);

			//Populate the API data object and return
			List<RemoteAutomatedTestRun> remoteTestRuns = new List<RemoteAutomatedTestRun>();
			foreach (TestRunView testRun in testRuns)
			{
				//Create and populate the row
				RemoteAutomatedTestRun remoteTestRun = new RemoteAutomatedTestRun();
				PopulationFunctions.PopulateAutomatedTestRun(remoteTestRun, testRun, projectId);
				PopulationFunctions.PopulateCustomProperties(remoteTestRun, testRun, customProperties);
				remoteTestRuns.Add(remoteTestRun);
			}

			Logger.LogExitingEvent(METHOD_NAME);
			return remoteTestRuns;
		}

		/// <summary>Retrieves a list of manual test runs in the system that match the provided filter/sort</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of test runs</returns>
		/// <remarks>Does include the test run steps</remarks>
		public List<RemoteManualTestRun> TestRun_RetrieveManual(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = CLASS_NAME + "TestRun_RetrieveManual";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view testRuns
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestRuns);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object and add the automated filter.
			if (remoteFilters == null)
				remoteFilters = new List<RemoteFilter>();
			remoteFilters.Add(new RemoteFilter() { IntValue = (int)TestRun.TestRunTypeEnum.Manual, PropertyName = "TestRunTypeId" });
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Create the manager..
			TestRunManager testRunManager = new TestRunManager();
			//Call the business object to actually retrieve the testRun dataset
			List<TestRunView> testRuns = testRunManager.Retrieve(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestRun, false);

			//Populate the API data object and return
			List<RemoteManualTestRun> remoteTestRuns = new List<RemoteManualTestRun>();
			foreach (TestRunView testRunView in testRuns)
			{
				//Get the manual test with test steps..
				TestRun testRunWithSteps = testRunManager.RetrieveByIdWithSteps(testRunView.TestRunId);

				if (testRunWithSteps != null)
				{
					//Create and populate the row
					RemoteManualTestRun remoteTestRun = new RemoteManualTestRun();
					PopulationFunctions.PopulateManualTestRun(remoteTestRun, testRunWithSteps, projectId);
					PopulationFunctions.PopulateCustomProperties(remoteTestRun, testRunWithSteps, customProperties);
					remoteTestRuns.Add(remoteTestRun);
				}
			}

			Logger.LogExitingEvent(METHOD_NAME);
			return remoteTestRuns;
		}

		/// <summary>
		/// Retrieves a single test run in the system. Only returns the generic information
		/// that is applicable for both automated and manual tests. Consider using
		/// TestRun_RetrieveAutomatedById or TestRun_RetrieveManualById if you need
		/// the automation/manual specific data for the test run
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testRunId">The id of the test run</param>
		/// <returns>Test Run object</returns>
		public RemoteTestRun TestRun_RetrieveById(RemoteCredentials credentials, int projectId, int testRunId)
		{
			const string METHOD_NAME = "TestRun_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestRuns);
			}

			//Call the business object to actually retrieve the test run dataset
			TestRunManager testRunManager = new TestRunManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the test run was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				TestRun testRun = testRunManager.RetrieveByIdWithSteps(testRunId);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, testRunId, DataModel.Artifact.ArtifactTypeEnum.TestRun, true);

				//Populate the API data object and return
				RemoteTestRun remoteTestRun = new RemoteTestRun();
				PopulationFunctions.PopulateTestRun(remoteTestRun, testRun, projectId);
				PopulationFunctions.PopulateCustomProperties(remoteTestRun, artifactCustomProperty);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestRun;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test run");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Retrieves a single automated test run in the system including the automation-specific information
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testRunId">The id of the test run</param>
		/// <returns>Test Run object</returns>
		public RemoteAutomatedTestRun TestRun_RetrieveAutomatedById(RemoteCredentials credentials, int projectId, int testRunId)
		{
			const string METHOD_NAME = "TestRun_RetrieveAutomatedById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestRuns);
			}

			//Call the business object to actually retrieve the test run dataset
			TestRunManager testRunManager = new TestRunManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the test run was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				TestRun testRun = testRunManager.RetrieveByIdWithSteps(testRunId);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, testRunId, DataModel.Artifact.ArtifactTypeEnum.TestRun, true);

				//Populate the API data object and return
				RemoteAutomatedTestRun remoteTestRun = new RemoteAutomatedTestRun();
				PopulationFunctions.PopulateAutomatedTestRun(remoteTestRun, testRun, projectId);
				PopulationFunctions.PopulateCustomProperties(remoteTestRun, artifactCustomProperty);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestRun;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test run");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Retrieves a single manual test run in the system including any associated steps
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testRunId">The id of the test run</param>
		/// <returns>Test Run object</returns>
		public RemoteManualTestRun TestRun_RetrieveManualById(RemoteCredentials credentials, int projectId, int testRunId)
		{
			const string METHOD_NAME = "TestRun_RetrieveManualById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestRuns);
			}

			//Call the business object to actually retrieve the test run dataset
			TestRunManager testRunManager = new TestRunManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the test run was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				TestRun testRun = testRunManager.RetrieveByIdWithSteps(testRunId);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, testRunId, DataModel.Artifact.ArtifactTypeEnum.TestRun, true);

				//Populate the API data object and return
				RemoteManualTestRun remoteTestRun = new RemoteManualTestRun();
				PopulationFunctions.PopulateManualTestRun(remoteTestRun, testRun, projectId);
				PopulationFunctions.PopulateCustomProperties(remoteTestRun, artifactCustomProperty);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestRun;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test run");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Records the results of executing an automated test
		/// </summary>
		/// <param name="remoteTestRun">The automated test run information</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>the test run data object with its primary key populated</returns>
		/// <remarks>
		/// You need to use this overload when you want to be able to set Test Run custom properties
		/// </remarks>
		/// <example>
		/// remoteTestRun = new RemoteAutomatedTestRun();
		///	remoteTestRun.TestCaseId = testCaseId1;
		///	remoteTestRun.ReleaseId = iterationId2;
		///	remoteTestRun.StartDate = DateTime.UtcNow;
		///	remoteTestRun.EndDate = DateTime.UtcNow.AddMinutes(2);
		/// remoteTestRun.ExecutionStatusId = Business.TestCase.ExecutionStatusPassed;
		/// remoteTestRun.RunnerName = "TestSuite";
		/// remoteTestRun.RunnerTestName = "02_Test_Method";
		/// testRunId3 = spiraImportExport.TestRun_RecordAutomated1(credentials, remoteTestRun).TestRunId.Value;
		/// </example>
		public RemoteAutomatedTestRun TestRun_RecordAutomated1(RemoteCredentials credentials, RemoteAutomatedTestRun remoteTestRun)
		{
			const string METHOD_NAME = "TestRun_RecordAutomated1";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a runner name was provided (needed for automated tests)
			if (String.IsNullOrEmpty(remoteTestRun.RunnerName))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_RunnerNameMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestRun.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestRuns);
			}

			try
			{
				//Instantiate the business classes
				TestRunManager testRunManager = new TestRunManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();

				//Default to the authenticated user if we have no tester provided
				int testerId = userId;
				if (remoteTestRun.TesterId.HasValue)
				{
					testerId = remoteTestRun.TesterId.Value;
				}

				//Default to plain text test run formats if not set
				if (remoteTestRun.TestRunFormatId < 1)
				{
					remoteTestRun.TestRunFormatId = (int)TestRun.TestRunFormatEnum.PlainText;
				}

				//Handle nullable properties
				DateTime endDate = DateTime.UtcNow;
				string runnerTestName = "Unknown?";
				string runnerMessage = "Nothing Reported";
				string runnerStackTrace = "Nothing Reported";
				int runnerAssertCount = 0;
				if (remoteTestRun.EndDate.HasValue)
				{
					endDate = remoteTestRun.EndDate.Value;
				}
				if (!String.IsNullOrEmpty(remoteTestRun.RunnerTestName))
				{
					runnerTestName = remoteTestRun.RunnerTestName;
				}
				if (!String.IsNullOrEmpty(remoteTestRun.RunnerMessage))
				{
					runnerMessage = remoteTestRun.RunnerMessage;
				}
				if (!String.IsNullOrEmpty(remoteTestRun.RunnerStackTrace))
				{
					runnerStackTrace = remoteTestRun.RunnerStackTrace;
				}
				if (remoteTestRun.RunnerAssertCount.HasValue)
				{
					runnerAssertCount = remoteTestRun.RunnerAssertCount.Value;
				}

				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//See if we have any test steps that need to be included
				List<TestRunStepInfo> testRunSteps = null;
				if (remoteTestRun.TestRunSteps != null && remoteTestRun.TestRunSteps.Count > 0)
				{
					testRunSteps = new List<TestRunStepInfo>();
					for (int i = 0; i < remoteTestRun.TestRunSteps.Count; i++)
					{
						RemoteTestRunStep remoteTestRunStep = remoteTestRun.TestRunSteps[i];
						TestRunStepInfo testRunStep = new TestRunStepInfo();
						testRunStep.TestStepId = remoteTestRunStep.TestStepId;
						testRunStep.Description = remoteTestRunStep.Description;
						testRunStep.ExpectedResult = remoteTestRunStep.ExpectedResult;
						testRunStep.SampleData = remoteTestRunStep.SampleData;
						testRunStep.ActualResult = remoteTestRunStep.ActualResult;
						testRunStep.ExecutionStatusId = remoteTestRunStep.ExecutionStatusId;
						//Generate a position from the index if one is not provided
						if (remoteTestRunStep.Position < 1)
						{
							remoteTestRunStep.Position = i + 1;
						}
						testRunStep.Position = remoteTestRunStep.Position;
						testRunSteps.Add(testRunStep);
					}
				}

				//Actually create the new test run
				int testRunId = testRunManager.Record(
				   projectId,
				   testerId,
				   remoteTestRun.TestCaseId,
				   remoteTestRun.ReleaseId,
				   remoteTestRun.TestSetId,
				   remoteTestRun.TestSetTestCaseId,
				   remoteTestRun.StartDate,
				   endDate,
				   remoteTestRun.ExecutionStatusId,
				   remoteTestRun.RunnerName,
				   runnerTestName,
				   runnerAssertCount,
				   runnerMessage,
				   runnerStackTrace,
				   remoteTestRun.AutomationHostId,
				   remoteTestRun.AutomationEngineId,
				   remoteTestRun.BuildId,
				   (TestRun.TestRunFormatEnum)remoteTestRun.TestRunFormatId,
				   testRunSteps
				   );

				//Need to now save the custom properties if necessary
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, testRunId, DataModel.Artifact.ArtifactTypeEnum.TestRun, true);
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTestRun, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, testRunId, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}

				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Populate the API data object with the primary keys and return
				remoteTestRun.TestRunId = testRunId;
				if (remoteTestRun.TestRunSteps != null && remoteTestRun.TestRunSteps.Count > 0)
				{
					foreach (TestRunStepInfo testRunStep in testRunSteps)
					{
						RemoteTestRunStep remoteTestRunStep = remoteTestRun.TestRunSteps.FirstOrDefault(r => r.Position == testRunStep.Position);
						if (remoteTestRunStep != null)
						{
							remoteTestRunStep.TestRunStepId = testRunStep.TestRunStepId;
						}
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestRun;
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, Resources.Messages.TestCaseDetails_ArtifactNotExists);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Records the results of executing an automated test
		/// </summary>
		/// <param name="userName">The username of the user</param>
		/// <param name="password">The unhashed password of the user</param>
		/// <param name="projectId">The project to connect to</param>
		/// <param name="testerUserId">The user id of the person who's running the test (null for logged in user)</param>
		/// <param name="testCaseId">The test case being executed</param>
		/// <param name="releaseId">The release being executed against (optional)</param>
		/// <param name="testSetId">The test set being executed against (optional)</param>
		/// <param name="executionStatusId">The status of the test run (pass/fail/not run)</param>
		/// <param name="runnerName">The name of the automated testing tool</param>
		/// <param name="runnerAssertCount">The number of assertions</param>
		/// <param name="runnerMessage">The failure message (if appropriate)</param>
		/// <param name="runnerStackTrace">The error stack trace (if any)s</param>
		/// <param name="runnerTestName">The name of the test case in the external tool</param>
		/// <param name="endDate">When the test run ended</param>
		/// <param name="startDate">When the test run started</param>
		/// <param name="buildId">The id of the build that the test run should be linked to</param>
		/// <param name="testRunFormatId">The format of the runnerStackTrace (1=Plain Text, 2=HTML)</param>
		/// <param name="testSetTestCaseId">The id of the unique test case entry in the test set (if none provided, the first matching test case is used)</param>
		/// <returns>The newly created test run id</returns>
		/// <remarks>
		/// Use this version of the method for clients that cannot handle complex data objects.
		/// Unlike the TestRun_RecordAutomated1 it cannot handle custom properties
		/// </remarks>
		/// <example>
		/// int testRunId5 = spiraImportExport.TestRun_RecordAutomated2("aant", "aant", projectId1, userId2, testCaseId1, iterationId2, null, null, null, DateTime.UtcNow, DateTime.UtcNow.AddSeconds(20), Business.TestCase.ExecutionStatusFailed, "TestSuite", "02_Test_Method", 5, "Expected 1, Found 0", "Error Stack Trace........");
		/// </example>
		public int TestRun_RecordAutomated2(string userName, string password, int projectId, int? testerUserId, int testCaseId, Nullable<int> releaseId, Nullable<int> testSetId, Nullable<int> testSetTestCaseId, int? buildId, DateTime startDate, DateTime endDate, int executionStatusId, string runnerName, string runnerTestName, int runnerAssertCount, string runnerMessage, string runnerStackTrace, int testRunFormatId)
		{
			const string METHOD_NAME = "TestRun_RecordAutomated2";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a runner name was provided (needed for automated tests)
			if (String.IsNullOrEmpty(runnerName))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_RunnerNameMissing);
			}

			//Make sure we have an authenticated user
			RemoteCredentials credentials = new RemoteCredentials();
			credentials.UserName = userName;
			credentials.Password = password;
			if (!this.IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationFailure", Resources.Messages.Services_CannotConnectToProject);
			}

			//Make sure we have permissions to create test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestRuns);
			}

			try
			{
				//Instantiate the business classes
				TestRunManager testRunManager = new TestRunManager();

				//Default to the authenticated user if no tester provided
				if (!testerUserId.HasValue)
				{
					testerUserId = userId;
				}

				//Default to plain text test run formats if not set
				if (testRunFormatId < 1)
				{
					testRunFormatId = (int)TestRun.TestRunFormatEnum.PlainText;
				}

				//Actually create the new test run
				int testRunId = testRunManager.Record(
				   projectId,
				   testerUserId.Value,
				   testCaseId,
				   releaseId,
				   testSetId,
				   testSetTestCaseId,
				   startDate,
				   endDate,
				   executionStatusId,
				   runnerName,
				   runnerTestName,
				   runnerAssertCount,
				   runnerMessage,
				   runnerStackTrace,
				   null,
				   null,
				   buildId,
				   (TestRun.TestRunFormatEnum)testRunFormatId,
				   null
				   );

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return testRunId;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Records the results of executing multiple automated tests
		/// </summary>
		/// <returns>the test run data object with its primary key populated</returns>
		/// <remarks>
		/// You need to use this overload when you want to be able to execute a large batch of test runs.
		/// It's faster than TestRun_RecordAutomated1 for large numbers of test runs.
		/// *However* it does not refresh any of the other items in the project (test cases, requirements, test sets)
		/// that also have summarized forms of this data. So once you're done loading data, you *must*
		/// call the Project_RefreshProgressExecutionStatusCaches() command once.
		/// </remarks>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestRuns">The list of populated automated test runs</param>
		/// <returns>The list of test runs with the TestRunId populated</returns>
		/// <seealso cref="TestRun_RecordAutomated1"/>
		public List<RemoteAutomatedTestRun> TestRun_RecordAutomated3(RemoteCredentials credentials, int projectId, List<RemoteAutomatedTestRun> remoteTestRuns)
		{
			const string METHOD_NAME = "TestRun_RecordAutomated3";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a runner name was provided (needed for automated tests)
			foreach (RemoteAutomatedTestRun remoteTestRun in remoteTestRuns)
			{
				if (String.IsNullOrEmpty(remoteTestRun.RunnerName))
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("ArgumentMissing", Resources.Messages.Services_RunnerNameMissing);
				}
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestRuns);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Instantiate the business classes
				TestRunManager testRunManager = new TestRunManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();

				//Loop through the test runs
				foreach (RemoteAutomatedTestRun remoteTestRun in remoteTestRuns)
				{
					//Default to the authenticated user if we have no tester provided
					int testerId = userId;
					if (remoteTestRun.TesterId.HasValue)
					{
						testerId = remoteTestRun.TesterId.Value;
					}

					//Default to plain text test run formats if not set
					if (remoteTestRun.TestRunFormatId < 1)
					{
						remoteTestRun.TestRunFormatId = (int)TestRun.TestRunFormatEnum.PlainText;
					}

					//Handle nullable properties
					DateTime endDate = DateTime.UtcNow;
					string runnerTestName = "Unknown?";
					string runnerMessage = "Nothing Reported";
					string runnerStackTrace = "Nothing Reported";
					int runnerAssertCount = 0;
					if (remoteTestRun.EndDate.HasValue)
					{
						endDate = remoteTestRun.EndDate.Value;
					}
					if (!String.IsNullOrEmpty(remoteTestRun.RunnerTestName))
					{
						runnerTestName = remoteTestRun.RunnerTestName;
					}
					if (!String.IsNullOrEmpty(remoteTestRun.RunnerMessage))
					{
						runnerMessage = remoteTestRun.RunnerMessage;
					}
					if (!String.IsNullOrEmpty(remoteTestRun.RunnerStackTrace))
					{
						runnerStackTrace = remoteTestRun.RunnerStackTrace;
					}
					if (remoteTestRun.RunnerAssertCount.HasValue)
					{
						runnerAssertCount = remoteTestRun.RunnerAssertCount.Value;
					}

					//See if we have any test steps that need to be included
					List<TestRunStepInfo> testRunSteps = null;
					if (remoteTestRun.TestRunSteps != null && remoteTestRun.TestRunSteps.Count > 0)
					{
						testRunSteps = new List<TestRunStepInfo>();
						for (int i = 0; i < remoteTestRun.TestRunSteps.Count; i++)
						{
							RemoteTestRunStep remoteTestRunStep = remoteTestRun.TestRunSteps[i];
							TestRunStepInfo testRunStep = new TestRunStepInfo();
							testRunStep.TestStepId = remoteTestRunStep.TestStepId;
							testRunStep.Description = remoteTestRunStep.Description;
							testRunStep.ExpectedResult = remoteTestRunStep.ExpectedResult;
							testRunStep.SampleData = remoteTestRunStep.SampleData;
							testRunStep.ActualResult = remoteTestRunStep.ActualResult;
							testRunStep.ExecutionStatusId = remoteTestRunStep.ExecutionStatusId;
							//Generate a position from the index if one is not provided
							if (remoteTestRunStep.Position < 1)
							{
								remoteTestRunStep.Position = i + 1;
							}
							testRunStep.Position = remoteTestRunStep.Position;
							testRunSteps.Add(testRunStep);
						}
					}

					//Actually create the new test run
					//We use the option to NOT update associated test statuses for the test run
					//because we will do that at the end for ALL the test runs
					int testRunId = testRunManager.Record(
					   projectId,
					   testerId,
					   remoteTestRun.TestCaseId,
					   remoteTestRun.ReleaseId,
					   remoteTestRun.TestSetId,
					   remoteTestRun.TestSetTestCaseId,
					   remoteTestRun.StartDate,
					   endDate,
					   remoteTestRun.ExecutionStatusId,
					   remoteTestRun.RunnerName,
					   runnerTestName,
					   runnerAssertCount,
					   runnerMessage,
					   runnerStackTrace,
					   remoteTestRun.AutomationHostId,
					   remoteTestRun.AutomationEngineId,
					   remoteTestRun.BuildId,
					   (TestRun.TestRunFormatEnum)remoteTestRun.TestRunFormatId,
					   testRunSteps,
					   false
					   );

					//Need to now save the custom properties if necessary
					ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, testRunId, DataModel.Artifact.ArtifactTypeEnum.TestRun, true);
					Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTestRun, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, testRunId, projectTemplateId);
					if (validationMessages != null && validationMessages.Count > 0)
					{
						//Throw a validation exception
						throw CreateValidationException(validationMessages);
					}

					customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

					//Populate the API data object with the primary key and return
					remoteTestRun.TestRunId = testRunId;
					if (remoteTestRun.TestRunSteps != null && remoteTestRun.TestRunSteps.Count > 0)
					{
						foreach (TestRunStepInfo testRunStep in testRunSteps)
						{
							RemoteTestRunStep remoteTestRunStep = remoteTestRun.TestRunSteps.FirstOrDefault(r => r.Position == testRunStep.Position);
							if (remoteTestRunStep != null)
							{
								remoteTestRunStep.TestRunStepId = testRunStep.TestRunStepId;
							}
						}
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestRuns;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Saves set of test runs, each containing test run steps
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestRuns">The test run objects to persist</param>
		/// <param name="endDate">The effective end-date of the test run (leave null to use the values specified on each test run object)</param>
		/// <returns>The saved copy of the test run objects (contains generated IDs)</returns>
		/// <example>
		/// a) RemoteManualTestRun[] remoteTestRuns = spiraImportExport.TestRun_Save(remoteTestRuns, DateTime.UtcNow);
		/// b) RemoteManualTestRun[] remoteTestRuns = spiraImportExport.TestRun_Save(remoteTestRuns, null);
		/// </example>
		public List<RemoteManualTestRun> TestRun_Save(RemoteCredentials credentials, int projectId, List<RemoteManualTestRun> remoteTestRuns, DateTime? endDate)
		{
			const string METHOD_NAME = "TestRun_Save";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test runs
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestRuns);
			}

			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				//Instantiate the test run business class and dataset
				TestRunManager testRunManager = new TestRunManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				TestRunsPending testRunsPending = new TestRunsPending();
				List<RemoteManualTestRun> updatedRemoteTestRuns = new List<RemoteManualTestRun>();

				//First populate the pending run
				UpdateFunctions.UpdatePendingTestRun(testRunsPending, remoteTestRuns, projectId, userId);

				//Loop through the test runs
				for (int i = 0; i < remoteTestRuns.Count; i++)
				{
					RemoteManualTestRun remoteTestRun = remoteTestRuns[i];
					//Make sure the test run has a tester set, if not, use the authenticated user
					if (!remoteTestRun.TesterId.HasValue)
					{
						remoteTestRun.TesterId = userId;
					}

					//Populate the dataset from the test run object
					UpdateFunctions.UpdateManualTestRunData(testRunsPending, remoteTestRun);

					//Update the status of the test run
					testRunManager.UpdateExecutionStatus(projectId, userId, testRunsPending, i, endDate, false);
				}

				//Actually save the test run and get the primary keys
				testRunManager.Save(testRunsPending, projectId, false);
				int testRunsPendingId = testRunsPending.TestRunsPendingId;
				for (int i = 0; i < remoteTestRuns.Count; i++)
				{
					RemoteManualTestRun remoteTestRun = remoteTestRuns[i];
					remoteTestRun.TestRunId = testRunsPending.TestRuns[i].TestRunId;

					//Need to now save the custom properties if necessary
					ArtifactCustomProperty artifactCustomProperty = null;
					Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTestRun, projectId, DataModel.Artifact.ArtifactTypeEnum.TestRun, remoteTestRun.TestRunId.Value, projectTemplateId);
					if (validationMessages != null && validationMessages.Count > 0)
					{
						//Throw a validation exception
						throw CreateValidationException(validationMessages);
					}

					customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

					//Finally we need to return the fully populated test run (after saving), it's easiest just to
					//regenerate from the test run dataset
					RemoteManualTestRun updatedRemoteTestRun = new RemoteManualTestRun();
					PopulationFunctions.PopulateManualTestRun(updatedRemoteTestRun, testRunsPending.TestRuns[i], projectId);
					updatedRemoteTestRuns.Add(updatedRemoteTestRun);
				}

				//Also need to complete the pending run so that it is no longer displayed
				testRunManager.CompletePending(testRunsPendingId, userId);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return updatedRemoteTestRuns;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		#endregion Test Run Methods

		#region Test Set Methods

		/// <summary>
		/// Retrieves a list of test parameter values specified by a specific test set
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="testSetId">The id of the test set</param>
		/// <returns>The list of parameter values</returns>
		/// <remarks>Does not include any parameters set at the test set test case level</remarks>
		public List<RemoteTestSetParameter> TestSet_RetrieveParameters(RemoteCredentials credentials, int projectId, int testSetId)
		{
			const string METHOD_NAME = "TestSet_RetrieveTestCaseParameters";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test set test set test case parameters
			TestSetManager testSetManager = new TestSetManager();

			try
			{
				//First retrieve the test set and verify it belongs to the current project (for security reasons)
				//and that the test step is inside the specified test case (for security reasons)
				TestSetView testSet = testSetManager.RetrieveById(projectId, testSetId);
				if (testSet.ProjectId != projectId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Next actually retrieve the parameters
				List<TestSetParameter> testSetParameterValues = testSetManager.RetrieveParameterValues(testSetId);

				//Loop through the dataset and populate the API object
				List<RemoteTestSetParameter> remoteTestSetParameters = new List<RemoteTestSetParameter>();
				foreach (TestSetParameter testSetParameter in testSetParameterValues)
				{
					RemoteTestSetParameter remoteTestSetParameter = new RemoteTestSetParameter();
					remoteTestSetParameter.TestCaseParameterId = testSetParameter.TestCaseParameterId;
					remoteTestSetParameter.TestSetId = testSetParameter.TestSetId;
					remoteTestSetParameter.Name = testSetParameter.Name;
					remoteTestSetParameter.Value = testSetParameter.Value;
					remoteTestSetParameters.Add(remoteTestSetParameter);
				}

				return remoteTestSetParameters;
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Adds a new test parameter specified by a specific test set's test case (the paramater is only added if it is not already set)
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="testSetId">The id of the test set</param>
		public void TestSet_AddTestCaseParameter(RemoteCredentials credentials, int projectId, int testSetId, RemoteTestSetTestCaseParameter remoteTestSetTestCaseParameter)
		{
			const string METHOD_NAME = "TestSet_AddTestCaseParameter";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test set test set test case parameters
			TestSetManager testSetManager = new TestSetManager();

			try
			{
				//First retrieve the test set and verify it belongs to the current project (for security reasons)
				//and that the test step is inside the specified test case (for security reasons)
				TestSetView testSet = testSetManager.RetrieveById(projectId, testSetId);
				if (testSet.ProjectId != projectId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Next get the test set test cases and verify ours exists and belongs to the test set
				TestSetTestCaseView testSetTestCase = testSetManager.RetrieveTestCaseById2(remoteTestSetTestCaseParameter.TestSetTestCaseId);
				if (testSetTestCase.TestSetId != testSetId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Next retrieve the current parameters for the test set test case
				List<TestSetTestCaseParameter> testSetTestCaseParameters = testSetManager.RetrieveTestCaseParameterValues(remoteTestSetTestCaseParameter.TestSetTestCaseId);

				//Verify that the parameter specified does not yet exist for this test set test case (required for this call because we are adding, not updating)
				TestSetTestCaseParameter requestedParameter = testSetTestCaseParameters.FirstOrDefault(p => p.TestCaseParameterId == remoteTestSetTestCaseParameter.TestCaseParameterId);
				if (requestedParameter != null)
				{
					throw CreateFault("ArgumentMissing", Resources.Messages.Services_TestSetTestCaseParameterInTestCase);
				}

				//If we do not have any parameters for the test set test case reset the list (otherwise we use the param list as is)
				if (testSetTestCaseParameters.Count == 0 || testSetTestCaseParameters == null)
				{
					testSetTestCaseParameters = new List<TestSetTestCaseParameter>();
				}
				//Create a new parameter and set the information from the remote object
				requestedParameter = new TestSetTestCaseParameter();
				requestedParameter.TestSetTestCaseId = remoteTestSetTestCaseParameter.TestSetTestCaseId;
				requestedParameter.TestCaseParameterId = remoteTestSetTestCaseParameter.TestCaseParameterId;
				requestedParameter.Value = remoteTestSetTestCaseParameter.Value;
				testSetTestCaseParameters.Add(requestedParameter);

				//Finally, update the parameters
				testSetManager.SaveTestCaseParameterValues(testSetTestCaseParameters);
				return;
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates an existing test parameter specified by a specific test set's test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="testSetId">The id of the test set</param>
		public void TestSet_UpdateTestCaseParameter(RemoteCredentials credentials, int projectId, int testSetId, RemoteTestSetTestCaseParameter remoteTestSetTestCaseParameter)
		{
			const string METHOD_NAME = "TestSet_UpdateTestCaseParameter";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test set test set test case parameters
			TestSetManager testSetManager = new TestSetManager();

			try
			{
				//First retrieve the test set and verify it belongs to the current project (for security reasons)
				//and that the test step is inside the specified test case (for security reasons)
				TestSetView testSet = testSetManager.RetrieveById(projectId, testSetId);
				if (testSet.ProjectId != projectId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Next get the test set test cases and verify ours exists and belongs to the test set
				TestSetTestCaseView testSetTestCase = testSetManager.RetrieveTestCaseById2(remoteTestSetTestCaseParameter.TestSetTestCaseId);
				if (testSetTestCase.TestSetId != testSetId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Next retrieve the current parameters for the test set test case
				List<TestSetTestCaseParameter> testSetTestCaseParameters = testSetManager.RetrieveTestCaseParameterValues(remoteTestSetTestCaseParameter.TestSetTestCaseId);

				//Verify that the parameter specified exists for this test set test case
				TestSetTestCaseParameter requestedParameter = testSetTestCaseParameters.FirstOrDefault(p => p.TestCaseParameterId == remoteTestSetTestCaseParameter.TestCaseParameterId);
				if (requestedParameter == null)
				{
					throw CreateFault("ArgumentMissing", Resources.Messages.Services_TestSetTestCaseParameterNotInTestCase);
				}

				//Update the parameter object
				requestedParameter.Value = remoteTestSetTestCaseParameter.Value;

				//Finally, update the parameters
				testSetManager.SaveTestCaseParameterValues(testSetTestCaseParameters);
				return;
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes an existing test parameter specified by a specific test set's test case
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="testSetId">The id of the test set</param>
		public void TestSet_DeleteTestCaseParameter(RemoteCredentials credentials, int projectId, int testSetId, RemoteTestSetTestCaseParameter remoteTestSetTestCaseParameter)
		{
			const string METHOD_NAME = "TestSet_DeleteTestCaseParameter";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test set test set test case parameters
			TestSetManager testSetManager = new TestSetManager();

			try
			{
				//First retrieve the test set and verify it belongs to the current project (for security reasons)
				//and that the test step is inside the specified test case (for security reasons)
				TestSetView testSet = testSetManager.RetrieveById(projectId, testSetId);
				if (testSet.ProjectId != projectId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Next get the test set test cases and verify ours exists and belongs to the test set
				TestSetTestCaseView testSetTestCase = testSetManager.RetrieveTestCaseById2(remoteTestSetTestCaseParameter.TestSetTestCaseId);
				if (testSetTestCase.TestSetId != testSetId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Next retrieve the current parameters for the test set test case
				List<TestSetTestCaseParameter> testSetTestCaseParameters = testSetManager.RetrieveTestCaseParameterValues(remoteTestSetTestCaseParameter.TestSetTestCaseId);

				//Verify that the parameter specified exists for this test set test case
				TestSetTestCaseParameter requestedParameter = testSetTestCaseParameters.FirstOrDefault(p => p.TestCaseParameterId == remoteTestSetTestCaseParameter.TestCaseParameterId);
				if (requestedParameter == null)
				{
					throw CreateFault("ArgumentMissing", Resources.Messages.Services_TestSetTestCaseParameterNotInTestCase);
				}

				//Remove the parameter from the list
				testSetTestCaseParameters.Remove(requestedParameter);

				//Finally, update the parameters
				//Check to see if we are removing all/the last value remaining - they are handled differently
				if (testSetTestCaseParameters.Count == 0)
				{
					testSetManager.RemoveTestCaseParameterValues(remoteTestSetTestCaseParameter.TestSetTestCaseId);
				}
				else
				{
					testSetManager.SaveTestCaseParameterValues(testSetTestCaseParameters);
				}
				return;
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Adds a new parameter for a test set
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="remoteTestSetParameter">The new test set parameter to add</param>
		public void TestSet_AddParameter(RemoteCredentials credentials, int projectId, RemoteTestSetParameter remoteTestSetParameter)
		{
			const string METHOD_NAME = "TestSet_AddParameter";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to modify test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			try
			{
				//Instantiate the test case business class
				TestSetManager testSetManager = new TestSetManager();

				//Now insert the test set parameter
				testSetManager.AddTestSetParameter(
				   remoteTestSetParameter.TestSetId,
				   remoteTestSetParameter.TestCaseParameterId,
				   remoteTestSetParameter.Value
				   );

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Updates an existing parameter for a test set
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="remoteTestSetParameter">The test set parameter to update</param>
		public void TestSet_UpdateParameter(RemoteCredentials credentials, int projectId, RemoteTestSetParameter remoteTestSetParameter)
		{
			const string METHOD_NAME = "TestSet_UpdateParameter";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to modify test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Must pass in a testcaseparameter id and testset id
			if (remoteTestSetParameter.TestCaseParameterId <= 0 || remoteTestSetParameter.TestCaseParameterId <= 0)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TestSetParameterUpdateFields);
			}

			//First retrieve the existing datarow
			try
			{
				//Instantiate the test set business class
				TestSetManager testSetManager = new TestSetManager();
				List<TestSetParameter> testSetParameters = testSetManager.RetrieveParameterValues(remoteTestSetParameter.TestSetId);

				//Find the specific parameter by ID
				TestSetParameter testSetParameter = testSetParameters.FirstOrDefault(p => p.TestCaseParameterId == remoteTestSetParameter.TestCaseParameterId);

				//Make sure the parameter is part of the test case
				if (testSetParameter == null)
				{
					throw CreateFault("TestCaseParameterNotInTestSet", Resources.Messages.Services_TestCaseParameterNotInTestSet);
				}

				//Make sure that the project ids match
				TestSet testSet = testSetManager.RetrieveById2(projectId, testSetParameter.TestSetId);
				if (testSet.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Now update the test case parameter
				testSetManager.UpdateTestSetParameter(testSetParameter.TestSetId,
					remoteTestSetParameter.TestCaseParameterId,
					remoteTestSetParameter.Value
				);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Deletes an existing parameter for a test set
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="remoteTestCaseParameter">The test set parameter to deleted</param>
		public void TestSet_DeleteParameter(RemoteCredentials credentials, int projectId, RemoteTestSetParameter remoteTestSetParameter)
		{
			const string METHOD_NAME = "TestSet_DeleteParameter";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to modify test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Must pass in a testcaseparameter id and testset id
			if (remoteTestSetParameter.TestCaseParameterId <= 0 || remoteTestSetParameter.TestCaseParameterId <= 0)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TestSetParameterUpdateFields);
			}

			//First retrieve the existing datarow
			try
			{
				//Instantiate the test set business class
				TestSetManager testSetManager = new TestSetManager();
				List<TestSetParameter> testSetParameters = testSetManager.RetrieveParameterValues(remoteTestSetParameter.TestSetId);

				//Find the specific parameter by ID
				TestSetParameter testSetParameter = testSetParameters.FirstOrDefault(p => p.TestCaseParameterId == remoteTestSetParameter.TestCaseParameterId);

				//Make sure the parameter is part of the test case
				if (testSetParameter == null)
				{
					throw CreateFault("TestCaseParameterNotInTestSet", Resources.Messages.Services_TestCaseParameterNotInTestSet);
				}

				//Make sure that the project ids match
				TestSet testSet = testSetManager.RetrieveById2(projectId, testSetParameter.TestSetId);
				if (testSet.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Now update the test case parameter
				testSetManager.DeleteTestSetParameter(testSetParameter.TestSetId, remoteTestSetParameter.TestCaseParameterId);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Retrieves a list of test parameter values specified by a specific test set's test case instance
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testSetTestCaseId">The id of the testSetTestCase instance</param>
		/// <param name="testSetId">The id of the test set</param>
		/// <returns>The list of parameter values</returns>
		public List<RemoteTestSetTestCaseParameter> TestSet_RetrieveTestCaseParameters(RemoteCredentials credentials, int projectId, int testSetId, int testSetTestCaseId)
		{
			const string METHOD_NAME = "TestSet_RetrieveTestCaseParameters";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test set test set test case parameters
			TestSetManager testSetManager = new TestSetManager();

			try
			{
				//First retrieve the test set and verify it belongs to the current project (for security reasons)
				//and that the test step is inside the specified test case (for security reasons)
				TestSetView testSet = testSetManager.RetrieveById(projectId, testSetId);
				if (testSet.ProjectId != projectId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Next get the test set test cases and verify ours exists and belongs to the test set
				TestSetTestCaseView testSetTestCase = testSetManager.RetrieveTestCaseById2(testSetTestCaseId);
				if (testSetTestCase.TestSetId != testSetId)
				{
					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
				}

				//Next actually retrieve the parameters
				List<TestSetTestCaseParameter> testSetParameterValues = testSetManager.RetrieveTestCaseParameterValues(testSetTestCaseId);

				//Loop through the dataset and populate the API object
				List<RemoteTestSetTestCaseParameter> remoteTestSetParameters = new List<RemoteTestSetTestCaseParameter>();
				foreach (TestSetTestCaseParameter testSetParameter in testSetParameterValues)
				{
					RemoteTestSetTestCaseParameter remoteTestSetParameter = new RemoteTestSetTestCaseParameter();
					remoteTestSetParameter.TestCaseParameterId = testSetParameter.TestCaseParameterId;
					remoteTestSetParameter.TestSetTestCaseId = testSetParameter.TestSetTestCaseId;
					remoteTestSetParameter.Name = testSetParameter.Name;
					remoteTestSetParameter.Value = testSetParameter.Value;
					remoteTestSetParameters.Add(remoteTestSetParameter);
				}

				return remoteTestSetParameters;
			}
			catch (ArtifactNotExistsException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Creates a new test set folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestSetFolder">The new test set folder object (primary key will be empty)</param>
		/// <returns>The populated test set object - including the primary key</returns>
		public RemoteTestSetFolder TestSet_CreateFolder(RemoteCredentials credentials, RemoteTestSetFolder remoteTestSetFolder)
		{
			const string METHOD_NAME = "TestSet_CreateFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a test set folder id specified
			if (remoteTestSetFolder.TestSetFolderId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TestSetIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestSetFolder.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestFolders);
			}

			//Always use the current project
			remoteTestSetFolder.ProjectId = projectId;

			//Instantiate the test set business class
			TestSetManager testSetManager = new TestSetManager();

			//Now insert the test folder under the specified parent folder
			remoteTestSetFolder.TestSetFolderId = testSetManager.TestSetFolder_Create(
				remoteTestSetFolder.Name,
				remoteTestSetFolder.ProjectId,
				remoteTestSetFolder.Description,
				remoteTestSetFolder.ParentTestSetFolderId
				).TestSetFolderId;

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTestSetFolder;
		}

		/// <summary>
		/// Creates a new test set in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestSet">The new test set object (primary key will be empty)</param>
		/// <returns>The populated test set object - including the primary key</returns>
		public RemoteTestSet TestSet_Create(RemoteCredentials credentials, RemoteTestSet remoteTestSet)
		{
			const string METHOD_NAME = "TestSet_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a test set id specified
			if (remoteTestSet.TestSetId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TestSetIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestSet.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestSets);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Default to the authenticated user if we have no creator provided
			int creatorId = userId;
			if (remoteTestSet.CreatorId.HasValue)
			{
				creatorId = remoteTestSet.CreatorId.Value;
			}
			//Always use the current project
			remoteTestSet.ProjectId = projectId;

			//Instantiate the test set business class
			TestSetManager testSetManager = new TestSetManager();

			//Now insert the test set under the specified folder
			remoteTestSet.TestSetId = testSetManager.Insert(
				userId,
				projectId,
				remoteTestSet.TestSetFolderId,
				remoteTestSet.ReleaseId,
				creatorId,
				remoteTestSet.OwnerId,
				(TestSet.TestSetStatusEnum)remoteTestSet.TestSetStatusId,
				remoteTestSet.Name,
				remoteTestSet.Description,
				remoteTestSet.PlannedDate,
				(TestRun.TestRunTypeEnum)remoteTestSet.TestRunTypeId,
				remoteTestSet.AutomationHostId,
				(remoteTestSet.RecurrenceId.HasValue) ? (TestSet.RecurrenceEnum?)remoteTestSet.RecurrenceId : null,
				remoteTestSet.IsAutoScheduled,
				remoteTestSet.IsDynamic,
				remoteTestSet.BuildExecuteTimeInterval,
				remoteTestSet.DynamicQuery,
				remoteTestSet.TestConfigurationSetId
				);

			//Now we need to populate any custom properties
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();
			ArtifactCustomProperty artifactCustomProperty = null;
			Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTestSet, remoteTestSet.ProjectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, remoteTestSet.TestSetId.Value, projectTemplateId);
			if (validationMessages != null && validationMessages.Count > 0)
			{
				//Throw a validation exception
				throw CreateValidationException(validationMessages);
			}
			customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

			//Send a notification
			testSetManager.SendCreationNotification(remoteTestSet.TestSetId.Value, artifactCustomProperty, null);

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTestSet;
		}

		/// <summary>
		/// Retrieves a single test set/folder in the system
		/// </summary>
		/// <param name="testSetId">The id of the test set</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>Test Set object</returns>
		public RemoteTestSet TestSet_RetrieveById(RemoteCredentials credentials, int projectId, int testSetId)
		{
			const string METHOD_NAME = "TestSet_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test set dataset
			TestSetManager testSetManager = new TestSetManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the test set was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				TestSetView testSet = testSetManager.RetrieveById(projectId, testSetId, false);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, testSetId, DataModel.Artifact.ArtifactTypeEnum.TestSet, true);

				//Make sure that the project ids match
				if (testSet.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteTestSet remoteTestSet = new RemoteTestSet();
				PopulationFunctions.PopulateTestSet(remoteTestSet, testSet);
				if (artifactCustomProperty != null)
				{
					PopulationFunctions.PopulateCustomProperties(remoteTestSet, artifactCustomProperty);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestSet;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test set");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Retrieves a single test folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testSetFolderId">The id of the test folder</param>
		/// <returns>Test Case Folder object</returns>
		public RemoteTestSetFolder TestSet_RetrieveFolderById(RemoteCredentials credentials, int projectId, int testSetFolderId)
		{
			const string METHOD_NAME = "TestSet_RetrieveFolderById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test set dataset
			TestSetManager testSetManager = new TestSetManager();

			//If the test set folder was not found, just return null
			try
			{
				TestSetFolder testSetFolder = testSetManager.TestSetFolder_GetById(testSetFolderId);
				if (testSetFolder == null)
				{
					return null;
				}

				//Make sure that the project ids match
				if (testSetFolder.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteTestSetFolder remoteTestSetFolder = new RemoteTestSetFolder();
				PopulationFunctions.PopulateTestSetFolder(remoteTestSetFolder, testSetFolder);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestSetFolder;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves all of the test set folders in the project with their hierarchy
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>List of test set folders</returns>
		public List<RemoteTestSetFolder> TestSet_RetrieveFolders(RemoteCredentials credentials, int projectId)
		{
			const string METHOD_NAME = "TestSet_RetrieveFolders";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test set dataset
			TestSetManager testSetManager = new TestSetManager();

			//If the test set folder was not found, just return null
			try
			{
				List<RemoteTestSetFolder> remoteTestSetFolders = new List<RemoteTestSetFolder>();

				List<TestSetFolderHierarchyView> testSetFolders = testSetManager.TestSetFolder_GetList(projectId);

				foreach (TestSetFolderHierarchyView testSetFolder in testSetFolders)
				{
					//Populate the API data objects and return
					RemoteTestSetFolder remoteTestSetFolder = new RemoteTestSetFolder();
					PopulationFunctions.PopulateTestSetFolder(remoteTestSetFolder, testSetFolder);
					remoteTestSetFolders.Add(remoteTestSetFolder);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestSetFolders;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of folders by the parent folder
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="parentTestSetFolderId">The id of the parent folder, or null = root</param>
		/// <param name="releaseId">The id of the current release, or null = all releases</param>
		/// <returns>The list of folders</returns>
		public List<RemoteTestSetFolder> TestSet_RetrieveFoldersByParent(RemoteCredentials credentials, int projectId, int? parentTestSetFolderId, int? releaseId)
		{
			const string METHOD_NAME = "TestSet_RetrieveFoldersByParent";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test set dataset
			TestSetManager testSetManager = new TestSetManager();

			//If the test set folder was not found, just return null
			try
			{
				List<RemoteTestSetFolder> remoteTestSetFolders = new List<RemoteTestSetFolder>();

				//See if we have a release specified
				if (releaseId.HasValue)
				{
					List<TestSetFolderReleaseView> testSetFolders = testSetManager.TestSetFolder_GetByParentIdForRelease(projectId, parentTestSetFolderId, releaseId.Value);

					foreach (TestSetFolderReleaseView testSetFolder in testSetFolders)
					{
						//Populate the API data objects and return
						RemoteTestSetFolder remoteTestSetFolder = new RemoteTestSetFolder();
						PopulationFunctions.PopulateTestSetFolder(remoteTestSetFolder, testSetFolder);
						remoteTestSetFolders.Add(remoteTestSetFolder);
					}
				}
				else
				{
					List<TestSetFolder> testSetFolders = testSetManager.TestSetFolder_GetByParentId(projectId, parentTestSetFolderId);

					foreach (TestSetFolder testSetFolder in testSetFolders)
					{
						//Populate the API data objects and return
						RemoteTestSetFolder remoteTestSetFolder = new RemoteTestSetFolder();
						PopulationFunctions.PopulateTestSetFolder(remoteTestSetFolder, testSetFolder);
						remoteTestSetFolders.Add(remoteTestSetFolder);
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestSetFolders;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates a test set in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestSet">The updated test set object</param>
		public void TestSet_Update(RemoteCredentials credentials, RemoteTestSet remoteTestSet)
		{
			const string METHOD_NAME = "TestSet_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have a testSet id specified
			if (!remoteTestSet.TestSetId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_TestSetIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestSet.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestSets);
			}

			//First retrieve the existing datarow
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				TestSetManager testSetManager = new TestSetManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();

				TestSet testSet = testSetManager.RetrieveById2(projectId, remoteTestSet.TestSetId.Value);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteTestSet.TestSetId.Value, DataModel.Artifact.ArtifactTypeEnum.TestSet, true);

				//Make sure that the project ids match
				if (testSet.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
				UpdateFunctions.UpdateTestSetData(testSet, remoteTestSet);
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTestSet, remoteTestSet.ProjectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, remoteTestSet.TestSetId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}

				//Get copies of everything..
				Artifact notificationArt = testSet.Clone();
				ArtifactCustomProperty notificationCust = artifactCustomProperty.Clone();

				//Call the business object to actually update the testSet dataset and the custom properties
				testSetManager.Update(testSet, userId);
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Call notifications..
				try
				{
					new NotificationManager().SendNotificationForArtifact(notificationArt, notificationCust, null);
				}
				catch (Exception ex)
				{
					Logger.LogErrorEvent(METHOD_NAME, ex, "Sending message for " + notificationArt.ArtifactToken);
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test set");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Updates a test folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestSetFolder">The updated test set folder object</param>
		public void TestSet_UpdateFolder(RemoteCredentials credentials, RemoteTestSetFolder remoteTestSetFolder)
		{
			const string METHOD_NAME = "TestSet_UpdateFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have a testSet folder id specified
			if (!remoteTestSetFolder.TestSetFolderId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_TestSetIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTestSetFolder.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestSets);
			}

			//First retrieve the existing datarow
			try
			{
				TestSetManager testSetManager = new TestSetManager();

				TestSetFolder testSetFolder = testSetManager.TestSetFolder_GetById(remoteTestSetFolder.TestSetFolderId.Value);
				if (testSetFolder != null)
				{
					//Make sure that the project ids match
					if (testSetFolder.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}

					//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
					//First the test set report
					UpdateFunctions.UpdateTestSetFolderData(testSetFolder, remoteTestSetFolder);

					//Call the business object to actually update the test folder dataset
					testSetManager.TestSetFolder_Update(testSetFolder);
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes a test set / folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testSetId">The id of the test set / folder</param>
		public void TestSet_Delete(RemoteCredentials credentials, int projectId, int testSetId)
		{
			const string METHOD_NAME = "TestSet_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				TestSetManager testSetManager = new TestSetManager();
				TestSetView testSet = testSetManager.RetrieveById(projectId, testSetId);

				//Make sure that the project ids match
				if (testSet.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually mark the item as deleted
				testSetManager.MarkAsDeleted(userId, projectId, testSetId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test set");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Deletes a test set folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testSetFolderId">The id of the test set</param>
		public void TestSet_DeleteFolder(RemoteCredentials credentials, int projectId, int testSetFolderId)
		{
			const string METHOD_NAME = "TestSet_DeleteFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				TestSetManager testSetManager = new TestSetManager();
				TestSetFolder testSetFolder = testSetManager.TestSetFolder_GetById(testSetFolderId);
				if (testSetFolder != null)
				{
					//Make sure that the project ids match
					if (testSetFolder.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}

					//Call the business object to actually delete the folder
					testSetManager.TestSetFolder_Delete(projectId, testSetFolderId, userId);
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>Returns the number of test sets that match the filter.</summary>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="releaseId">The id of the release, null = All Releases</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The number of items.</returns>
		public long TestSet_Count(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, int? releaseId)
		{
			const string METHOD_NAME = CLASS_NAME + "TestSet_Count";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the test set count
			long retNum;
			if (releaseId.HasValue)
			{
				retNum = new TestSetManager().CountByRelease(projectId, releaseId.Value, filters, 0, null, false, true);
			}
			else
			{
				retNum = new TestSetManager().Count(projectId, filters, 0, null, false, true);
			}

			Logger.LogExitingEvent(METHOD_NAME);
			return retNum;
		}

		/// <summary>Gives a count of items within the given folder that match the filters.</summary>
		/// <param name="remoteFilters">Filters for the child items.</param>
		/// <param name="testSetFolderId">The TestSet folder to count in. (null = root folder)</param>
		/// <param name="releaseId">The id of the release, null = All Releases</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>A number of all items (folder objects and test sets) in the given parent folder ID.</returns>
		public long TestSet_CountForFolder(RemoteCredentials credentials, int projectId, int? testSetFolderId, List<RemoteFilter> remoteFilters, int? releaseId)
		{
			const string METHOD_NAME = CLASS_NAME + "TestSet_CountForFolder";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the test set dataset
			long retNum;
			if (releaseId.HasValue)
			{
				retNum = new TestSetManager().CountByRelease(projectId, releaseId.Value, filters, 0, testSetFolderId);
			}
			else
			{
				retNum = new TestSetManager().Count(projectId, filters, 0, testSetFolderId);
			}

			Logger.LogExitingEvent(METHOD_NAME);
			return retNum;
		}

		/// <summary>
		/// Retrieves a list of testSets in the project (all folders) that match the provided filter
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="releaseId">The id of the release, null = all releases</param>
		/// <param name="remoteSort">The sort to use</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of testSets</returns>
		public List<RemoteTestSet> TestSet_Retrieve(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows, int? releaseId)
		{
			const string METHOD_NAME = "TestSet_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view testSets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the testSet dataset
			TestSetManager testSetManager = new TestSetManager();

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestSet, false);

			//See if we have a release specified or not
			List<RemoteTestSet> remoteTestSets = new List<RemoteTestSet>();
			if (releaseId.HasValue)
			{
				List<TestSetReleaseView> testSets = testSetManager.RetrieveByReleaseId(projectId, releaseId.Value, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0, TestSetManager.TEST_SET_FOLDER_ID_ALL_TEST_SETS);

				//Populate the API data object and return
				foreach (TestSetReleaseView testSet in testSets)
				{
					//Create and populate the row
					RemoteTestSet remoteTestSet = new RemoteTestSet();
					PopulationFunctions.PopulateTestSet(remoteTestSet, testSet);
					PopulationFunctions.PopulateCustomProperties(remoteTestSet, testSet, customProperties);
					remoteTestSets.Add(remoteTestSet);
				}
			}
			else
			{
				List<TestSetView> testSets = testSetManager.Retrieve(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0, TestSetManager.TEST_SET_FOLDER_ID_ALL_TEST_SETS);

				//Populate the API data object and return
				foreach (TestSetView testSet in testSets)
				{
					//Create and populate the row
					RemoteTestSet remoteTestSet = new RemoteTestSet();
					PopulationFunctions.PopulateTestSet(remoteTestSet, testSet);
					PopulationFunctions.PopulateCustomProperties(remoteTestSet, testSet, customProperties);
					remoteTestSets.Add(remoteTestSet);
				}
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTestSets;
		}

		/// <summary>
		/// Retrieves a list of testSets in the project (all folders) that match the provided filter
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="releaseId">The id of the release, null = all releases</param>
		/// <param name="remoteSort">The sort to use</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <param name="testSetFolderId">The id of the folder, null = root</param>
		/// <returns>List of testSets</returns>
		public List<RemoteTestSet> TestSet_RetrieveByFolder(RemoteCredentials credentials, int projectId, int? testSetFolderId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows, int? releaseId)
		{
			const string METHOD_NAME = "TestSet_RetrieveByFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view testSets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the testSet dataset
			TestSetManager testSetManager = new TestSetManager();

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.TestSet, false);

			//See if we have a release specified or not
			List<RemoteTestSet> remoteTestSets = new List<RemoteTestSet>();
			if (releaseId.HasValue)
			{
				List<TestSetReleaseView> testSets = testSetManager.RetrieveByReleaseId(projectId, releaseId.Value, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0, testSetFolderId);

				//Populate the API data object and return
				foreach (TestSetReleaseView testSet in testSets)
				{
					//Create and populate the row
					RemoteTestSet remoteTestSet = new RemoteTestSet();
					PopulationFunctions.PopulateTestSet(remoteTestSet, testSet);
					PopulationFunctions.PopulateCustomProperties(remoteTestSet, testSet, customProperties);
					remoteTestSets.Add(remoteTestSet);
				}
			}
			else
			{
				List<TestSetView> testSets = testSetManager.Retrieve(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0, testSetFolderId);

				//Populate the API data object and return
				foreach (TestSetView testSet in testSets)
				{
					//Create and populate the row
					RemoteTestSet remoteTestSet = new RemoteTestSet();
					PopulationFunctions.PopulateTestSet(remoteTestSet, testSet);
					PopulationFunctions.PopulateCustomProperties(remoteTestSet, testSet, customProperties);
					remoteTestSets.Add(remoteTestSet);
				}
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTestSets;
		}

		/// <summary>
		/// Retrieves all testSets owned by the currently authenticated user
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>List of testSets</returns>
		public List<RemoteTestSet> TestSet_RetrieveForOwner(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "TestSet_RetrieveForOwner";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//We assume if they are specified as owner, they have permissions since we can't easily
			//check cross-project permissions in one query
			try
			{
				//Call the business object to actually retrieve the testSet dataset
				TestSetManager testSetManager = new TestSetManager();
				List<TestSetView> testSets = testSetManager.RetrieveByOwnerId(userId, null);

				//Get the custom property definitions - for all projects
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(Artifact.ArtifactTypeEnum.TestSet);

				//Populate the API data object and return
				List<RemoteTestSet> remoteTestSets = new List<RemoteTestSet>();
				foreach (TestSetView testSet in testSets)
				{
					//Create and populate the row
					RemoteTestSet remoteTestSet = new RemoteTestSet();
					PopulationFunctions.PopulateTestSet(remoteTestSet, testSet);
					PopulationFunctions.PopulateCustomProperties(remoteTestSet, testSet, customProperties);
					remoteTestSets.Add(remoteTestSet);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestSets;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Moves a test set to another location in the hierarchy
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testSetId">The id of the test set we want to move</param>
		/// <param name="destinationTestSetFolderId">The id of the test set folder it's to be inserted inside (or null to be at the root)</param>
		public void TestSet_Move(RemoteCredentials credentials, int projectId, int testSetId, int? destinationTestSetFolderId)
		{
			const string METHOD_NAME = "TestSet_Move";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestSets);
			}

			//First retrieve the test sets to make sure they exists and are in the authorized project
			try
			{
				TestSetManager testSetManager = new TestSetManager();
				TestSetView sourceTestSet = testSetManager.RetrieveById(projectId, testSetId);

				//Make sure that the project ids match
				if (sourceTestSet.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}
				if (destinationTestSetFolderId.HasValue)
				{
					TestSetFolder destTestSetFolder = testSetManager.TestSetFolder_GetById(destinationTestSetFolderId.Value);
					if (destTestSetFolder == null)
					{
						throw new ArtifactNotExistsException();
					}
					if (destTestSetFolder.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}
				}

				//Call the business object to actually perform the move
				testSetManager.TestSet_UpdateFolder(testSetId, destinationTestSetFolderId);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test set");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Retrieves all the test cases that are part of a test set
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testSetId">The id of the test set</param>
		/// <returns>List of Test Set, Test Case mapping objects</returns>
		public List<RemoteTestSetTestCaseMapping> TestSet_RetrieveTestCaseMapping(RemoteCredentials credentials, int projectId, int testSetId)
		{
			const string METHOD_NAME = "TestSet_RetrieveTestCaseMapping";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestCases);
			}

			//Call the business object to actually retrieve the test set test case dataset
			TestSetManager testSetManager = new TestSetManager();

			//If the test case was not found, just return null
			try
			{
				List<TestSetTestCaseView> testSetTestCases = testSetManager.RetrieveTestCases(testSetId);

				//Populate the API data object and return
				List<RemoteTestSetTestCaseMapping> remoteTestSetTestCaseMappings = new List<RemoteTestSetTestCaseMapping>();
				foreach (TestSetTestCaseView testSetTestCase in testSetTestCases)
				{
					RemoteTestSetTestCaseMapping remoteTestSetTestCaseMapping = new RemoteTestSetTestCaseMapping();
					remoteTestSetTestCaseMappings.Add(remoteTestSetTestCaseMapping);

					//Populate fields
					remoteTestSetTestCaseMapping.TestSetTestCaseId = testSetTestCase.TestSetTestCaseId;
					remoteTestSetTestCaseMapping.TestSetId = testSetTestCase.TestSetId;
					remoteTestSetTestCaseMapping.TestCaseId = testSetTestCase.TestCaseId;
					remoteTestSetTestCaseMapping.OwnerId = testSetTestCase.OwnerId;
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestSetTestCaseMappings;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested test case");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Maps a test set to a test case, so that the test case is part of the test set
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="existingTestSetTestCaseId">The id of the existing entry we want to insert it before (if not set, will be simply added to the end of the list)</param>
		/// <param name="remoteTestSetTestCaseMapping">The test set and test case mapping entry</param>
		/// <param name="parameters">Any parameter values to be passed from the test set to the test case</param>
		/// <remarks>
		/// You can only pass in a test case id not a test case folder id
		/// </remarks>
		/// <returns>
		/// A list of the newly mapped items, with the unique instance id (TestSetTestCaseId) populated
		/// </returns>
		public List<RemoteTestSetTestCaseMapping> TestSet_AddTestMapping(RemoteCredentials credentials, int projectId, RemoteTestSetTestCaseMapping remoteTestSetTestCaseMapping, Nullable<int> existingTestSetTestCaseId, List<RemoteTestSetTestCaseParameter> parameters)
		{
			const string METHOD_NAME = "TestSet_AddTestMapping";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			try
			{
				//Now add the test case to the test set, seeing if we need to set any parameter values or not
				TestSetManager testSetManager = new TestSetManager();
				int testSetTestCaseId;
				if (parameters != null && parameters.Count > 0)
				{
					Dictionary<string, string> parameterValues = new Dictionary<string, string>();
					foreach (RemoteTestSetTestCaseParameter parameter in parameters)
					{
						parameterValues.Add(parameter.Name, parameter.Value);
					}
					testSetTestCaseId = testSetManager.AddTestCase(projectId, remoteTestSetTestCaseMapping.TestSetId, remoteTestSetTestCaseMapping.TestCaseId, remoteTestSetTestCaseMapping.OwnerId, existingTestSetTestCaseId, parameterValues);
				}
				else
				{
					testSetTestCaseId = testSetManager.AddTestCase(projectId, remoteTestSetTestCaseMapping.TestSetId, remoteTestSetTestCaseMapping.TestCaseId, remoteTestSetTestCaseMapping.OwnerId, existingTestSetTestCaseId);
				}

				//We need to return the mapping info
				List<RemoteTestSetTestCaseMapping> mappings = new List<RemoteTestSetTestCaseMapping>();
				remoteTestSetTestCaseMapping.TestSetTestCaseId = testSetTestCaseId;
				mappings.Add(remoteTestSetTestCaseMapping);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return mappings;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}

		/// <summary>
		/// Removes a test case from a test set
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTestSetTestCaseMapping">The test set and test case mapping entry</param>
		public void TestSet_RemoveTestMapping(RemoteCredentials credentials, int projectId, RemoteTestSetTestCaseMapping remoteTestSetTestCaseMapping)
		{
			const string METHOD_NAME = "TestSet_RemoveTestMapping";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update test cases
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestCase, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestCases);
			}

			try
			{
				//Now remove the test case from the test set
				TestSetManager testSetManager = new TestSetManager();
				testSetManager.RemoveTestCase(projectId, remoteTestSetTestCaseMapping.TestSetId, remoteTestSetTestCaseMapping.TestSetTestCaseId);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}


		/// <summary>Retrieves comments for a specified test set.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="TestSetId">The ID of the test set to retrieve comments for.</param>
		/// <returns>An array of comments associated with the specified test set.</returns>
		public List<RemoteComment> TestSet_RetrieveComments(RemoteCredentials credentials, int projectId, int TestSetId)
		{
			List<RemoteComment> retList = new List<RemoteComment>();

			if (TestSetId > 0)
			{
				retList = this.CommentRetrieve(credentials, projectId, TestSetId, DataModel.Artifact.ArtifactTypeEnum.TestSet);
			}

			return retList;
		}

		/// <summary>Creates a new comment for a test set.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteComment">The remote comment.</param>
		/// <returns>The RemoteComment with the comment's new ID specified.</returns>
		public RemoteComment TestSet_CreateComment(RemoteCredentials credentials, int projectId, RemoteComment remoteComment)
		{
			RemoteComment retComment = this.CreateComment(credentials, projectId, remoteComment, DataModel.Artifact.ArtifactTypeEnum.TestSet);

			return retComment;
		}

		/// <summary>
		/// Marks a specific test case in a test set as being either in use or available for automated execution
		/// </summary>
		/// <remarks>
		/// Used by RemoteLaunch when in load-balanced execution mode (to avoid being executed simultenously on two hosts)
		/// </remarks>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="testSetId">The id of the test set</param>
		/// <param name="testSetTestCaseId">The id of the test case in the test set</param>
		/// <param name="isInUse">Is the test case in use or available</param>
		public void TestSet_SetInUseStatus(RemoteCredentials credentials, int projectId, int testSetId, int testSetTestCaseId, bool isInUse)
		{
			const string METHOD_NAME = "TestSet_SetInUseStatus";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to change test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestSets);
			}

			try
			{
				//Now update the status of the test case in the test set
				TestSetManager testSetManager = new TestSetManager();
				DateTime? plannedDate = (isInUse) ? (DateTime?)DateTime.UtcNow : null;
				testSetManager.UpdateTestCasePlannedDate(projectId, testSetId, testSetTestCaseId, plannedDate);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Checks to see if a specific test case in a test set is either in use or available for automated execution
		/// </summary>
		/// <remarks>
		/// Used by RemoteLaunch when in load-balanced execution mode (to avoid being executed simultenously on two hosts)
		/// </remarks>
		/// <returns>True if 'in use', False if 'available'</returns>
		/// <param name="credentials">The credentials for accessing the API</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="testSetId">The id of the test set</param>
		/// <param name="testSetTestCaseId">The id of the test case in the test set</param>
		public bool TestSet_CheckInUseStatus(RemoteCredentials credentials, int projectId, int testSetId, int testSetTestCaseId)
		{
			const string METHOD_NAME = "TestSet_CheckInUseStatus";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to change test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTestSets);
			}

			try
			{
				//Now check the status of the test case in the test set, i.e. does it have a planned date value set
				TestSetManager testSetManager = new TestSetManager();
				TestSetTestCaseView testSetTestCase = testSetManager.RetrieveTestCaseById2(testSetTestCaseId);
				if (testSetTestCase == null)
				{
					//The test case does not exist
					throw CreateFault("ArtifactNotFound", Resources.Messages.Services_ArtifactNotFound);
				}
				if (testSetTestCase.ProjectId != projectId || testSetTestCase.TestSetId != testSetId)
				{
					//The user does not have access
					throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
				}

				//For now, in-use means a planned date is set
				bool isInUse = (testSetTestCase.PlannedDate.HasValue);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return isInUse;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw;
			}
		}


		#endregion Test Set Methods

		#region Test Configurations

		/// <summary>
		/// Retrieves the test configuration set associated with the given test set, or NULL if none associated
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testSetId">The id of the test set</param>
		/// <returns>The test configuration set associated with the test set, or NULL if none associated</returns>
		public RemoteTestConfigurationSet TestConfiguration_RetrieveForTestSet(RemoteCredentials credentials, int projectId, int testSetId)
		{
			const string METHOD_NAME = "TestConfiguration_RetrieveSetById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test configuration set
			TestSetManager testSetManager = new TestSetManager();
			TestConfigurationManager testConfigurationManager = new TestConfigurationManager();

			//If the test set was not found, just return null
			try
			{
				//First retrieve the test set itself
				TestSet testSet = testSetManager.RetrieveById2(projectId, testSetId);
				if (testSet != null && testSet.TestConfigurationSetId.HasValue)
				{
					TestConfigurationSet testConfigurationSet = testConfigurationManager.RetrieveSetById(testSet.TestConfigurationSetId.Value, false);

					//Make sure that the project ids match
					if (testConfigurationSet.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}

					//Populate the API data object and return
					RemoteTestConfigurationSet remoteTestConfigurationSet = new RemoteTestConfigurationSet();
					PopulationFunctions.PopulateTestConfigurationSet(remoteTestConfigurationSet, testConfigurationSet);

					//Next we need to populate the entries
					List<TestConfigurationEntry> testConfigurationEntries = testConfigurationManager.RetrieveEntries(projectId, testConfigurationSet.TestConfigurationSetId);
					PopulationFunctions.PopulateTestConfigurationEntries(remoteTestConfigurationSet, testConfigurationEntries);

					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();
					return remoteTestConfigurationSet;
				}
				else
				{
					return null;
				}
			}
			catch (Exception ex)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, ex);
				Logger.Flush();
				throw ConvertExceptions(ex);
			}
		}

		/// <summary>
		/// Retrieves the test configuration set by its id
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="testConfigurationSetId">The id of the test configuration set</param>
		/// <returns>The test configuration set</returns>
		public RemoteTestConfigurationSet TestConfiguration_RetrieveSetById(RemoteCredentials credentials, int projectId, int testConfigurationSetId)
		{
			const string METHOD_NAME = "TestConfiguration_RetrieveSetById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test configuration set
			TestConfigurationManager testConfigurationManager = new TestConfigurationManager();

			//If the test set was not found, just return null
			try
			{
				TestConfigurationSet testConfigurationSet = testConfigurationManager.RetrieveSetById(testConfigurationSetId, false);

				//Make sure that the project ids match
				if (testConfigurationSet.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteTestConfigurationSet remoteTestConfigurationSet = new RemoteTestConfigurationSet();
				PopulationFunctions.PopulateTestConfigurationSet(remoteTestConfigurationSet, testConfigurationSet);

				//Next we need to populate the entries
				List<TestConfigurationEntry> testConfigurationEntries = testConfigurationManager.RetrieveEntries(projectId, testConfigurationSetId);
				PopulationFunctions.PopulateTestConfigurationEntries(remoteTestConfigurationSet, testConfigurationEntries);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestConfigurationSet;
			}
			catch (Exception ex)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, ex);
				Logger.Flush();
				throw ConvertExceptions(ex);
			}
		}

		/// <summary>
		/// Retrieves the list of test configuration sets in the current project (without the detailed entries)
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of test configuration sets</returns>
		public List<RemoteTestConfigurationSet> TestConfiguration_RetrieveSets(RemoteCredentials credentials, int projectId)
		{
			const string METHOD_NAME = "TestConfiguration_RetrieveSetById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view test sets
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.TestSet, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTestSets);
			}

			//Call the business object to actually retrieve the test configuration set
			TestConfigurationManager testConfigurationManager = new TestConfigurationManager();

			//If the test set was not found, just return null
			try
			{
				List<TestConfigurationSet> testConfigurationSets = testConfigurationManager.RetrieveSets(projectId);

				//Populate the API data objects and return
				List<RemoteTestConfigurationSet> remoteTestConfigurationSets = new List<RemoteTestConfigurationSet>();
				foreach (TestConfigurationSet testConfigurationSet in testConfigurationSets)
				{
					RemoteTestConfigurationSet remoteTestConfigurationSet = new RemoteTestConfigurationSet();
					PopulationFunctions.PopulateTestConfigurationSet(remoteTestConfigurationSet, testConfigurationSet);
					remoteTestConfigurationSets.Add(remoteTestConfigurationSet);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTestConfigurationSets;
			}
			catch (Exception ex)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, ex);
				Logger.Flush();
				throw ConvertExceptions(ex);
			}
		}

		#endregion

		#region Task Methods

		/// <summary>Returns the number of tasks that match the filter.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <returns>The number of items.</returns>
		public long Task_Count(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters)
		{
			const string METHOD_NAME = CLASS_NAME + "Task_Count";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the incident dataset
			long retNum = new TaskManager().Count(projectId, filters, 0, null, false);

			Logger.LogExitingEvent(METHOD_NAME);
			return retNum;
		}

		/// <summary>
		/// Retrieves all new tasks added in the system since the date specified
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="startRow">The starting row</param>
		/// <param name="numberOfRows">The maximum number of rows to return</param>
		/// <param name="creationDate">The date after which the task needs to have been created</param>
		/// <returns>List of tasks</returns>
		public List<RemoteTask> Task_RetrieveNew(RemoteCredentials credentials, int projectId, DateTime creationDate, int startRow, int numberOfRows)
		{
			const string METHOD_NAME = "Task_RetrieveNew";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTasks);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Call the business object to actually retrieve the task dataset
			TaskManager taskManager = new TaskManager();
			Hashtable filters = new Hashtable();
			Common.DateRange dateRange = new Common.DateRange();
			dateRange.StartDate = creationDate;
			dateRange.ConsiderTimes = true;
			filters.Add("CreationDate", dateRange);
			List<TaskView> tasks = taskManager.Retrieve(projectId, "CreationDate", true, startRow, numberOfRows, filters, 0);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Task, false);

			//Populate the API data object and return
			List<RemoteTask> remoteTasks = new List<RemoteTask>();
			foreach (TaskView task in tasks)
			{
				//Create and populate the row
				RemoteTask remoteTask = new RemoteTask();
				PopulationFunctions.PopulateTask(remoteTask, task);
				PopulationFunctions.PopulateCustomProperties(remoteTask, task, customProperties);
				remoteTasks.Add(remoteTask);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTasks;
		}

		/// <summary>
		/// Retrieves a list of tasks in the system that match the provided filter/sort
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of tasks</returns>
		public List<RemoteTask> Task_Retrieve(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = "Task_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTasks);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the task dataset
			TaskManager taskManager = new TaskManager();
			List<TaskView> tasks = taskManager.Retrieve(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Task, false);

			//Populate the API data object and return
			List<RemoteTask> remoteTasks = new List<RemoteTask>();
			foreach (TaskView task in tasks)
			{
				//Create and populate the row
				RemoteTask remoteTask = new RemoteTask();
				PopulationFunctions.PopulateTask(remoteTask, task);
				PopulationFunctions.PopulateCustomProperties(remoteTask, task, customProperties);
				remoteTasks.Add(remoteTask);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTasks;
		}

		/// <summary>
		/// Retrieves all tasks owned by the currently authenticated user
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>List of tasks</returns>
		public List<RemoteTask> Task_RetrieveForOwner(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Task_RetrieveForOwner";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//We assume if they are specified as owner, they have permissions since we can't easily
			//check cross-project permissions in one query
			try
			{
				//Call the business object to actually retrieve the task dataset
				TaskManager taskManager = new TaskManager();
				List<TaskView> tasks = taskManager.RetrieveByOwnerId(userId, null, null, false);

				//Get the custom property definitions - for all projects
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(Artifact.ArtifactTypeEnum.Task);

				//Populate the API data object and return
				List<RemoteTask> remoteTasks = new List<RemoteTask>();
				foreach (TaskView task in tasks)
				{
					//Create and populate the row
					RemoteTask remoteTask = new RemoteTask();
					PopulationFunctions.PopulateTask(remoteTask, task);
					PopulationFunctions.PopulateCustomProperties(remoteTask, task, customProperties);
					remoteTasks.Add(remoteTask);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTasks;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a single task in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="taskId">The id of the task</param>
		/// <returns>Task object</returns>
		public RemoteTask Task_RetrieveById(RemoteCredentials credentials, int projectId, int taskId)
		{
			const string METHOD_NAME = "Task_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTasks);
			}

			//Call the business object to actually retrieve the task dataset
			TaskManager taskManager = new TaskManager();

			//If the task was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				TaskView task = taskManager.TaskView_RetrieveById(taskId);

				//Make sure that the project ids match
				if (task.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				ArtifactCustomProperty artifactCustomProperty = new CustomPropertyManager().ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, taskId, DataModel.Artifact.ArtifactTypeEnum.Task, true);

				//Populate the API data object and return
				RemoteTask remoteTask = new RemoteTask();
				PopulationFunctions.PopulateTask(remoteTask, task);
				PopulationFunctions.PopulateCustomProperties(remoteTask, artifactCustomProperty);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTask;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested task");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Updates a task in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTask">The updated task object</param>
		public void Task_Update(RemoteCredentials credentials, RemoteTask remoteTask)
		{
			const string METHOD_NAME = "Task_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have an task id specified
			if (!remoteTask.TaskId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_TaskIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTask.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTasks);
			}

			//First retrieve the existing datarow
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				TaskManager taskManager = new TaskManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				Task task = taskManager.RetrieveById(remoteTask.TaskId.Value);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteTask.TaskId.Value, DataModel.Artifact.ArtifactTypeEnum.Task, true);

				//Make sure that the project ids match
				if (task.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
				UpdateFunctions.UpdateTaskData(task, remoteTask, projectTemplateId);
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTask, remoteTask.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Task, remoteTask.TaskId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}

				//Get copies of everything..
				Artifact notificationArt = task.Clone();
				ArtifactCustomProperty notificationCust = artifactCustomProperty.Clone();

				//Call the business object to actually update the task dataset and the custom properties
				taskManager.Update(task, userId);
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Call notifications..
				try
				{
					new NotificationManager().SendNotificationForArtifact(notificationArt, notificationCust, null);
				}
				catch (Exception ex)
				{
					Logger.LogErrorEvent(METHOD_NAME, ex, "Sending message for Task #" + task.TaskId + ".");
				}
			}
			catch (DataValidationException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested task");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Deletes a task in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="taskId">The id of the task</param>
		public void Task_Delete(RemoteCredentials credentials, int projectId, int taskId)
		{
			const string METHOD_NAME = "Task_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				TaskManager taskManager = new TaskManager();
				Task task = taskManager.RetrieveById(taskId);

				//Make sure that the project ids match
				if (task.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually mark the item as deleted
				taskManager.MarkAsDeleted(projectId, taskId, userId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested task");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Creates a new task in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTask">The new task object (primary key will be empty)</param>
		/// <returns>The populated task object - including the primary key</returns>
		public RemoteTask Task_Create(RemoteCredentials credentials, RemoteTask remoteTask)
		{
			const string METHOD_NAME = "Task_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have an task id specified
			if (remoteTask.TaskId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TaskIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTask.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTasks);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Always use the current project
			remoteTask.ProjectId = projectId;

			//Default to the authenticated user if we have no creator provided
			int creatorId = userId;
			if (remoteTask.CreatorId.HasValue)
			{
				creatorId = remoteTask.CreatorId.Value;
			}

			//Set the default status
			Task.TaskStatusEnum taskStatus = Task.TaskStatusEnum.NotStarted;
			//If the template setting allows bulk edit of status, set the status
			ProjectTemplateSettings projectTemplateSettings = new ProjectTemplateSettings(projectTemplateId);
			if (projectTemplateSettings.Workflow_BulkEditCanChangeStatus)
			{
				taskStatus = (Task.TaskStatusEnum)remoteTask.TaskStatusId;
			}

			//First insert the new task record itself, capturing and populating the id
			TaskManager taskManager = new TaskManager();
			remoteTask.TaskId = taskManager.Insert(
			   projectId,
			   creatorId,
			   taskStatus,
			   remoteTask.TaskTypeId,
			   remoteTask.TaskFolderId,
			   remoteTask.RequirementId,
			   remoteTask.ReleaseId,
			   remoteTask.OwnerId,
			   remoteTask.TaskPriorityId,
			   remoteTask.Name,
			   remoteTask.Description,
			   remoteTask.StartDate,
			   remoteTask.EndDate,
			   remoteTask.EstimatedEffort,
			   remoteTask.ActualEffort,
			   remoteTask.RemainingEffort,
			   userId,
			   true,
			   remoteTask.RiskId
			   );

			//Now we need to populate any custom properties
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();
			ArtifactCustomProperty artifactCustomProperty = null;
			Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteTask, remoteTask.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Task, remoteTask.TaskId.Value, projectTemplateId);
			if (validationMessages != null && validationMessages.Count > 0)
			{
				//Throw a validation exception
				throw CreateValidationException(validationMessages);
			}
			customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

			//Send a notification
			taskManager.SendCreationNotification(remoteTask.TaskId.Value, artifactCustomProperty, null);

			//Finally return the populated task object
			return remoteTask;
		}

		/// <summary>Retrieves comments for a specified task.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="TaskId">The ID of the task to retrieve comments for.</param>
		/// <returns>An array of comments associated with the specified task.</returns>
		public List<RemoteComment> Task_RetrieveComments(RemoteCredentials credentials, int projectId, int TaskId)
		{
			List<RemoteComment> retList = new List<RemoteComment>();

			if (TaskId > 0)
			{
				retList = this.CommentRetrieve(credentials, projectId, TaskId, DataModel.Artifact.ArtifactTypeEnum.Task);
			}

			return retList;
		}

		/// <summary>Creates a new comment for a task.</summary>
		/// <param name="remoteComment">The remote comment.</param>
		/// <returns>The RemoteComment with the comment's new ID specified.</returns>
		public RemoteComment Task_CreateComment(RemoteCredentials credentials, int projectId, RemoteComment remoteComment)
		{
			RemoteComment retComment = this.CreateComment(credentials, projectId, remoteComment, DataModel.Artifact.ArtifactTypeEnum.Task);

			//Send Notification..
			//Pull the requirement.
			int tskNum = -1;
			try
			{
				Task task = new TaskManager().RetrieveById(remoteComment.ArtifactId, true);
				tskNum = task.TaskId;
				if (task != null)
					new NotificationManager().SendNotificationForArtifact(task, null, remoteComment.Text);
			}
			catch (Exception ex)
			{
				Logger.LogErrorEvent(CLASS_NAME + "Task_CreateComment()", ex, "Sending message for Task #" + tskNum + ".");
			}

			return retComment;
		}

		/// <summary>
		/// Retrieves the list of task statuses in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of task statuses</returns>
		public List<RemoteTaskStatus> Task_RetrieveStatuses(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Task_RetrieveStatuses";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Call the business object to actually retrieve the task statuses
			TaskManager taskManager = new TaskManager();

			try
			{
				List<TaskStatus> taskStati = taskManager.RetrieveStatuses();

				//Populate the API data objects and return
				List<RemoteTaskStatus> remoteTaskStati = new List<RemoteTaskStatus>();
				foreach (TaskStatus taskStatus in taskStati)
				{
					RemoteTaskStatus remoteTaskStatus = new RemoteTaskStatus();
					PopulationFunctions.PopulateTaskStatus(remoteTaskStatus, taskStatus);
					remoteTaskStati.Add(remoteTaskStatus);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTaskStati;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of task types in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of task types </returns>
		public List<RemoteTaskType> Task_RetrieveTypes(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Task_RetrieveTypes";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Call the business object to actually retrieve the task types
			TaskManager taskManager = new TaskManager();
			TaskWorkflowManager workflowManager = new TaskWorkflowManager();

			try
			{
				List<TaskType> taskTypes = taskManager.TaskType_Retrieve(projectTemplateId);

				//Populate the API data objects and return
				List<RemoteTaskType> remoteTaskTypes = new List<RemoteTaskType>();
				foreach (TaskType taskType in taskTypes)
				{
					RemoteTaskType remoteTaskType = new RemoteTaskType();
					PopulationFunctions.PopulateTaskType(remoteTaskType, taskType);
					remoteTaskTypes.Add(remoteTaskType);

					//Also get the associated workflow for this project
					remoteTaskType.WorkflowId = workflowManager.Workflow_GetForTaskType(taskType.TaskTypeId);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTaskTypes;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of task priorities in the project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of task priorities </returns>
		public List<RemoteTaskPriority> Task_RetrievePriorities(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Task_RetrievePriorities";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Call the business object to actually retrieve the task priorities
			TaskManager taskManager = new TaskManager();

			try
			{
				List<TaskPriority> priorities = taskManager.TaskPriority_Retrieve(projectTemplateId);

				//Populate the API data objects and return
				List<RemoteTaskPriority> remoteTaskPriorities = new List<RemoteTaskPriority>();
				foreach (TaskPriority priority in priorities)
				{
					RemoteTaskPriority remoteTaskPriority = new RemoteTaskPriority();
					PopulationFunctions.PopulateTaskPriority(remoteTaskPriority, priority);
					remoteTaskPriorities.Add(remoteTaskPriority);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTaskPriorities;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of task fields and their workflow status for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current task type</param>
		/// <param name="currentStatusId">The current task status</param>
		/// <returns>The list of task fields</returns>
		public List<RemoteWorkflowField> Task_RetrieveWorkflowFields(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "Task_RetrieveWorkflowFields";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowField> retList = new List<RemoteWorkflowField>();

			//Get the workflow ID for the specified type.
			TaskWorkflowManager workflowManager = new TaskWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForTaskType(currentTypeId);

			//Pull fields.
			List<TaskWorkflowField> workflowFields = workflowManager.Workflow_RetrieveFieldStates(workflowId, currentStatusId);

			foreach (TaskWorkflowField workflowField in workflowFields)
			{
				RemoteWorkflowField remoteWorkflowField = new RemoteWorkflowField();
				PopulationFunctions.PopulateWorkflowField(remoteWorkflowField, workflowField);
				retList.Add(remoteWorkflowField);
			}

			return retList;
		}

		/// <summary>
		/// Will retrieve available transitions for the specied status ID for the currently logged-on user.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current task type</param>
		/// <param name="currentStatusId">The current task status</param>
		/// <param name="isCreator">Is the user the creator of the task</param>
		/// <param name="isOwner">Is the user the owner of the task</param>
		/// <returns>The list of workflow transitions</returns>
		public List<RemoteWorkflowTransition> Task_RetrieveWorkflowTransitions(RemoteCredentials credentials, int projectId, int currentTypeId, int currentStatusId, bool isCreator, bool isOwner)
		{
			const string METHOD_NAME = "Task_RetrieveWorkflowTransitions";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTasks);
			}

			List<RemoteWorkflowTransition> retList = new List<RemoteWorkflowTransition>();

			//Get the use's role in the project.
			ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
			if (projectUser == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}
			int roleId = projectUser.ProjectRoleId;

			//Get the workflow ID for the specified type.
			TaskWorkflowManager workflowManager = new TaskWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForTaskType(currentTypeId);

			List<TaskWorkflowTransition> workflowTransitions = workflowManager.WorkflowTransition_RetrieveByInputStatus(workflowId, currentStatusId, roleId, isCreator, isOwner);

			foreach (TaskWorkflowTransition transition in workflowTransitions)
			{
				RemoteWorkflowTransition wrkTransition = new RemoteWorkflowTransition();
				PopulationFunctions.PopulateWorkflowTransition(wrkTransition, transition);
				retList.Add(wrkTransition);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves the list of task custom properties and their workflow state for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current task type</param>
		/// <param name="currentStatusId">The current task status</param>
		/// <returns>The list of task custom property states</returns>
		public List<RemoteWorkflowCustomProperty> Task_RetrieveWorkflowCustomProperties(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "Task_RetrieveWorkflowCustomProperties";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowCustomProperty> retList = new List<RemoteWorkflowCustomProperty>();

			//Get the workflow ID for the specified type.
			TaskWorkflowManager workflowManager = new TaskWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForTaskType(currentTypeId);

			//Pull custom properties
			List<TaskWorkflowCustomProperty> workflowCustomProperties = workflowManager.Workflow_RetrieveCustomPropertyStates(workflowId, currentStatusId);

			foreach (TaskWorkflowCustomProperty workflowCustomProperty in workflowCustomProperties)
			{
				RemoteWorkflowCustomProperty remoteWorkflowCustomProperty = new RemoteWorkflowCustomProperty();
				PopulationFunctions.PopulateWorkflowCustomProperty(remoteWorkflowCustomProperty, workflowCustomProperty);
				retList.Add(remoteWorkflowCustomProperty);
			}

			return retList;
		}

		/// <summary>
		/// Creates a new task folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTaskFolder">The new task folder object (primary key will be empty)</param>
		/// <returns>The populated task folder object - including the primary key</returns>
		public RemoteTaskFolder Task_CreateFolder(RemoteCredentials credentials, RemoteTaskFolder remoteTaskFolder)
		{
			const string METHOD_NAME = "Task_CreateFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have a test folder id specified
			if (remoteTaskFolder.TaskFolderId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_TaskIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTaskFolder.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateTestFolders);
			}

			//Always use the current project
			remoteTaskFolder.ProjectId = projectId;

			//Instantiate the task business class
			Business.TaskManager taskManager = new Business.TaskManager();

			//Now insert the test folder under the parent
			remoteTaskFolder.TaskFolderId = taskManager.TaskFolder_Create(
				remoteTaskFolder.Name,
				remoteTaskFolder.ProjectId,
				remoteTaskFolder.ParentTaskFolderId
				).TaskFolderId;


			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteTaskFolder;
		}

		/// <summary>
		/// Retrieves all of the task folders in the project with their hierarchy
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>List of task folders</returns>
		public List<RemoteTaskFolder> Task_RetrieveFolders(RemoteCredentials credentials, int projectId)
		{
			const string METHOD_NAME = "Task_RetrieveFolders";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTasks);
			}

			//Call the business object to actually retrieve the task dataset
			TaskManager taskManager = new TaskManager();

			//If the task folder was not found, just return null
			try
			{
				List<RemoteTaskFolder> remoteTaskFolders = new List<RemoteTaskFolder>();

				List<TaskFolderHierarchyView> taskFolders = taskManager.TaskFolder_GetList(projectId);

				foreach (TaskFolderHierarchyView taskFolder in taskFolders)
				{
					//Populate the API data objects and return
					RemoteTaskFolder remoteTaskFolder = new RemoteTaskFolder();
					PopulationFunctions.PopulateTaskFolder(projectId, remoteTaskFolder, taskFolder);
					remoteTaskFolders.Add(remoteTaskFolder);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTaskFolders;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a single test folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="taskFolderId">The id of the test folder</param>
		/// <returns>Test Case Folder object</returns>
		public RemoteTaskFolder Task_RetrieveFolderById(RemoteCredentials credentials, int projectId, int taskFolderId)
		{
			const string METHOD_NAME = "Task_RetrieveFolderById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTasks);
			}

			//Call the business object to actually retrieve the task dataset
			TaskManager taskManager = new TaskManager();

			//If the task folder was not found, just return null
			try
			{
				TaskFolder taskFolder = taskManager.TaskFolder_GetById(taskFolderId);
				if (taskFolder == null)
				{
					return null;
				}

				//Make sure that the project ids match
				if (taskFolder.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteTaskFolder remoteTaskFolder = new RemoteTaskFolder();
				PopulationFunctions.PopulateTaskFolder(remoteTaskFolder, taskFolder);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTaskFolder;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}


		/// <summary>
		/// Retrieves a list of folders by the parent folder
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="parentTaskFolderId">The id of the parent folder, or null = root</param>
		/// <returns>The list of folders</returns>
		public List<RemoteTaskFolder> Task_RetrieveFoldersByParent(RemoteCredentials credentials, int projectId, int? parentTaskFolderId)
		{
			const string METHOD_NAME = "Task_RetrieveFoldersByParent";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewTasks);
			}

			//Call the business object to actually retrieve the task dataset
			TaskManager taskManager = new TaskManager();

			//If the task folder was not found, just return null
			try
			{
				List<RemoteTaskFolder> remoteTaskFolders = new List<RemoteTaskFolder>();

				List<TaskFolder> taskFolders = taskManager.TaskFolder_GetByParentId(projectId, parentTaskFolderId);

				foreach (TaskFolder taskFolder in taskFolders)
				{
					//Populate the API data objects and return
					RemoteTaskFolder remoteTaskFolder = new RemoteTaskFolder();
					PopulationFunctions.PopulateTaskFolder(remoteTaskFolder, taskFolder);
					remoteTaskFolders.Add(remoteTaskFolder);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTaskFolders;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates a test folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteTaskFolder">The updated task folder object</param>
		public void Task_UpdateFolder(RemoteCredentials credentials, RemoteTaskFolder remoteTaskFolder)
		{
			const string METHOD_NAME = "Task_UpdateFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have a task folder id specified
			if (!remoteTaskFolder.TaskFolderId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_TaskIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteTaskFolder.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyTasks);
			}

			//First retrieve the existing datarow
			try
			{
				TaskManager taskManager = new TaskManager();

				TaskFolder taskFolder = taskManager.TaskFolder_GetById(remoteTaskFolder.TaskFolderId.Value);
				if (taskFolder != null)
				{
					//Make sure that the project ids match
					if (taskFolder.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}

					//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
					//First the task report
					UpdateFunctions.UpdateTaskFolderData(taskFolder, remoteTaskFolder);

					//Call the business object to actually update the test folder dataset
					taskManager.TaskFolder_Update(taskFolder);
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes a task folder in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="taskFolderId">The id of the task</param>
		public void Task_DeleteFolder(RemoteCredentials credentials, int projectId, int taskFolderId)
		{
			const string METHOD_NAME = "Task_DeleteFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete tasks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Task, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				TaskManager taskManager = new TaskManager();
				TaskFolder taskFolder = taskManager.TaskFolder_GetById(taskFolderId);
				if (taskFolder != null)
				{
					//Make sure that the project ids match
					if (taskFolder.ProjectId != projectId)
					{
						throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
					}

					//Call the business object to actually delete the folder
					taskManager.TaskFolder_Delete(projectId, taskFolderId);
				}
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
		}

		#endregion Task Methods

		#region Data Mapping Methods

		/// <summary>
		/// Retrieves a list of data mappings for artifact field values
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="artifactFieldId">The field we're interested in</param>
		/// <param name="dataSyncSystemId">The id of the plug-in</param>
		/// <returns>The list of data mappings</returns>
		public List<RemoteDataMapping> DataMapping_RetrieveFieldValueMappings(RemoteCredentials credentials, int projectId, int dataSyncSystemId, int artifactFieldId)
		{
			const string METHOD_NAME = "DataMapping_RetrieveFieldValueMappings";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Get the list of artifact field value mappings
			DataMappingManager dataMappingManager = new DataMappingManager();
			List<DataSyncFieldValueMappingView> dataMappings = dataMappingManager.RetrieveDataSyncFieldValueMappings(dataSyncSystemId, projectId, artifactFieldId, false);

			//Populate the API data object and return
			List<RemoteDataMapping> remoteDataMappings = new List<RemoteDataMapping>();
			foreach (DataSyncFieldValueMappingView fieldMapping in dataMappings)
			{
				//Create and populate the row
				RemoteDataMapping remoteDataMapping = new RemoteDataMapping();
				remoteDataMapping.InternalId = fieldMapping.ArtifactFieldValue.Value;
				remoteDataMapping.ProjectId = fieldMapping.ProjectId;
				remoteDataMapping.ExternalKey = fieldMapping.ExternalKey;
				remoteDataMapping.Primary = (fieldMapping.PrimaryYn == "Y");
				remoteDataMappings.Add(remoteDataMapping);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDataMappings;
		}

		/// <summary>
		/// Retrieves the data mapping for a custom property
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="dataSyncSystemId">The id of the plug-in</param>
		/// <param name="artifactTypeId">The id of the type of artifact</param>
		/// <param name="customPropertyId">The id of the custom property</param>
		/// <returns>Data mapping object</returns>
		public RemoteDataMapping DataMapping_RetrieveCustomPropertyMapping(RemoteCredentials credentials, int projectId, int dataSyncSystemId, int artifactTypeId, int customPropertyId)
		{
			const string METHOD_NAME = "DataMapping_RetrieveCustomPropertyMapping";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Get the custom property mapping
			DataMappingManager dataMappingManager = new DataMappingManager();
			DataSyncCustomPropertyMapping dataMapping = dataMappingManager.RetrieveDataSyncCustomPropertyMapping(dataSyncSystemId, projectId, (DataModel.Artifact.ArtifactTypeEnum)artifactTypeId, customPropertyId);

			//Populate the API data object and return
			if (dataMapping == null)
			{
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return null;
			}
			RemoteDataMapping remoteDataMapping = new RemoteDataMapping();
			remoteDataMapping.InternalId = dataMapping.CustomPropertyId;
			remoteDataMapping.ProjectId = dataMapping.ProjectId;
			remoteDataMapping.ExternalKey = dataMapping.ExternalKey;

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDataMapping;
		}

		/// <summary>
		/// Retrieves a list of data mappings for custom property values
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="dataSyncSystemId">The id of the plug-in</param>
		/// <param name="artifactTypeId">The id of the type of artifact</param>
		/// <param name="customPropertyId">The id of the custom property that the values are for</param>
		/// <returns>The list of data mappings</returns>
		public List<RemoteDataMapping> DataMapping_RetrieveCustomPropertyValueMappings(RemoteCredentials credentials, int projectId, int dataSyncSystemId, int artifactTypeId, int customPropertyId)
		{
			const string METHOD_NAME = "DataMapping_RetrieveCustomPropertyValueMappings";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Get the list of custom property value mappings
			DataMappingManager dataMappingManager = new DataMappingManager();
			List<DataSyncCustomPropertyValueMappingView> dataMappings = dataMappingManager.RetrieveDataSyncCustomPropertyValueMappings(dataSyncSystemId, projectId, (DataModel.Artifact.ArtifactTypeEnum)artifactTypeId, customPropertyId, false);

			//Populate the API data object and return
			List<RemoteDataMapping> remoteDataMappings = new List<RemoteDataMapping>();
			foreach (DataSyncCustomPropertyValueMappingView dataRow in dataMappings)
			{
				//Create and populate the row
				RemoteDataMapping remoteDataMapping = new RemoteDataMapping();
				remoteDataMapping.InternalId = dataRow.CustomPropertyValueId;
				remoteDataMapping.ProjectId = dataRow.ProjectId;
				remoteDataMapping.ExternalKey = dataRow.ExternalKey;
				remoteDataMappings.Add(remoteDataMapping);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDataMappings;
		}

		/// <summary>
		/// Retrieves a list of data mappings for projects in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="dataSyncSystemId">The id of the plug-in</param>
		/// <returns>The list of data mappings</returns>
		public List<RemoteDataMapping> DataMapping_RetrieveProjectMappings(RemoteCredentials credentials, int dataSyncSystemId)
		{
			const string METHOD_NAME = "DataMapping_RetrieveProjectMappings";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Get the list of project mappings
			DataMappingManager dataMappingManager = new DataMappingManager();
			List<DataSyncProject> dataMappings = dataMappingManager.RetrieveDataSyncProjects(dataSyncSystemId);

			//Populate the API data object and return
			List<RemoteDataMapping> remoteDataMappings = new List<RemoteDataMapping>();
			foreach (DataSyncProject dataRow in dataMappings)
			{
				//Create and populate the row
				RemoteDataMapping remoteDataMapping = new RemoteDataMapping();
				remoteDataMapping.InternalId = dataRow.ProjectId;
				remoteDataMapping.ProjectId = dataRow.ProjectId;
				remoteDataMapping.ExternalKey = dataRow.ExternalKey;
				remoteDataMappings.Add(remoteDataMapping);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDataMappings;
		}

		/// <summary>
		/// Retrieves a list of data mappings for users in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="dataSyncSystemId">The id of the plug-in</param>
		/// <returns>The list of data mappings</returns>
		public List<RemoteDataMapping> DataMapping_RetrieveUserMappings(RemoteCredentials credentials, int dataSyncSystemId)
		{
			const string METHOD_NAME = "DataMapping_RetrieveUserMappings";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Get the list of user mappings
			DataMappingManager dataMappingManager = new DataMappingManager();
			List<DataSyncUserMapping> dataMappings = dataMappingManager.RetrieveDataSyncUserMappingsForSystem(dataSyncSystemId);

			//Populate the API data object and return
			List<RemoteDataMapping> remoteDataMappings = new List<RemoteDataMapping>();
			foreach (DataSyncUserMapping dataRow in dataMappings)
			{
				//Create and populate the row
				RemoteDataMapping remoteDataMapping = new RemoteDataMapping();
				remoteDataMapping.InternalId = dataRow.UserId;
				remoteDataMapping.ExternalKey = dataRow.ExternalKey;
				remoteDataMappings.Add(remoteDataMapping);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDataMappings;
		}

		/// <summary>
		/// Adds new user data mapping entries
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="dataSyncSystemId">The id of the plug-in we're interested in</param>
		/// <param name="remoteDataMappings">The list of mapping entries to add</param>
		public void DataMapping_AddUserMappings(RemoteCredentials credentials, int dataSyncSystemId, List<RemoteDataMapping> remoteDataMappings)
		{
			const string METHOD_NAME = "DataMapping_AddUserMappings";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Get the list of existing user mappings
			DataMappingManager dataMappingManager = new DataMappingManager();
			List<DataSyncUserMapping> dataMappings = dataMappingManager.RetrieveDataSyncUserMappingsForSystem(dataSyncSystemId);

			//Now iterate through the provided list of mappings and add any new ones (ignore duplicates)
			foreach (RemoteDataMapping remoteDataMapping in remoteDataMappings)
			{
				//See if we already have the mapping
				DataSyncUserMapping dataRow = dataMappings.FirstOrDefault(d => d.UserId == remoteDataMapping.InternalId);
				if (dataRow == null)
				{
					DataSyncUserMapping newMapping = new DataSyncUserMapping();
					newMapping.MarkAsAdded();
					newMapping.DataSyncSystemId = dataSyncSystemId;
					newMapping.UserId = remoteDataMapping.InternalId;
					newMapping.ExternalKey = remoteDataMapping.ExternalKey;
					dataMappings.Add(newMapping);
				}
			}

			//Save the changes
			dataMappingManager.SaveDataSyncUserMappings(dataMappings);

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Retrieves a list of data mappings for artifact ids in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="artifactTypeId">The type of artifact we're interested in</param>
		/// <param name="dataSyncSystemId">The id of the plug-in</param>
		/// <returns>The list of data mappings</returns>
		public List<RemoteDataMapping> DataMapping_RetrieveArtifactMappings(RemoteCredentials credentials, int projectId, int dataSyncSystemId, int artifactTypeId)
		{
			const string METHOD_NAME = "DataMapping_RetrieveArtifactMappings";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Get the list of artifact id mappings
			DataMappingManager dataMappingManager = new DataMappingManager();
			List<DataSyncArtifactMapping> dataMappings = dataMappingManager.RetrieveDataSyncArtifactMappings(dataSyncSystemId, projectId, (DataModel.Artifact.ArtifactTypeEnum)artifactTypeId);

			//Populate the API data object and return
			List<RemoteDataMapping> remoteDataMappings = new List<RemoteDataMapping>();
			foreach (DataSyncArtifactMapping dataRow in dataMappings)
			{
				//Create and populate the row
				RemoteDataMapping remoteDataMapping = new RemoteDataMapping();
				remoteDataMapping.InternalId = dataRow.ArtifactId;
				remoteDataMapping.ProjectId = dataRow.ProjectId;
				remoteDataMapping.ExternalKey = dataRow.ExternalKey;
				remoteDataMappings.Add(remoteDataMapping);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteDataMappings;
		}

		/// <summary>
		/// Retrieves a list of data mappings for a specific artifact across all projects in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="externalKey">The external system key of the artifact we're interested in</param>
		/// <param name="artifactTypeId">The type of artifact we're interested in</param>
		/// <param name="dataSyncSystemId">The id of the plug-in</param>
		/// <returns>The list of martching artifact ids</returns>
		public List<RemoteProjectArtifact> DataMapping_SearchArtifactMappings(RemoteCredentials credentials, int dataSyncSystemId, int artifactTypeId, string externalKey)
		{
			const string METHOD_NAME = "DataMapping_SearchArtifactMappings";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//We don't need to be connected to a project.

			//Loop through all the projects the current user is a member of
			ProjectManager projectManager = new ProjectManager();
			DataMappingManager dataMappingManager = new DataMappingManager();
			List<ProjectUser> projectUsers = projectManager.RetrieveProjectMembershipForUser(userId);
			List<RemoteProjectArtifact> matchingProjectArtifactIds = new List<RemoteProjectArtifact>();
			foreach (ProjectUser projectUser in projectUsers)
			{
				RemoteProjectArtifact remoteProjectArtifact = new RemoteProjectArtifact();
				remoteProjectArtifact.ProjectId = projectUser.ProjectId;
				remoteProjectArtifact.ArtifactIds = new List<int>();
				//Get the list of artifact id mappings
				List<DataSyncArtifactMapping> artifactMappings = dataMappingManager.RetrieveDataSyncArtifactMappingByExternalKey(dataSyncSystemId, projectUser.ProjectId, (DataModel.Artifact.ArtifactTypeEnum)artifactTypeId, externalKey);
				if (artifactMappings.Count > 0)
				{
					foreach (DataSyncArtifactMapping artifactMapping in artifactMappings)
					{
						if (!remoteProjectArtifact.ArtifactIds.Contains(artifactMapping.ArtifactId))
						{
							remoteProjectArtifact.ArtifactIds.Add(artifactMapping.ArtifactId);
						}
					}
					matchingProjectArtifactIds.Add(remoteProjectArtifact);
				}
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return matchingProjectArtifactIds;
		}

		/// <summary>
		/// Adds new artifact data mapping entries
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="dataSyncSystemId">The id of the plug-in we're interested in</param>
		/// <param name="artifactTypeId">The type of artifact the mappings are for</param>
		/// <param name="remoteDataMappings">The list of mapping entries to add</param>
		public void DataMapping_AddArtifactMappings(RemoteCredentials credentials, int projectId, int dataSyncSystemId, int artifactTypeId, List<RemoteDataMapping> remoteDataMappings)
		{
			const string METHOD_NAME = "DataMapping_AddArtifactMappings";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Get the list of existing artifact id mappings
			DataMappingManager dataMappingManager = new DataMappingManager();
			List<DataSyncArtifactMapping> dataMappings = dataMappingManager.RetrieveDataSyncArtifactMappings(dataSyncSystemId, projectId, (DataModel.Artifact.ArtifactTypeEnum)artifactTypeId);

			//Now iterate through the provided list of mappings and add any new ones (ignore duplicates)
			foreach (RemoteDataMapping remoteDataMapping in remoteDataMappings)
			{
				//See if we already have the mapping
				DataSyncArtifactMapping dataRow = dataMappings.FirstOrDefault(d => d.ArtifactId == remoteDataMapping.InternalId);
				if (dataRow == null)
				{
					DataSyncArtifactMapping newMapping = new DataSyncArtifactMapping();
					newMapping.MarkAsAdded();
					newMapping.DataSyncSystemId = dataSyncSystemId;
					newMapping.ProjectId = projectId;
					newMapping.ArtifactTypeId = artifactTypeId;
					newMapping.ArtifactId = remoteDataMapping.InternalId;
					newMapping.ExternalKey = remoteDataMapping.ExternalKey;
					dataMappings.Add(newMapping);
				}
			}

			//Save the changes
			dataMappingManager.SaveDataSyncArtifactMappings(dataMappings);

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		/// <summary>
		/// Removes existing artifact data mapping entries
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="dataSyncSystemId">The id of the plug-in we're interested in</param>
		/// <param name="artifactTypeId">The type of artifact the mappings are for</param>
		/// <param name="remoteDataMappings">The list of mapping entries to remove</param>
		public void DataMapping_RemoveArtifactMappings(RemoteCredentials credentials, int projectId, int dataSyncSystemId, int artifactTypeId, List<RemoteDataMapping> remoteDataMappings)
		{
			const string METHOD_NAME = "DataMapping_RemoveArtifactMappings";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Get the list of existing artifact id mappings
			DataMappingManager dataMappingManager = new DataMappingManager();
			List<DataSyncArtifactMapping> dataMappings = dataMappingManager.RetrieveDataSyncArtifactMappings(dataSyncSystemId, projectId, (DataModel.Artifact.ArtifactTypeEnum)artifactTypeId);

			//Now iterate through the provided list of mappings and remove any old ones (ignore it if they've been already deleted)
			foreach (RemoteDataMapping remoteDataMapping in remoteDataMappings)
			{
				//See if we already have the mapping
				DataSyncArtifactMapping dataRow = dataMappings.FirstOrDefault(d => d.ArtifactId == remoteDataMapping.InternalId);
				if (dataRow != null)
				{
					//To remove the mapping, just set the external key to null
					dataRow.StartTracking();
					dataRow.ExternalKey = null;
				}
			}

			//Save the changes
			dataMappingManager.SaveDataSyncArtifactMappings(dataMappings);

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
		}

		#endregion Data Mapping Methods

		#region Comment Methods (Internal)

		private List<RemoteComment> CommentRetrieve(RemoteCredentials credentials, int projectId, int artifactId, DataModel.Artifact.ArtifactTypeEnum artifactType)
		{
			const string METHOD_NAME = "CommentRetrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			List<RemoteComment> retComments = new List<RemoteComment>();

			//Get our comments, then convert them over.
			IEnumerable<IDiscussion> comments = new DiscussionManager().Retrieve(artifactId, artifactType, false);

			if (comments.Count() > 0)
			{
				foreach (IDiscussion commentRow in comments)
				{
					RemoteComment newComment = new RemoteComment();
					newComment.ArtifactId = commentRow.ArtifactId;
					newComment.CommentId = commentRow.DiscussionId;
					newComment.IsDeleted = commentRow.IsDeleted;
					newComment.Text = commentRow.Text;
					newComment.CreationDate = commentRow.CreationDate;
					newComment.UserId = commentRow.CreatorId;
					newComment.UserName = commentRow.CreatorName;
					newComment.IsPermanent = commentRow.IsPermanent;

					retComments.Add(newComment);
				}
			}

			return retComments;
		}

		/// <summary>
		/// Creates a new comment from the provided API object
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="remoteComment">The API data object</param>
		/// <param name="artifactType">The  type of artifact</param>
		/// <returns>The updated API object</returns>
		private RemoteComment CreateComment(RemoteCredentials credentials, int projectId, RemoteComment remoteComment, DataModel.Artifact.ArtifactTypeEnum artifactType)
		{
			const string METHOD_NAME = "CreateComment";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			if (remoteComment.ArtifactId > 0)
			{
				DiscussionManager discussionManager = new DiscussionManager();
				if (remoteComment.CreationDate.HasValue)
				{
					remoteComment.CommentId = discussionManager.Insert(
						(remoteComment.UserId.HasValue) ? remoteComment.UserId.Value : credentials.UserId,
						remoteComment.ArtifactId,
						artifactType,
						remoteComment.Text,
						remoteComment.CreationDate.Value,
						projectId,
						remoteComment.IsPermanent,
						true
						);
				}
				else
				{
					remoteComment.CommentId = discussionManager.Insert(
						(remoteComment.UserId.HasValue) ? remoteComment.UserId.Value : credentials.UserId,
						remoteComment.ArtifactId,
						artifactType,
						remoteComment.Text,
						projectId,
						remoteComment.IsPermanent,
						true
						);
				}
			}
			else
			{
				throw new Exception("ArtifactID must be entered.");
			}

			return remoteComment;
		}

		#endregion Comment Methods (Internal)

		#region Automation Host methods

		/// <summary>
		/// Retrieves the list of automation hosts in the current project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The array of filters</param>
		/// <param name="remoteSort">The sort to be applied</param>
		/// <param name="startingRow">The starting row (1-based)</param>
		/// <param name="numberOfRows">The number of rows to retrieve</param>
		/// <returns>List of automation host objects</returns>
		public List<RemoteAutomationHost> AutomationHost_Retrieve(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = "AutomationHost_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view automation hosts
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.AutomationHost, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewAutomationHosts);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the automation host dataset
			AutomationManager automationManager = new AutomationManager();
			List<AutomationHostView> automationHosts = automationManager.RetrieveHosts(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.AutomationHost, false);

			//Populate the API data object and return
			List<RemoteAutomationHost> remoteAutomationHosts = new List<RemoteAutomationHost>();
			foreach (AutomationHostView automationHost in automationHosts)
			{
				//Create and populate the row
				RemoteAutomationHost remoteAutomationHost = new RemoteAutomationHost();
				PopulationFunctions.PopulateAutomationHost(remoteAutomationHost, automationHost);
				PopulationFunctions.PopulateCustomProperties(remoteAutomationHost, automationHost, customProperties);
				remoteAutomationHosts.Add(remoteAutomationHost);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteAutomationHosts;
		}

		/// <summary>
		/// Retrieves a single automation host by its id
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="automationHostId">The id of the automation host</param>
		/// <returns>The automation host object</returns>
		public RemoteAutomationHost AutomationHost_RetrieveById(RemoteCredentials credentials, int projectId, int automationHostId)
		{
			const string METHOD_NAME = "AutomationHost_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view automation hosts
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.AutomationHost, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewAutomationHosts);
			}

			//Call the business object to actually retrieve the automation host dataset
			AutomationManager automationManager = new AutomationManager();
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();

			//If the host was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				AutomationHostView automationHost = automationManager.RetrieveHostById(automationHostId);

				//Make sure that the project ids match
				if (automationHost.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				ArtifactCustomProperty artifactCustomProperty = new CustomPropertyManager().ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, automationHostId, Artifact.ArtifactTypeEnum.AutomationHost, true);

				//Populate the API data object and return
				RemoteAutomationHost remoteAutomationHost = new RemoteAutomationHost();
				PopulationFunctions.PopulateAutomationHost(remoteAutomationHost, automationHost);
				PopulationFunctions.PopulateCustomProperties(remoteAutomationHost, artifactCustomProperty);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteAutomationHost;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested automation host");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Retrieves a single automation host by its token name
		/// </summary>
		/// <param name="token">The automation host's token name</param>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The automation host object</returns>
		/// <remarks>Token names are only unique within a project</remarks>
		public RemoteAutomationHost AutomationHost_RetrieveByToken(RemoteCredentials credentials, int projectId, string token)
		{
			const string METHOD_NAME = "AutomationHost_RetrieveByToken";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view automation hosts
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.AutomationHost, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewAutomationHosts);
			}

			//Call the business object to actually retrieve the automation host dataset
			AutomationManager automationManager = new AutomationManager();

			//If the host was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				AutomationHostView automationHost = automationManager.RetrieveHostByToken(projectId, token);

				//Get the custom property definitions
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.AutomationHost, false);

				//Populate the API data object and return
				RemoteAutomationHost remoteAutomationHost = new RemoteAutomationHost();
				PopulationFunctions.PopulateAutomationHost(remoteAutomationHost, automationHost);
				PopulationFunctions.PopulateCustomProperties(remoteAutomationHost, automationHost, customProperties);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteAutomationHost;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested automation host");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Creates a new automation host in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteAutomationHost">The new automation host object (primary key will be empty)</param>
		/// <returns>The populated automation host object - including the primary key</returns>
		public RemoteAutomationHost AutomationHost_Create(RemoteCredentials credentials, RemoteAutomationHost remoteAutomationHost)
		{
			const string METHOD_NAME = "AutomationHost_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have an primary key specified
			if (remoteAutomationHost.AutomationHostId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_AutomationHostIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteAutomationHost.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create automation hosts
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.AutomationHost, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateAutomationHosts);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Always use the current project
			remoteAutomationHost.ProjectId = projectId;

			//First insert the new automation host record itself, capturing and populating the id
			AutomationManager automationManager = new AutomationManager();
			remoteAutomationHost.AutomationHostId = automationManager.InsertHost(
			   projectId,
			   remoteAutomationHost.Name,
			   remoteAutomationHost.Token,
			   remoteAutomationHost.Description,
			   remoteAutomationHost.Active,
			   userId);

			//Now we need to populate any custom properties
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();
			ArtifactCustomProperty artifactCustomProperty = null;
			Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteAutomationHost, remoteAutomationHost.ProjectId, DataModel.Artifact.ArtifactTypeEnum.AutomationHost, remoteAutomationHost.AutomationHostId.Value, projectTemplateId);
			if (validationMessages != null && validationMessages.Count > 0)
			{
				//Throw a validation exception
				throw CreateValidationException(validationMessages);
			}
			customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

			//Finally return the populated data object
			return remoteAutomationHost;
		}

		/// <summary>
		/// Updates an automation host in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteAutomationHost">The updated task object</param>
		public void AutomationHost_Update(RemoteCredentials credentials, RemoteAutomationHost remoteAutomationHost)
		{
			const string METHOD_NAME = "AutomationHost_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have a primary key id specified
			if (!remoteAutomationHost.AutomationHostId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_AutomationHostIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteAutomationHost.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update hosts
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.AutomationHost, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyAutomationHosts);
			}

			//First retrieve the existing datarow
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				AutomationManager automationManager = new AutomationManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				AutomationHost automationHost = automationManager.RetrieveHostById2(remoteAutomationHost.AutomationHostId.Value);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteAutomationHost.AutomationHostId.Value, DataModel.Artifact.ArtifactTypeEnum.AutomationHost, true);

				//Make sure that the project ids match
				if (automationHost.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
				UpdateFunctions.UpdateAutomationHostData(automationHost, remoteAutomationHost);
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteAutomationHost, remoteAutomationHost.ProjectId, DataModel.Artifact.ArtifactTypeEnum.AutomationHost, remoteAutomationHost.AutomationHostId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}

				//Call the business object to actually update the dataset and the custom properties
				automationManager.UpdateHost(automationHost, userId);
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);
			}
			catch (DataValidationException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested automation host");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Deletes a automation host in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="automationHostId">The id of the automation host</param>
		public void AutomationHost_Delete(RemoteCredentials credentials, int projectId, int automationHostId)
		{
			const string METHOD_NAME = "AutomationHost_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete automation hosts
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.AutomationHost, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				AutomationManager automationManager = new AutomationManager();
				AutomationHostView automationHost = automationManager.RetrieveHostById(automationHostId);

				//Make sure that the project ids match
				if (automationHost.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually mark the item as deleted
				automationManager.MarkHostAsDeleted(projectId, automationHostId, userId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested automation host");
				Logger.Flush();
			}
		}

		#endregion Automation Host methods

		#region Automation Engine functions

		/// <summary>
		/// Retrieves a single automation engine record by its Token
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="token">The token of the engine</param>
		/// <returns>The automation engine data object</returns>
		public RemoteAutomationEngine AutomationEngine_RetrieveByToken(RemoteCredentials credentials, string token)
		{
			const string METHOD_NAME = "AutomationEngine_RetrieveByToken";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Any authenticated user can see the list of automation engines

			//Call the business object to actually retrieve the automation engine dataset
			AutomationManager automationManager = new AutomationManager();

			//If the engine was not found, just return null
			try
			{
				AutomationEngine automationEngine = automationManager.RetrieveEngineByToken(token);

				//Populate the API data object and return
				RemoteAutomationEngine remoteAutomationEngine = new RemoteAutomationEngine();
				PopulationFunctions.PopulateAutomationEngine(remoteAutomationEngine, automationEngine);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteAutomationEngine;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested automation engine");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>Creates a new Automation Engine in the system.</summary>
		/// <param name="remoteEngine">The new automation engine</param>
		/// <param name="credentials">The API credentials</param>
		/// <returns>The newly-created Automation Engine.</returns>
		public RemoteAutomationEngine AutomationEngine_Create(RemoteCredentials credentials, RemoteAutomationEngine remoteEngine)
		{
			const string METHOD_NAME = CLASS_NAME + "AutomationEngine_Create";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have permissions to create automation engines (i.e. is a system admin)
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateAutomationEngines);
			}

			//Create the engine..
			new AutomationManager().InsertEngine(remoteEngine.Name, remoteEngine.Token, remoteEngine.Description, remoteEngine.Active, userId);

			//Call the business object to actually retrieve the automation engine dataset
			AutomationManager automationManager = new AutomationManager();
			List<AutomationEngine> automationEngines = automationManager.RetrieveEngines(true);

			//Populate the API data object and return
			List<RemoteAutomationEngine> remoteAutomationEngines = new List<RemoteAutomationEngine>();
			foreach (AutomationEngine automationEngine in automationEngines.Where(ae => ae.Token == remoteEngine.Token))
			{
				//Create and populate the row
				RemoteAutomationEngine remoteAutomationEngine = new RemoteAutomationEngine();
				PopulationFunctions.PopulateAutomationEngine(remoteAutomationEngine, automationEngine);
				remoteAutomationEngines.Add(remoteAutomationEngine);
			}

			//Withdraw the one we need..
			RemoteAutomationEngine retEngine = null;
			if (remoteAutomationEngines.Where(ae => ae.Token == remoteEngine.Token).Count() == 1)
			{
				retEngine = remoteAutomationEngines.Where(ae => ae.Token == remoteEngine.Token).Single();
			}

			Logger.LogExitingEvent(METHOD_NAME);
			return retEngine;
		}

		/// <summary>
		/// Updates an existing automation engine in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="remoteEngine">The automation engine to update</param>
		public void AutomationEngine_Update(RemoteCredentials credentials, RemoteAutomationEngine remoteEngine)
		{
			const string METHOD_NAME = CLASS_NAME + "AutomationEngine_Update";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure the ID is populated
			if (!remoteEngine.AutomationEngineId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_AutomationEngineIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have permissions to create automation engines (i.e. is a system admin)
			if (!credentials.IsSystemAdmin)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateAutomationEngines);
			}

			try
			{
				//Call the business object to actually retrieve the automation engine
				AutomationManager automationManager = new AutomationManager();
				AutomationEngine automationEngine = automationManager.RetrieveEngineById(remoteEngine.AutomationEngineId.Value);

				//Update the engine
				if (automationEngine != null)
				{
					automationEngine.StartTracking();
					automationEngine.Name = remoteEngine.Name;
					automationEngine.Description = remoteEngine.Description;
					automationEngine.IsActive = remoteEngine.Active;
					automationEngine.Token = remoteEngine.Token;
					automationManager.UpdateEngine(automationEngine, userId);
				}
				Logger.LogExitingEvent(METHOD_NAME);
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of automation engines in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="activeOnly">Do we only want  the active ones</param>
		/// <returns>List of automation engine data objects</returns>
		public List<RemoteAutomationEngine> AutomationEngine_Retrieve(RemoteCredentials credentials, bool activeOnly)
		{
			const string METHOD_NAME = "AutomationEngine_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Any authenticated user can see the list of automation engines

			//Call the business object to actually retrieve the automation engine dataset
			AutomationManager automationManager = new AutomationManager();
			List<AutomationEngine> automationEngines = automationManager.RetrieveEngines(activeOnly);

			//Populate the API data object and return
			List<RemoteAutomationEngine> remoteAutomationEngines = new List<RemoteAutomationEngine>();
			foreach (AutomationEngine automationEngine in automationEngines)
			{
				//Create and populate the row
				RemoteAutomationEngine remoteAutomationEngine = new RemoteAutomationEngine();
				PopulationFunctions.PopulateAutomationEngine(remoteAutomationEngine, automationEngine);
				remoteAutomationEngines.Add(remoteAutomationEngine);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteAutomationEngines;
		}

		/// <summary>
		/// Retrieves a single automation engine record by its ID
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="automationEngineId">The id of the engine</param>
		/// <returns>The automation engine data object</returns>
		public RemoteAutomationEngine AutomationEngine_RetrieveById(RemoteCredentials credentials, int automationEngineId)
		{
			const string METHOD_NAME = "AutomationEngine_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Any authenticated user can see the list of automation engines

			//Call the business object to actually retrieve the automation engine dataset
			AutomationManager automationManager = new AutomationManager();

			//If the engine was not found, just return null
			try
			{
				AutomationEngine automationEngine = automationManager.RetrieveEngineById(automationEngineId);

				//Populate the API data object and return
				RemoteAutomationEngine remoteAutomationEngine = new RemoteAutomationEngine();
				PopulationFunctions.PopulateAutomationEngine(remoteAutomationEngine, automationEngine);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteAutomationEngine;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested automation engine");
				Logger.Flush();
				return null;
			}
		}

		#endregion Automation Engine functions

		#region Build functions

		/// <summary>
		/// Retrieves the list of builds that are associated with a specific Release
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <param name="releaseId">The release we're interested in</param>
		/// <param name="remoteSort">The sort to apply (pass null for default)</param>
		/// <returns>List of builds</returns>
		public List<RemoteBuild> Build_RetrieveByReleaseId(RemoteCredentials credentials, int projectId, int releaseId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = "Build_RetrieveByReleaseId";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view Releases (since builds don't have their own permission)
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewReleases);
			}

			//Extract the filters and sortsfrom the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);
			string sortExpression = "";
			if (remoteSort != null)
			{
				sortExpression = PopulationFunctions.PopulateSort(remoteSort);
			}

			//Call the business object to actually retrieve the list of builds
			BuildManager buildManager = new BuildManager();
			int artifactCount; //Not used
			List<BuildView> builds = buildManager.RetrieveForRelease(projectId, releaseId, sortExpression, startingRow - 1, numberOfRows, filters, 0, out artifactCount);

			//Populate the API data object and return
			List<RemoteBuild> remoteBuilds = new List<RemoteBuild>();
			foreach (BuildView buildView in builds)
			{
				//Need to retrieve the build with its long description
				Build build = buildManager.RetrieveById(buildView.BuildId);

				//Create and populate the row
				RemoteBuild remoteBuild = new RemoteBuild();
				PopulationFunctions.PopulateBuild(remoteBuild, build);
				remoteBuilds.Add(remoteBuild);

				//Now get any revisions and populate
				List<BuildSourceCode> revisions = buildManager.RetrieveRevisionsForBuild(projectId, build.BuildId);
				if (revisions.Count > 0)
				{
					remoteBuild.Revisions = new List<RemoteBuildSourceCode>();
					foreach (BuildSourceCode revision in revisions)
					{
						//Create and populate the row
						RemoteBuildSourceCode remoteBuildSourceCode = new RemoteBuildSourceCode();
						PopulationFunctions.PopulateBuildSourceCode(remoteBuildSourceCode, revision);
						remoteBuild.Revisions.Add(remoteBuildSourceCode);
					}
				}
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteBuilds;
		}

		/// <summary>
		/// Retrieves the list of builds that are associated with a specific Release, without including the build description fields
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <param name="releaseId">The release we're interested in</param>
		/// <param name="remoteSort">The sort to apply (pass null for default)</param>
		/// <returns>List of builds (without empty description fields)</returns>
		public List<RemoteBuild> Build_RetrieveByReleaseId_NoDescription(RemoteCredentials credentials, int projectId, int releaseId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = "Build_RetrieveByReleaseId_NoDescription";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view Releases (since builds don't have their own permission)
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewReleases);
			}

			//Extract the filters and sortsfrom the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);
			string sortExpression = "";
			if (remoteSort != null)
			{
				sortExpression = PopulationFunctions.PopulateSort(remoteSort);
			}

			//Call the business object to actually retrieve the list of builds
			BuildManager buildManager = new BuildManager();
			int artifactCount; //Not used
			List<BuildView> builds = buildManager.RetrieveForRelease(projectId, releaseId, sortExpression, startingRow - 1, numberOfRows, filters, 0, out artifactCount);

			//Populate the API data object and return
			List<RemoteBuild> remoteBuilds = new List<RemoteBuild>();
			foreach (BuildView buildView in builds)
			{
				//Need to retrieve the build with its long description
				Build build = buildManager.RetrieveById(buildView.BuildId);

				//Create and populate the row
				RemoteBuild remoteBuild = new RemoteBuild();
				PopulationFunctions.PopulateBuild(remoteBuild, build);
				//Clear the build description
				remoteBuild.Description = "";
				remoteBuilds.Add(remoteBuild);

				//Now get any revisions and populate
				List<BuildSourceCode> revisions = buildManager.RetrieveRevisionsForBuild(projectId, build.BuildId);
				if (revisions.Count > 0)
				{
					remoteBuild.Revisions = new List<RemoteBuildSourceCode>();
					foreach (BuildSourceCode revision in revisions)
					{
						//Create and populate the row
						RemoteBuildSourceCode remoteBuildSourceCode = new RemoteBuildSourceCode();
						PopulationFunctions.PopulateBuildSourceCode(remoteBuildSourceCode, revision);
						remoteBuild.Revisions.Add(remoteBuildSourceCode);
					}
				}
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteBuilds;
		}

		/// <summary>
		/// Retrieves the a single build (and associated source code revisions) by its id
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="releaseId">The release we're interested in</param>
		/// <param name="buildId">The id of the build to retrieve</param>
		/// <returns>A single build object</returns>
		public RemoteBuild Build_RetrieveById(RemoteCredentials credentials, int projectId, int releaseId, int buildId)
		{
			const string METHOD_NAME = "Build_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view Releases (since builds don't have their own permission)
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewReleases);
			}

			try
			{
				//Call the business object to actually retrieve the build
				BuildManager buildManager = new BuildManager();
				Build build = buildManager.RetrieveById(buildId);

				//Make sure that the project ids match (to avoid returning data to unauthorized users)
				if (build.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteBuild remoteBuild = new RemoteBuild();
				PopulationFunctions.PopulateBuild(remoteBuild, build);

				//Now get any revisions and populate
				List<BuildSourceCode> revisions = buildManager.RetrieveRevisionsForBuild(projectId, build.BuildId);
				if (revisions.Count > 0)
				{
					remoteBuild.Revisions = new List<RemoteBuildSourceCode>();
					foreach (BuildSourceCode revision in revisions)
					{
						//Create and populate the row
						RemoteBuildSourceCode remoteBuildSourceCode = new RemoteBuildSourceCode();
						PopulationFunctions.PopulateBuildSourceCode(remoteBuildSourceCode, revision);
						remoteBuild.Revisions.Add(remoteBuildSourceCode);
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteBuild;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested build");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Retrieves the a single build (and associated source code revisions) by its id, without including the build description field
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="releaseId">The release we're interested in</param>
		/// <param name="buildId">The id of the build to retrieve</param>
		/// <returns>A single build object (with an empty description field)</returns>
		public RemoteBuild Build_RetrieveById_NoDescription(RemoteCredentials credentials, int projectId, int releaseId, int buildId)
		{
			const string METHOD_NAME = "Build_RetrieveById_NoDescription";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view Releases (since builds don't have their own permission)
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewReleases);
			}

			try
			{
				//Call the business object to actually retrieve the build
				BuildManager buildManager = new BuildManager();
				Build build = buildManager.RetrieveById(buildId);

				//Make sure that the project ids match (to avoid returning data to unauthorized users)
				if (build.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the API data object and return
				RemoteBuild remoteBuild = new RemoteBuild();
				PopulationFunctions.PopulateBuild(remoteBuild, build);
				//Clear the build description
				remoteBuild.Description = "";

				//Now get any revisions and populate
				List<BuildSourceCode> revisions = buildManager.RetrieveRevisionsForBuild(projectId, build.BuildId);
				if (revisions.Count > 0)
				{
					remoteBuild.Revisions = new List<RemoteBuildSourceCode>();
					foreach (BuildSourceCode revision in revisions)
					{
						//Create and populate the row
						RemoteBuildSourceCode remoteBuildSourceCode = new RemoteBuildSourceCode();
						PopulationFunctions.PopulateBuildSourceCode(remoteBuildSourceCode, revision);
						remoteBuild.Revisions.Add(remoteBuildSourceCode);
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteBuild;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested build");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Creates a new build in the system, including any linked source code revisions
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="remoteBuild">The new build object (primary key will be empty)</param>
		/// <returns>The populated build object - including the primary key</returns>
		public RemoteBuild Build_Create(RemoteCredentials credentials, RemoteBuild remoteBuild)
		{
			const string METHOD_NAME = "Build_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have an primary key specified
			if (remoteBuild.BuildId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_BuildIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteBuild.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create releases (since builds don't have their own permission)
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Release, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateReleases);
			}

			//See if we have a creation date specified, otherwise use current date/time
			DateTime creationDate = DateTime.UtcNow;
			if (remoteBuild.CreationDate.HasValue)
			{
				creationDate = remoteBuild.CreationDate.Value;
			}

			//First insert the new build record itself, capturing and populating the id
			//Always use the current project (for security) - i.e. projectId not remoteBuild.ProjectId
			BuildManager buildManager = new BuildManager();
			Build build = buildManager.Insert(
			   projectId,
			   remoteBuild.ReleaseId,
			   remoteBuild.Name,
			   remoteBuild.Description,
			   creationDate,
			   (Build.BuildStatusEnum)remoteBuild.BuildStatusId,
			   userId
			   );
			PopulationFunctions.PopulateBuild(remoteBuild, build);

			//Now add the revisions
			if (remoteBuild.Revisions != null)
			{
				foreach (RemoteBuildSourceCode remoteBuildSourceCode in remoteBuild.Revisions)
				{
					//See if we have a creation date specified, otherwise use current date/time
					if (!remoteBuildSourceCode.CreationDate.HasValue)
					{
						remoteBuildSourceCode.CreationDate = DateTime.UtcNow;
					}
					BuildSourceCode buildSourceCode = buildManager.InsertSourceCodeRevision(
						remoteBuild.BuildId.Value,
						remoteBuildSourceCode.RevisionKey,
						remoteBuildSourceCode.CreationDate.Value
					);
				}
			}

			//Finally return the populated data object
			return remoteBuild;
		}

		#endregion Build functions

		#region Source Code functions

		/// <summary>
		/// Returns the source code information for a specific product in Spira
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <returns>The source code information or NULL if no source code providers active</returns>
		public RemoteSourceCodeConnection SourceCode_RetrieveConnectionInformation(RemoteCredentials credentials, int projectId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveConnectionInformation";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Make sure this project is active for source code
				bool isActiveForSourceCode = new SourceCodeManager().IsActiveProvidersForProject(projectId);
				if (!isActiveForSourceCode)
				{
					return null;
				}

				RemoteSourceCodeConnection remoteSourceCodeConnection = new RemoteSourceCodeConnection();
				PopulationFunctions.PopulateSourceCodeConnection(userId, projectId, remoteSourceCodeConnection);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeConnection;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of source code branches in the project
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <returns>The list of branches</returns>
		public List<RemoteSourceCodeBranch> SourceCode_RetrieveBranches(RemoteCredentials credentials, int projectId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveBranches";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the branches
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);
				List<SourceCodeBranch> branches = sourceCodeManager.RetrieveBranches();
				if (branches == null)
				{
					return null;
				}

				//Loop through the data and populate api objects
				List<RemoteSourceCodeBranch> remoteSourceCodeBranches = new List<RemoteSourceCodeBranch>();
				foreach (SourceCodeBranch branch in branches)
				{
					//Populate the API data object and return
					RemoteSourceCodeBranch remoteSourceCodeBranch = new RemoteSourceCodeBranch();
					PopulationFunctions.PopulateSourceCodeBranch(remoteSourceCodeBranch, branch);
					remoteSourceCodeBranches.Add(remoteSourceCodeBranch);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeBranches;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of folders by their parent (unless root)
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the branch</param>
		/// <param name="parentFolderId">The id of the parent folder (or null for root)</param>
		/// <returns>The list of folders</returns>
		public List<RemoteSourceCodeFolder> SourceCode_RetrieveFoldersByParent(RemoteCredentials credentials, int projectId, string branchId, string parentFolderId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveFoldersByParent";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the folders
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);
				int? parentFolderCacheId = null;
				if (!String.IsNullOrEmpty(parentFolderId))
				{
					SourceCodeFolder parentFolder = sourceCodeManager.RetrieveFolderByKey(parentFolderId, branchId);
					parentFolderCacheId = parentFolder.FolderId;
				}
				List<SourceCodeFolder> folders = sourceCodeManager.RetrieveFoldersByParentId(parentFolderCacheId, branchId);
				if (folders == null)
				{
					return null;
				}

				//Loop through the data and populate api objects
				List<RemoteSourceCodeFolder> remoteSourceCodeFolders = new List<RemoteSourceCodeFolder>();
				foreach (SourceCodeFolder folder in folders)
				{
					//Populate the API data object and return
					RemoteSourceCodeFolder remoteSourceCodeFolder = new RemoteSourceCodeFolder();
					PopulationFunctions.PopulateSourceCodeFolder(remoteSourceCodeFolder, folder);
					remoteSourceCodeFolders.Add(remoteSourceCodeFolder);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeFolders;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of files in a specific folder
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the branch</param>
		/// <param name="folderId">The id of the folder</param>
		/// <returns>The list of files</returns>
		public List<RemoteSourceCodeFile> SourceCode_RetrieveFilesByFolder(RemoteCredentials credentials, int projectId, string branchId, string folderId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveFilesByFolder";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the files
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);

				SourceCodeFolder folder = sourceCodeManager.RetrieveFolderByKey(folderId, branchId);
				int folderCacheId = folder.FolderId;
				int count;
				List<SourceCodeFile> files = sourceCodeManager.RetrieveFilesByFolderId(folderCacheId, "Filename", true, 1, Int32.MaxValue, null, out branchId, out count);
				if (files == null)
				{
					return null;
				}

				//Loop through the data and populate api objects
				List<RemoteSourceCodeFile> remoteSourceCodeFiles = new List<RemoteSourceCodeFile>();
				foreach (SourceCodeFile file in files)
				{
					//Populate the API data object and return
					RemoteSourceCodeFile remoteSourceCodeFile = new RemoteSourceCodeFile();
					PopulationFunctions.PopulateSourceCodeFile(remoteSourceCodeFile, file);
					remoteSourceCodeFiles.Add(remoteSourceCodeFile);

					//Add the parent folder
					if (!String.IsNullOrEmpty(folderId))
					{
						remoteSourceCodeFile.ParentFolder = new RemoteSourceCodeFolder();
						remoteSourceCodeFile.ParentFolder.Id = folderId;
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeFiles;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of files contained in a specific revision
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the branch</param>
		/// <param name="revisionId">The id of the revision</param>
		/// <returns>The list of files</returns>
		public List<RemoteSourceCodeFile> SourceCode_RetrieveFilesByRevision(RemoteCredentials credentials, int projectId, string branchId, string revisionId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveFilesByRevision";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the files
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);

				int count;
				List<SourceCodeFile> files = sourceCodeManager.RetrieveFilesForRevision(revisionId, branchId, "Filename", true, 1, Int32.MaxValue, null, out count);
				if (files == null)
				{
					return null;
				}

				//Loop through the data and populate api objects
				List<RemoteSourceCodeFile> remoteSourceCodeFiles = new List<RemoteSourceCodeFile>();
				foreach (SourceCodeFile file in files)
				{
					//Populate the API data object and return
					RemoteSourceCodeFile remoteSourceCodeFile = new RemoteSourceCodeFile();
					PopulationFunctions.PopulateSourceCodeFile(remoteSourceCodeFile, file);
					remoteSourceCodeFiles.Add(remoteSourceCodeFile);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeFiles;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a specific file by its ID
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the branch</param>
		/// <param name="fileId">The id of the file</param>
		/// <returns>The matching file record</returns>
		public RemoteSourceCodeFile SourceCode_RetrieveFileById(RemoteCredentials credentials, int projectId, string branchId, string fileId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveFileById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the files
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);

				SourceCodeFile file = sourceCodeManager.RetrieveFileByKey(fileId, branchId);
				if (file == null)
				{
					return null;
				}

				//Populate the API data object and return
				RemoteSourceCodeFile remoteSourceCodeFile = new RemoteSourceCodeFile();
				PopulationFunctions.PopulateSourceCodeFile(remoteSourceCodeFile, file);

				//Add the parent folder if popululated
				if (file.ParentFolderId.HasValue)
				{
					SourceCodeFolder folder = sourceCodeManager.RetrieveFolderById(file.ParentFolderId.Value, out branchId);
					if (folder != null)
					{
						remoteSourceCodeFile.ParentFolder = new RemoteSourceCodeFolder();
						remoteSourceCodeFile.ParentFolder.Id = folder.FolderKey;
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeFile;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of files associated with a specific artifact
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the branch</param>
		/// <param name="artifactTypeId">The id of the type of artifact</param>
		/// <param name="artifactId">The id of the artifact</param>
		/// <returns>The list of associated files</returns>
		public List<RemoteSourceCodeFile> SourceCode_RetrieveFilesForArtifact(RemoteCredentials credentials, int projectId, string branchId, int artifactTypeId, int artifactId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveFilesForArtifact";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the files
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);

				List<SourceCodeFile> files = sourceCodeManager.RetrieveFilesForArtifact((Artifact.ArtifactTypeEnum)artifactTypeId, artifactId);
				if (files == null)
				{
					return null;
				}

				//Loop through the data and populate api objects
				List<RemoteSourceCodeFile> remoteSourceCodeFiles = new List<RemoteSourceCodeFile>();
				foreach (SourceCodeFile file in files)
				{
					//Populate the API data object and return
					RemoteSourceCodeFile remoteSourceCodeFile = new RemoteSourceCodeFile();
					PopulationFunctions.PopulateSourceCodeFile(remoteSourceCodeFile, file);
					remoteSourceCodeFiles.Add(remoteSourceCodeFile);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeFiles;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Returns the physical contents of a file in a linked source code repository
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the branch</param>
		/// <param name="fileId">The id of the file</param>
		/// <param name="revisionId">The id of the revision, or null for the lastest revision</param>
		/// <returns>The contents of the file</returns>
		public byte[] SourceCode_OpenFileById(RemoteCredentials credentials, int projectId, string branchId, string fileId, string revisionId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveFileById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the files
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);

				SourceCodeFileStream fileStream = sourceCodeManager.OpenFile(fileId, revisionId, branchId);
				if (fileStream == null)
				{
					return null;
				}

				//Populate the raw data and return
				Stream stream = fileStream.DataStream;

				//Read the file in.
				byte[] binaryData = new byte[stream.Length];
				stream.Read(binaryData, 0, (int)stream.Length);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return binaryData;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a sorted, filtered, paginated list of revisions in the repository
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the branch</param>
		/// <param name="startRow">The starting row</param>
		/// <param name="numberRows">The number of rows to return</param>
		/// <param name="remoteSort">The sort to use</param>
		/// <param name="remoteFilters">Any filters to apply</param>
		/// <returns>The list of revisions</returns>
		public List<RemoteSourceCodeRevision> SourceCode_RetrieveRevisions(RemoteCredentials credentials, int projectId, string branchId, int startRow, int numberRows, RemoteSort remoteSort, List<RemoteFilter> remoteFilters)
		{
			const string METHOD_NAME = "SourceCode_RetrieveRevisions";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Convert the filters
				Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

				//Call the business object to actually retrieve the files
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);

				int count;
				List<SourceCodeCommit> commits = sourceCodeManager.RetrieveRevisions(branchId, remoteSort.PropertyName, remoteSort.SortAscending, startRow, numberRows, filters, 0, out count);
				if (commits == null)
				{
					return null;
				}

				//Loop through the data and populate api objects
				List<RemoteSourceCodeRevision> remoteSourceCodeRevisions = new List<RemoteSourceCodeRevision>();
				foreach (SourceCodeCommit commit in commits)
				{
					//Populate the API data object and return
					RemoteSourceCodeRevision remoteSourceCodeRevision = new RemoteSourceCodeRevision();
					PopulationFunctions.PopulateSourceCodeRevision(remoteSourceCodeRevision, commit);
					remoteSourceCodeRevisions.Add(remoteSourceCodeRevision);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeRevisions;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of revisions for a specific file
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the branch</param>
		/// <param name="fileId">The id of the file</param>
		/// <returns>The list of revisions</returns>
		public List<RemoteSourceCodeRevision> SourceCode_RetrieveRevisionsForFile(RemoteCredentials credentials, int projectId, string branchId, string fileId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveRevisionsForFile";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the files
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);

				int count;
				List<SourceCodeCommit> commits = sourceCodeManager.RetrieveRevisionsForFile(fileId, branchId, "LastUpdated", false, 1, Int32.MaxValue, null, 0, out count);
				if (commits == null)
				{
					return null;
				}

				//Loop through the data and populate api objects
				List<RemoteSourceCodeRevision> remoteSourceCodeRevisions = new List<RemoteSourceCodeRevision>();
				foreach (SourceCodeCommit commit in commits)
				{
					//Populate the API data object and return
					RemoteSourceCodeRevision remoteSourceCodeRevision = new RemoteSourceCodeRevision();
					PopulationFunctions.PopulateSourceCodeRevision(remoteSourceCodeRevision, commit);
					remoteSourceCodeRevisions.Add(remoteSourceCodeRevision);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeRevisions;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a revision by its ID
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the branch</param>
		/// <param name="revisionId">The id of the revision</param>
		/// <returns>The revision information</returns>
		public RemoteSourceCodeRevision SourceCode_RetrieveRevisionById(RemoteCredentials credentials, int projectId, string branchId, string revisionId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveRevisionById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the revision
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);

				SourceCodeCommit commit = sourceCodeManager.RetrieveRevisionByKey(revisionId);
				if (commit == null)
				{
					return null;
				}

				//Populate the API data object and return
				RemoteSourceCodeRevision remoteSourceCodeRevision = new RemoteSourceCodeRevision();
				PopulationFunctions.PopulateSourceCodeRevision(remoteSourceCodeRevision, commit);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeRevision;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of revisions associated with a specific artifact
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the specific branch (ignored)</param>
		/// <param name="artifactTypeId">The id of the type of artifact</param>
		/// <param name="artifactId">The id of the artifact</param>
		/// <returns>The list of revisions associated</returns>
		public List<RemoteSourceCodeRevision> SourceCode_RetrieveRevisionsForArtifact(RemoteCredentials credentials, int projectId, string branchId, int artifactTypeId, int artifactId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveRevisionsForArtifact";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the files
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);

				List<SourceCodeCommit> commits = sourceCodeManager.RetrieveRevisionsForArtifact((Artifact.ArtifactTypeEnum)artifactTypeId, artifactId);
				if (commits == null)
				{
					return null;
				}

				//Loop through the data and populate api objects
				List<RemoteSourceCodeRevision> remoteSourceCodeRevisions = new List<RemoteSourceCodeRevision>();
				foreach (SourceCodeCommit commit in commits)
				{
					//Populate the API data object and return
					RemoteSourceCodeRevision remoteSourceCodeRevision = new RemoteSourceCodeRevision();
					PopulationFunctions.PopulateSourceCodeRevision(remoteSourceCodeRevision, commit);
					remoteSourceCodeRevisions.Add(remoteSourceCodeRevision);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSourceCodeRevisions;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of artifacts associated with a specific revision
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="branchId">The id of the branch</param>
		/// <param name="revisionId">The id of the revision</param>
		/// <returns>The list of linked artifacts</returns>
		public List<RemoteLinkedArtifact> SourceCode_RetrieveArtifactsForRevision(RemoteCredentials credentials, int projectId, string branchId, string revisionId)
		{
			const string METHOD_NAME = "SourceCode_RetrieveArtifactsForRevision";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we're allowed to view source code in this project
			if (!credentials.IsSystemAdmin)
			{
				Business.ProjectManager projectManager = new Business.ProjectManager();
				ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
				ProjectRole projectRole = projectManager.RetrieveRolePermissions(projectUser.ProjectRoleId);
				bool hasPermissions = false;
				if (projectRole != null && projectRole.IsSourceCodeView)
				{
					hasPermissions = true;
				}
				if (!hasPermissions)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
				}
			}

			try
			{
				//Call the business object to actually retrieve the files
				SourceCodeManager sourceCodeManager = new SourceCodeManager(projectId);

				List<ArtifactLinkView> artifactLinks = sourceCodeManager.RetrieveAssociationsForRevision(revisionId);
				if (artifactLinks == null)
				{
					return null;
				}

				//Loop through the data and populate api objects
				List<RemoteLinkedArtifact> remoteLinkedArtifacts = new List<RemoteLinkedArtifact>();
				foreach (ArtifactLinkView artifactLink in artifactLinks)
				{
					//Populate the API data object and return
					RemoteLinkedArtifact remoteLinkedArtifact = new RemoteLinkedArtifact();
					PopulationFunctions.PopulateArtifactLink(remoteLinkedArtifact, artifactLink);
					remoteLinkedArtifacts.Add(remoteLinkedArtifact);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteLinkedArtifacts;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		#endregion

		#region Message functions

		/// <summary>
		/// Retrieves the IM status for the current user
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <returns>The message status info</returns>
		public RemoteMessageInfo Message_GetInfo(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Message_GetInfo";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have SpiraPlan/SpiraTeam
			if (License.LicenseProductName == LicenseProductNameEnum.SpiraTest)
			{
				throw CreateFault("FeatureNotAvailable", Resources.Messages.Services_InvalidLicense);
			}

			//We don't need to check project permissions since these are their own saved filters
			try
			{
				RemoteMessageInfo messageInfo = new RemoteMessageInfo();

				//Get the number of unread messages
				User user = new UserManager().GetUserById(userId);
				if (user.Profile != null)
				{
					messageInfo.UnreadMessages = user.Profile.UnreadMessages;
				}

				//See if the user is in the hashtable of active user sessions
				messageInfo.OnlineUsers = Global.GetActiveUserIds();

				//Finally see if we need to purge old messages
				if (DateTime.UtcNow.AddDays(-ConfigurationSettings.Default.Message_RetentionPeriod) > ConfigurationSettings.Default.Message_LastPurgeAttempt)
				{
					new MessageManager().Message_PurgeOld();
					ConfigurationSettings.Default.Message_LastPurgeAttempt = DateTime.UtcNow;
					ConfigurationSettings.Default.Save();
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				return messageInfo;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Posts a new message to a specific recipient
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="recipientUserId">The id of the recipient</param>
		/// <param name="messageText">The message text</param>
		public long Message_PostNew(RemoteCredentials credentials, int recipientUserId, string messageText)
		{
			const string METHOD_NAME = "Message_PostNew";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have SpiraPlan/SpiraTeam
			if (License.LicenseProductName == LicenseProductNameEnum.SpiraTest)
			{
				throw CreateFault("FeatureNotAvailable", Resources.Messages.Services_InvalidLicense);
			}

			//We don't need to check project permissions since these are their own saved filters
			try
			{
				//Make sure the user exists and is active
				User user = new UserManager().GetUserById(recipientUserId);
				long messageId = -1;
				if (user != null)
				{
					Message message = new MessageManager().Message_Create(userId, recipientUserId, messageText);
					messageId = message.MessageId;
				}
				return messageId;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Marks all the messages as read for a specific sending user
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="senderUserId">The id of the user</param>
		public void Message_MarkAllAsRead(RemoteCredentials credentials, int senderUserId)
		{
			const string METHOD_NAME = "Message_MarkAllAsRead";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have SpiraPlan/SpiraTeam
			if (License.LicenseProductName == LicenseProductNameEnum.SpiraTest)
			{
				throw CreateFault("FeatureNotAvailable", Resources.Messages.Services_InvalidLicense);
			}

			//We don't need to check project permissions since these are their own saved filters
			try
			{
				//Get all the unread messages from that person
				MessageManager messageManager = new MessageManager();
				List<Message> messages = messageManager.Message_RetrieveUnread(userId);
				foreach (Message message in messages)
				{
					//If it's from the specified sender, mark as unread
					if (message.SenderUserId == senderUserId)
					{
						messageManager.Message_MarkAsRead(message.MessageId);
					}
				}
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Gets the list of users and number of unread messages from them
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <returns>The list of users and unread messages</returns>
		public List<RemoteUserMessage> Message_GetUnreadMessageSenders(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Message_GetUnreadMessageSenders";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have SpiraPlan/SpiraTeam
			if (License.LicenseProductName == LicenseProductNameEnum.SpiraTest)
			{
				throw CreateFault("FeatureNotAvailable", Resources.Messages.Services_InvalidLicense);
			}

			//We don't need to check project permissions since these are their own saved filters
			try
			{
				List<RemoteUserMessage> remoteUserMessages = new List<RemoteUserMessage>();

				//Get the list of unread messages for this user
				List<Message> unreadMessages = new MessageManager().Message_RetrieveUnread(userId);
				foreach (Message message in unreadMessages)
				{
					RemoteUserMessage remoteUserMessage = remoteUserMessages.FirstOrDefault(m => m.UserId == message.SenderUserId);
					if (remoteUserMessage == null)
					{
						remoteUserMessage = new RemoteUserMessage();
						remoteUserMessage.UserId = message.SenderUserId;
						remoteUserMessage.UnreadMessages = 1;
						remoteUserMessages.Add(remoteUserMessage);
					}
					else
					{
						remoteUserMessage.UnreadMessages++;
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				return remoteUserMessages;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of unread messages
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <returns>List of unread messages</returns>
		public List<RemoteMessage> Message_RetrieveUnread(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Message_RetrieveUnread";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we have SpiraPlan/SpiraTeam
			if (License.LicenseProductName == LicenseProductNameEnum.SpiraTest)
			{
				throw CreateFault("FeatureNotAvailable", Resources.Messages.Services_InvalidLicense);
			}

			//We don't need to check project permissions since these are their own saved filters
			try
			{
				//Get a list of the messages between the two users
				MessageManager messageManager = new MessageManager();
				List<Message> messages = messageManager.Message_RetrieveUnread(userId);

				if (messages == null || messages.Count == 0)
				{
					return null;
				}

				//Return the API data object
				List<RemoteMessage> remoteMessages = new List<RemoteMessage>();
				foreach (Message message in messages)
				{
					RemoteMessage remoteMessage = new RemoteMessage();
					PopulationFunctions.PopulateMessage(remoteMessage, message);
					remoteMessages.Add(remoteMessage);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				return remoteMessages;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		#endregion

		#region History functions

		/// <summary>
		/// Retrieves the history of changes for a specific artifact
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="artifactTypeId">The type of artifact</param>
		/// <param name="artifactId">The id of the artifact</param>
		/// <param name="startingRow">The starting row (starting at 1)</param>
		/// <param name="numberOfRows">The number of rows to retrieve</param>
		/// <param name="remoteSort">The field and direction to sort by</param>
		/// <param name="remoteFilters">Any filters to apply</param>
		/// <returns>The list of changes</returns>
		/// <remarks>Includes the field-level details of each change</remarks>
		public List<RemoteHistoryChange> History_RetrieveForArtifact(RemoteCredentials credentials, int projectId, int artifactTypeId, int artifactId, int startingRow, int numberOfRows, RemoteSort remoteSort, List<RemoteFilter> remoteFilters)
		{
			const string METHOD_NAME = "History_RetrieveForArtifact";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//Make sure we have permissions to view the artifact type in this project
			if (!IsAuthorized(credentials, projectId, (Artifact.ArtifactTypeEnum)artifactTypeId, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				//Extract the filters from the provided API object
				Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

				//Call the business object to actually retrieve the history changesets
				HistoryManager historyManager = new HistoryManager();
				List<HistoryChangeView> historyChanges = historyManager.RetrieveByArtifactId(projectId, artifactId, (Artifact.ArtifactTypeEnum)artifactTypeId, remoteSort.PropertyName, remoteSort.SortAscending, filters, startingRow, numberOfRows, 0, true);

				//Populate the API objects
				List<RemoteHistoryChange> remoteHistoryChanges = new List<RemoteHistoryChange>();
				foreach (HistoryChangeView historyChangeView in historyChanges)
				{
					RemoteHistoryChange remoteHistoryChange = new RemoteHistoryChange();
					PopulationFunctions.PopulateHistoryChangeSet(remoteHistoryChange, historyChangeView);
					remoteHistoryChanges.Add(remoteHistoryChange);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteHistoryChanges;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}
		/// <summary>
		/// Retrieves the details of a specific change made
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="historyChangeSetId">The id of the change</param>
		/// <returns>The details of the change</returns>
		/// <remarks>Includes the field-level details of each change</remarks>
		public RemoteHistoryChangeSet History_RetrieveById(RemoteCredentials credentials, int projectId, int historyChangeSetId)
		{
			const string METHOD_NAME = "History_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			try
			{
				//Call the business object to actually retrieve the history changesets
				HistoryManager historyManager = new HistoryManager();
				HistoryChangeSet historyChangeSet = historyManager.RetrieveChangeSetById(historyChangeSetId, true);
				RemoteHistoryChangeSet remoteHistoryChangeSet = null;

				if (historyChangeSet != null)
				{
					remoteHistoryChangeSet = new RemoteHistoryChangeSet();
					//Make sure we have permissions to view the artifact type in this project
					if (!IsAuthorized(credentials, projectId, (Artifact.ArtifactTypeEnum)historyChangeSet.ArtifactTypeId, Project.PermissionEnum.View))
					{
						//Throw back an exception
						Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
						Logger.Flush();

						throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
					}

					//Populate the API objects
					PopulationFunctions.PopulateHistoryChangeSet(remoteHistoryChangeSet, historyChangeSet);

					if (historyChangeSet.Details.Count > 0)
					{
						remoteHistoryChangeSet.Changes = new List<RemoteHistoryChange>();
						foreach (HistoryDetail historyDetail in historyChangeSet.Details)
						{
							RemoteHistoryChange remoteHistoryChange = new RemoteHistoryChange();
							PopulationFunctions.PopulateHistoryChange(remoteHistoryChange, historyDetail);
							remoteHistoryChangeSet.Changes.Add(remoteHistoryChange);
						}
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteHistoryChangeSet;
			}
			catch (Exception exception)
			{
				//Log and then rethrow the converted exception
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		#endregion

		#region Subscription functions

		/// <summary>
		/// Subscribes to a specified artifact
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="artifactTypeId">The type of artifact</param>
		/// <param name="artifactId">The id of the artifact</param>
		public void Subscription_SubscribeToArtifact(RemoteCredentials credentials, int projectId, int artifactTypeId, int artifactId)
		{
			const string METHOD_NAME = "Subscription_SubscribeToArtifact";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Need to verify the user has permissions to see this artifact
			if (!new ArtifactManager().VerifyArtifactExists((Artifact.ArtifactTypeEnum)artifactTypeId, artifactId, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			//Make sure we have permissions to view the artifact
			if (!IsAuthorized(credentials, projectId, (Artifact.ArtifactTypeEnum)artifactTypeId, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				//Subscribe for this user
				NotificationManager notificationManager = new NotificationManager();
				notificationManager.AddUserSubscription(userId, artifactTypeId, artifactId);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Unsubscribes from a specified artifact
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="artifactTypeId">The type of artifact</param>
		/// <param name="artifactId">The id of the artifact</param>
		public void Subscription_UnsubscribeFromArtifact(RemoteCredentials credentials, int projectId, int artifactTypeId, int artifactId)
		{
			const string METHOD_NAME = "Subscription_UnsubscribeFromArtifact";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Need to verify the user has permissions to see this artifact
			if (!new ArtifactManager().VerifyArtifactExists((Artifact.ArtifactTypeEnum)artifactTypeId, artifactId, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			//Make sure we have permissions to view the artifact
			if (!IsAuthorized(credentials, projectId, (Artifact.ArtifactTypeEnum)artifactTypeId, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				//Subscribe for this user
				NotificationManager notificationManager = new NotificationManager();
				notificationManager.RemoveUserSubscription(userId, artifactTypeId, artifactId);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of all the items the current user is subscribed to (all projects)
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <returns>The list of artifacts</returns>
		public List<RemoteArtifactSubscription> Subscription_RetrieveForUser(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Subscription_RetrieveForUser";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//We don't need to check project permissions since these are their own subscriptions
			try
			{
				//Retrieve this user's subscriptions for all projects
				NotificationManager notificationManager = new NotificationManager();
				List<NotificationUserSubscriptionView> subscriptions = notificationManager.RetrieveSubscriptionsForUser(userId, null);

				//Populate the API data object and return
				List<RemoteArtifactSubscription> remoteArtifactSubscriptions = new List<RemoteArtifactSubscription>();
				foreach (NotificationUserSubscriptionView subscription in subscriptions)
				{
					//Create and populate the row
					RemoteArtifactSubscription remoteArtifactSubscription = new RemoteArtifactSubscription();
					remoteArtifactSubscription.ArtifactId = subscription.ArtifactId;
					remoteArtifactSubscription.ArtifactTypeId = subscription.ArtifactTypeId;
					remoteArtifactSubscription.ArtifactName = subscription.ArtifactName;
					remoteArtifactSubscription.ArtifactDescription = subscription.ArtifactDescription;
					remoteArtifactSubscription.ArtifactTypeName = subscription.ArtifactTypeName;
					remoteArtifactSubscription.ProjectId = subscription.ProjectId;
					remoteArtifactSubscription.ProjectName = subscription.ProjectName;
					remoteArtifactSubscription.UserId = subscription.UserId;
					remoteArtifactSubscription.LastUpdateDate = subscription.LastUpdateDate;
					remoteArtifactSubscriptions.Add(remoteArtifactSubscription);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteArtifactSubscriptions;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a list of all the users subscribed to an artifact
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="artifactTypeId">The type of artifact</param>
		/// <param name="artifactId">The id of the artifact</param>
		/// <returns>The list of users</returns>
		public List<RemoteArtifactSubscription> Subscription_RetrieveForArtifact(RemoteCredentials credentials, int projectId, int artifactTypeId, int artifactId)
		{
			const string METHOD_NAME = "Subscription_RetrieveForUser";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Need to verify the user has permissions to see this artifact
			if (!new ArtifactManager().VerifyArtifactExists((Artifact.ArtifactTypeEnum)artifactTypeId, artifactId, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			//Make sure we have permissions to view the artifact
			if (!IsAuthorized(credentials, projectId, (Artifact.ArtifactTypeEnum)artifactTypeId, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewArtifact);
			}

			try
			{
				//Retrieve this user's subscriptions for all projects
				NotificationManager notificationManager = new NotificationManager();
				List<NotificationUserSubscription> subscriptions = notificationManager.RetrieveSubscriptionsForArtifact(artifactTypeId, artifactId);

				//Populate the API data object and return
				List<RemoteArtifactSubscription> remoteArtifactSubscriptions = new List<RemoteArtifactSubscription>();
				foreach (NotificationUserSubscription subscription in subscriptions)
				{
					//Create and populate the row
					RemoteArtifactSubscription remoteArtifactSubscription = new RemoteArtifactSubscription();
					remoteArtifactSubscription.ArtifactId = subscription.ArtifactId;
					remoteArtifactSubscription.ArtifactTypeId = subscription.ArtifactTypeId;
					remoteArtifactSubscription.UserId = subscription.UserId;
					if (subscription.User != null)
					{
						remoteArtifactSubscription.UserFullName = subscription.User.FullName;
					}
					remoteArtifactSubscriptions.Add(remoteArtifactSubscription);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteArtifactSubscriptions;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		#endregion

		#region Saved Filter functions

		/// <summary>
		/// Retrieves the list of saved filters for the current user (all projects)
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <returns>The list of saved filters</returns>
		public List<RemoteSavedFilter> SavedFilter_RetrieveForUser(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "SavedFilter_RetrieveForUser";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//We don't need to check project permissions since these are their own saved filters
			try
			{
				//Retrieve this user's saved filters for all projects
				SavedFilterManager savedFilterManager = new SavedFilterManager();
				List<DataModel.SavedFilter> savedFilters = savedFilterManager.Retrieve(userId, null);

				//Populate the API data object and return
				List<RemoteSavedFilter> remoteSavedFilters = new List<RemoteSavedFilter>();
				foreach (DataModel.SavedFilter savedFilter in savedFilters)
				{
					//Create and populate the row
					RemoteSavedFilter remoteSavedFilter = new RemoteSavedFilter();
					remoteSavedFilter.SavedFilterId = savedFilter.SavedFilterId;
					remoteSavedFilter.ArtifactTypeId = savedFilter.ArtifactTypeId;
					remoteSavedFilter.IsShared = savedFilter.IsShared;
					remoteSavedFilter.ProjectId = savedFilter.ProjectId;
					remoteSavedFilter.ArtifactTypeName = savedFilter.ArtifactTypeName;
					remoteSavedFilter.ProjectName = savedFilter.ProjectName;
					remoteSavedFilter.Name = savedFilter.Name;
					remoteSavedFilters.Add(remoteSavedFilter);

					//Now actually restore the filter and populate
					DataModel.SavedFilter savedFilterDetails = savedFilterManager.RetrieveById(savedFilter.SavedFilterId);
					if (savedFilterDetails != null)
					{
						remoteSavedFilter.Filters = new List<RemoteFilter>();
						foreach (DataModel.SavedFilterEntry savedFilterEntry in savedFilterDetails.Entries)
						{
							RemoteFilter remoteFilter = new RemoteFilter();
							PopulationFunctions.PopulateFilters(remoteFilter, savedFilterEntry, savedFilterManager);
							remoteSavedFilter.Filters.Add(remoteFilter);
						}
					}
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSavedFilters;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		#endregion

		#region User Contacts

		/// <summary>
		/// Retrieves the list of contacts for the current user
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <returns></returns>
		public List<RemoteUser> User_RetrieveContacts(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "User_RetrieveContacts";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//As long as they are authenticatd, we can return the contact list
			try
			{
				//Call the business object to actually retrieve the contacts
				List<User> users = new UserManager().UserContact_Retrieve(userId);

				//Populate the API data object and return
				List<RemoteUser> remoteUsers = new List<RemoteUser>();
				foreach (User user in users)
				{
					//Create and populate the row
					RemoteUser remoteUser = new RemoteUser();
					PopulationFunctions.PopulateUser(remoteUser, user, false);
					remoteUsers.Add(remoteUser);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteUsers;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Adds a user as a contact
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="userId">The id of the user</param>
		public void User_AddContact(RemoteCredentials credentials, int userId)
		{
			const string METHOD_NAME = "User_AddContact";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int authenticatedUserId = credentials.UserId;

			//We need to make sure the user being added is a member of a project the current user is a member of
			try
			{
				//Get the user membership of both users
				UserManager userManager = new UserManager();
				ProjectManager projectManager = new ProjectManager();
				List<ProjectForUserView> projectUsers1 = projectManager.RetrieveForUser(authenticatedUserId);
				List<ProjectForUserView> projectUsers2 = projectManager.RetrieveForUser(userId);

				//See if at least one project is shared by the two users
				if (projectUsers2.Any(p => projectUsers1.Any(q => q.ProjectId == p.ProjectId)))
				{
					//Call the business object to actually add the contact
					userManager.UserContact_Add(authenticatedUserId, userId);
				}
				else
				{
					throw CreateFault("NotAuthorizedAddContact", Resources.Messages.Services_NotAuthorizedAddContact);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Removes a user as a contact
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="userId">The id of the user</param>
		public void User_RemoveContact(RemoteCredentials credentials, int userId)
		{
			const string METHOD_NAME = "User_RemoveContact";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int authenticatedUserId = credentials.UserId;

			//As long as they are authenticatd, we can always remove someone
			try
			{
				//Call the business object to actually remove the contact
				new UserManager().UserContact_Remove(authenticatedUserId, userId);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		#endregion

		#region Reports

		/// <summary>
		/// Returns the grid of data from a specific custom graph created by an administrator
		/// </summary>
		/// <remarks>
		/// You need to be a system administrator to be able to call this API method
		/// (for safety since query can be across all artifacts, projects and programs).
		/// </remarks>
		/// <param name="credentials">The API credentials</param>
		/// <param name="customGraphId">The id of the custom graph to get the data for</param>
		/// <param name="projectId">The id of the project to pass to the report</param>
		/// <param name="projectGroupId">The id of the program to pass to the report</param>
		/// <returns>The graph data</returns>
		public RemoteTableData Reports_RetrieveCustomGraphData(RemoteCredentials credentials, int customGraphId, int? projectId, int? projectGroupId)
		{
			const string METHOD_NAME = "Reports_RetrieveCustomGraphData";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//If we have a project id, need to be a project admin
			if (projectId.HasValue && !IsAuthorized(credentials, projectId.Value, DataModel.Artifact.ArtifactTypeEnum.None, Project.PermissionEnum.ProjectAdmin))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.Services_NotAuthorizedViewProject, projectId.Value));
			}

			//If we have a project group id, need to be a member of the group with a role
			if (projectGroupId.HasValue && !IsAuthorizedForGroup(credentials, projectGroupId.Value))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", String.Format(Resources.Messages.Services_NotAuthorizedViewProjectGroup, projectGroupId.Value));
			}

			//We need to be a system or report admin as well for all queries regardless
			//DO NOT CHANGE THIS
			if (!credentials.IsSystemAdmin && !IsReportAdmin(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewSystemWideData);
			}

			try
			{
				RemoteTableData remoteTableData = new RemoteTableData();

				//Now execute the graph and get back the data
				GraphManager graphManager = new GraphManager();
				DataTable dataTable = graphManager.GraphCustom_ExecuteSQL((projectId.HasValue) ? projectId.Value : 0, (projectGroupId.HasValue) ? projectGroupId.Value : 0, customGraphId);

				//Convert the data and return
				PopulationFunctions.PopulateDataTable(remoteTableData, dataTable);
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTableData;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Returns the grid of data from a specific custom graph created by an administrator
		/// </summary>
		/// <remarks>
		/// You need to be a system administrator to be able to call this API method
		/// (for safety since query can be across all artifacts, projects and programs).
		/// </remarks>
		/// <param name="credentials">The API credentials</param>
		/// <param name="query">The ESQL Query</param>
		/// <returns>The report data</returns>
		public RemoteTableData Reports_RetrieveESQLQueryData(RemoteCredentials credentials, string query)
		{
			const string METHOD_NAME = "Reports_RetrieveESQLQueryData";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//We need to be a system or report admin as well for all queries regardless
			//DO NOT CHANGE THIS
			if (!credentials.IsSystemAdmin && !IsReportAdmin(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewSystemWideData);
			}

			try
			{
				RemoteTableData remoteTableData = new RemoteTableData();

				//Now execute the report and get back the data
				ReportManager reportManager = new ReportManager();
				System.Xml.XmlDocument xmlDocument = reportManager.ReportCustomSection_ExecuteSQL(0, 0, query, null);

				//Convert the data and return
				PopulationFunctions.PopulateDataTable(remoteTableData, xmlDocument);
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteTableData;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of saved reports for a specific user
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="includeShared">Should we include saved reports shared by other users</param>
		/// <returns>List of saved reports</returns>
		public List<RemoteSavedReport> Reports_RetrieveSaved(RemoteCredentials credentials, int projectId, bool includeShared)
		{
			const string METHOD_NAME = "Reports_RetrieveESQLQueryData";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			try
			{
				//Retrieve the saved reports
				ReportManager reportManager = new ReportManager();
				List<SavedReportView> savedReports = reportManager.RetrieveSaved(userId, projectId, includeShared);

				//Convert the data and return
				List<RemoteSavedReport> remoteSavedReports = new List<RemoteSavedReport>();
				foreach (SavedReportView savedReport in savedReports)
				{
					RemoteSavedReport remoteSavedReport = new RemoteSavedReport();
					PopulationFunctions.PopulateSavedReports(remoteSavedReport, savedReport);
					remoteSavedReports.Add(remoteSavedReport);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteSavedReports;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Starts the generation of a specific user's saved report
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="savedReportId">The id of the saved report</param>
		/// <remarks>
		/// This API call is currently limited to system administrators because of the potential performance impact of running large reports
		/// </remarks>
		/// <returns>The id of the report generation id (used to check status and retrieve it)</returns>
		public Guid Reports_GenerateSavedReport(RemoteCredentials credentials, int projectId, int savedReportId)
		{
			const string METHOD_NAME = "Reports_GenerateSavedReport";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//We need to be a system or report admin as well for all queries regardless
			//DO NOT CHANGE THIS
			if (!credentials.IsSystemAdmin && !IsReportAdmin(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewSystemWideData);
			}

			try
			{
				//Retrieve the saved report
				ReportManager reportManager = new ReportManager();
				SavedReportView savedReport = reportManager.RetrieveSavedById(savedReportId);

				//Make sure the user has access to it
				if (savedReport.ProjectId != projectId || (savedReport.UserId != userId && !savedReport.IsShared))
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedToGenerateThisReport);
				}

				//Generate the report from the saved report as a background process
				string appRootPath = HttpContext.Current.Server.MapPath("~");
				string timezoneId = SpiraContext.Current.TimezoneId;
				string themeName = GlobalFunctions.DEFAULT_THEME;
				Guid reportGenerationId = reportManager.GenerateSavedReport(userId, projectId, savedReportId, timezoneId, themeName, appRootPath);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return reportGenerationId;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Checks on the status of the generation of a specific user's saved report
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="reportGenerationId">The guid of the report generation request</param>
		/// <remarks>
		/// This API call is currently limited to system administrators because of the potential performance impact of running large reports
		/// </remarks>
		/// <returns>
		/// -1 = Report Generation Not Found / Cancelled
		/// 0 = Report Generation In Progress
		/// other = ID of Report that was Generated (Completed)
		/// </returns>
		public int Reports_CheckGeneratedReportStatus(RemoteCredentials credentials, int projectId, Guid reportGenerationId)
		{
			const string METHOD_NAME = "Reports_CheckGeneratedReportStatus";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//We need to be a system or report admin as well for all queries regardless
			//DO NOT CHANGE THIS
			if (!credentials.IsSystemAdmin && !IsReportAdmin(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewSystemWideData);
			}

			try
			{
				//Check on the status of the generating report
				ReportManager reportManager = new ReportManager();
				int? generatedReportId = reportManager.CheckStatusOfGeneratingReport(reportGenerationId);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				if (generatedReportId.HasValue)
				{
					return generatedReportId.Value;
				}
				else
				{
					return 0;   //In Progress
				}
			}
			catch (ArtifactNotExistsException)
			{
				return -1;  //Not Found
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the contents of the generated report
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The id of the project</param>
		/// <param name="generatedReportId">The id of the generated report</param>
		/// <remarks>
		/// This API call is currently limited to system administrators because of the potential performance impact of running large reports
		/// </remarks>
		/// <returns>
		/// The contents of the report in binary form
		/// </returns>
		public byte[] Reports_RetrieveGeneratedReport(RemoteCredentials credentials, int projectId, int generatedReportId)
		{
			const string METHOD_NAME = "Reports_RetrieveGeneratedReport";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}

			//We need to be a system or report admin as well for all queries regardless
			//DO NOT CHANGE THIS
			if (!credentials.IsSystemAdmin && !IsReportAdmin(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewSystemWideData);
			}

			try
			{
				//Retrieve the generated report
				ReportManager reportManager = new ReportManager();
				ReportGenerated reportGenerated = reportManager.ReportGenerated_RetrieveById(generatedReportId);

				//Make sure it exists
				if (reportGenerated == null)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("ArtifactNotFound", Resources.Messages.Services_ArtifactNotFound);
				}

				//Make sure the user was the one who generated
				if (reportGenerated.UserId != userId)
				{
					//Throw back an exception
					Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
					Logger.Flush();

					throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedToGenerateThisReport);
				}

				//Get the actual binary data
				byte[] reportData = reportManager.GetReportData(generatedReportId);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return reportData;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				Logger.Flush();
				throw ConvertExceptions(exception);
			}
		}

		#endregion

		#region Risk functions

		/// <summary>Returns the number of risks that match the filter.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <returns>The number of items.</returns>
		public long Risk_Count(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters)
		{
			const string METHOD_NAME = CLASS_NAME + "Risk_Count";
			Logger.LogEnteringEvent(METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view incidents
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(METHOD_NAME);
				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewIncidents);
			}

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the risk dataset
			long retNum = new RiskManager().Risk_Count(projectId, filters, 0);

			Logger.LogExitingEvent(METHOD_NAME);
			return retNum;
		}

		/// <summary>
		/// Retrieves a list of risks in the system that match the provided filter/sort
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteFilters">The list of filters to apply</param>
		/// <param name="remoteSort">The sort to apply</param>
		/// <param name="numberOfRows">The number of rows to return</param>
		/// <param name="startingRow">The first row to return (starting with 1)</param>
		/// <returns>List of risks</returns>
		public List<RemoteRisk> Risk_Retrieve(RemoteCredentials credentials, int projectId, List<RemoteFilter> remoteFilters, RemoteSort remoteSort, int startingRow, int numberOfRows)
		{
			const string METHOD_NAME = "Risk_Retrieve";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure a sort object was provided (filters are optional)
			if (remoteSort == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_SortMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRisks);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Extract the filters from the provided API object
			Hashtable filters = PopulationFunctions.PopulateFilters(remoteFilters);

			//Call the business object to actually retrieve the risk dataset
			RiskManager riskManager = new RiskManager();
			List<RiskView> risks = riskManager.Risk_Retrieve(projectId, remoteSort.PropertyName, remoteSort.SortAscending, startingRow, numberOfRows, filters, 0);

			//Get the custom property definitions
			List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(projectTemplateId, Artifact.ArtifactTypeEnum.Risk, false);

			//Populate the API data object and return
			List<RemoteRisk> remoteRisks = new List<RemoteRisk>();
			foreach (RiskView risk in risks)
			{
				//Create and populate the row
				RemoteRisk remoteRisk = new RemoteRisk();
				PopulationFunctions.PopulateRisk(remoteRisk, risk);
				PopulationFunctions.PopulateCustomProperties(remoteRisk, risk, customProperties);
				remoteRisks.Add(remoteRisk);
			}

			Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
			Logger.Flush();
			return remoteRisks;
		}

		/// <summary>
		/// Retrieves all risks owned by the currently authenticated user
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>List of risks</returns>
		public List<RemoteRisk> Risk_RetrieveForOwner(RemoteCredentials credentials)
		{
			const string METHOD_NAME = "Risk_RetrieveForOwner";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//We assume if they are specified as owner, they have permissions since we can't easily
			//check cross-project permissions in one query
			try
			{
				//Call the business object to actually retrieve the risk dataset
				RiskManager riskManager = new RiskManager();
				List<RiskView> risks = riskManager.Risk_RetrieveOpenByOwnerId(userId, null, null);

				//Get the custom property definitions - for all projects
				List<CustomProperty> customProperties = new CustomPropertyManager().CustomPropertyDefinition_RetrieveForArtifactType(Artifact.ArtifactTypeEnum.Risk);

				//Populate the API data object and return
				List<RemoteRisk> remoteRisks = new List<RemoteRisk>();
				foreach (RiskView risk in risks)
				{
					//Create and populate the row
					RemoteRisk remoteRisk = new RemoteRisk();
					PopulationFunctions.PopulateRisk(remoteRisk, risk);
					PopulationFunctions.PopulateCustomProperties(remoteRisk, risk, customProperties);
					remoteRisks.Add(remoteRisk);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRisks;
			}
			catch (Exception exception)
			{
				//Log and convert to FaultException
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a single risk in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="riskId">The id of the risk</param>
		/// <returns>Risk object</returns>
		public RemoteRisk Risk_RetrieveById(RemoteCredentials credentials, int projectId, int riskId)
		{
			const string METHOD_NAME = "Risk_RetrieveById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRisks);
			}

			//Call the business object to actually retrieve the risk dataset
			RiskManager riskManager = new RiskManager();

			//If the risk was not found, just return null
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				RiskView risk = riskManager.Risk_RetrieveById2(riskId);
				if (risk == null)
				{
					return null;
				}

				//Make sure that the project ids match
				if (risk.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				ArtifactCustomProperty artifactCustomProperty = new CustomPropertyManager().ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, riskId, DataModel.Artifact.ArtifactTypeEnum.Risk, true);

				//Populate the API data object and return
				RemoteRisk remoteRisk = new RemoteRisk();
				PopulationFunctions.PopulateRisk(remoteRisk, risk);
				PopulationFunctions.PopulateCustomProperties(remoteRisk, artifactCustomProperty);

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRisk;
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested risk");
				Logger.Flush();
				return null;
			}
		}

		/// <summary>
		/// Updates a risk in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteRisk">The updated risk object</param>
		public void Risk_Update(RemoteCredentials credentials, RemoteRisk remoteRisk)
		{
			const string METHOD_NAME = "Risk_Update";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we have an risk id specified
			if (!remoteRisk.RiskId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("ArgumentMissing", Resources.Messages.Services_RiskIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteRisk.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to update risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedModifyRisks);
			}

			//First retrieve the existing datarow
			try
			{
				//Get the template associated with the project
				int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

				RiskManager riskManager = new RiskManager();
				CustomPropertyManager customPropertyManager = new CustomPropertyManager();
				Risk risk = riskManager.Risk_RetrieveById(remoteRisk.RiskId.Value);
				ArtifactCustomProperty artifactCustomProperty = customPropertyManager.ArtifactCustomProperty_RetrieveByArtifactId(projectId, projectTemplateId, remoteRisk.RiskId.Value, DataModel.Artifact.ArtifactTypeEnum.Risk, true);

				//Make sure that the project ids match
				if (risk.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Need to extract the data from the API data object and add to the artifact dataset and custom property dataset
				UpdateFunctions.UpdateRiskData(risk, remoteRisk, projectTemplateId);
				Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteRisk, remoteRisk.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Risk, remoteRisk.RiskId.Value, projectTemplateId);
				if (validationMessages != null && validationMessages.Count > 0)
				{
					//Throw a validation exception
					throw CreateValidationException(validationMessages);
				}

				//Get copies of everything..
				Artifact notificationArt = risk.Clone();
				ArtifactCustomProperty notificationCust = artifactCustomProperty.Clone();

				//Call the business object to actually update the risk dataset and the custom properties
				riskManager.Risk_Update(risk, userId);
				customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

				//Call notifications..
				try
				{
					new NotificationManager().SendNotificationForArtifact(notificationArt, notificationCust, null);
				}
				catch (Exception ex)
				{
					Logger.LogErrorEvent(METHOD_NAME, ex, "Sending message for Risk #" + risk.RiskId + ".");
				}
			}
			catch (DataValidationException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested risk");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Deletes a risk in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="riskId">The id of the risk</param>
		public void Risk_Delete(RemoteCredentials credentials, int projectId, int riskId)
		{
			const string METHOD_NAME = "Risk_Delete";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to delete risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.Delete))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedDeleteArtifactType);
			}

			//First retrieve the existing datarow
			try
			{
				RiskManager riskManager = new RiskManager();
				Risk risk = riskManager.Risk_RetrieveById(riskId);

				//Make sure that the project ids match
				if (risk.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Call the business object to actually mark the item as deleted
				riskManager.Risk_MarkAsDeleted(projectId, riskId, userId);
			}
			catch (OptimisticConcurrencyException exception)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, exception.Message);
				throw ConvertExceptions(exception);
			}
			catch (ArtifactNotExistsException)
			{
				Logger.LogWarningEvent(CLASS_NAME + METHOD_NAME, "Unable to locate requested risk");
				Logger.Flush();
			}
		}

		/// <summary>
		/// Creates a new risk in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteRisk">The new risk object (primary key will be empty)</param>
		/// <returns>The populated risk object - including the primary key</returns>
		public RemoteRisk Risk_Create(RemoteCredentials credentials, RemoteRisk remoteRisk)
		{
			const string METHOD_NAME = "Risk_Create";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure that we don't have an risk id specified
			if (remoteRisk.RiskId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("DataObjectPrimaryKeyNotNull", Resources.Messages.Services_RiskIdNotNull);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;
			int projectId = remoteRisk.ProjectId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to create risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.Create))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedCreateRisks);
			}

			//Get the template associated with the project
			int projectTemplateId = new TemplateManager().RetrieveForProject(projectId).ProjectTemplateId;

			//Always use the current project
			remoteRisk.ProjectId = projectId;

			int? riskStatusId = null;
			//If the remote artifact contains a status AND the template setting allows bulk edit of status, set the status, otherwise leave it null (so manager will use the default)
			if (remoteRisk.RiskStatusId.HasValue)
			{
				ProjectTemplateSettings projectTemplateSettings = new ProjectTemplateSettings(projectTemplateId);
				if (projectTemplateSettings.Workflow_BulkEditCanChangeStatus)
				{
					riskStatusId = remoteRisk.RiskStatusId.Value;
				}
			}

			//First insert the new risk record itself, capturing and populating the id
			RiskManager riskManager = new RiskManager();
			remoteRisk.RiskId = riskManager.Risk_Insert(
			   projectId,
			   remoteRisk.RiskStatusId,
			   remoteRisk.RiskTypeId,
			   remoteRisk.RiskProbabilityId,
			   remoteRisk.RiskImpactId,
			   remoteRisk.CreatorId,
			   remoteRisk.OwnerId,
			   remoteRisk.Name,
			   remoteRisk.Description,
			   remoteRisk.ReleaseId,
			   remoteRisk.ComponentId,
			   remoteRisk.CreationDate,
			   remoteRisk.ReviewDate,
			   remoteRisk.ClosedDate
			   );

			//Now we need to populate any custom properties
			CustomPropertyManager customPropertyManager = new CustomPropertyManager();
			ArtifactCustomProperty artifactCustomProperty = null;
			Dictionary<string, string> validationMessages = UpdateFunctions.UpdateCustomPropertyData(ref artifactCustomProperty, remoteRisk, remoteRisk.ProjectId, DataModel.Artifact.ArtifactTypeEnum.Risk, remoteRisk.RiskId.Value, projectTemplateId);
			if (validationMessages != null && validationMessages.Count > 0)
			{
				//Throw a validation exception
				throw CreateValidationException(validationMessages);
			}
			customPropertyManager.ArtifactCustomProperty_Save(artifactCustomProperty, userId);

			//Send a notification
			riskManager.Risk_SendCreationNotification(remoteRisk.RiskId.Value, artifactCustomProperty, null);

			//Finally return the populated risk object
			return remoteRisk;
		}

		/// <summary>Retrieves comments for a specified risk.</summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="RiskId">The ID of the risk to retrieve comments for.</param>
		/// <returns>An array of comments associated with the specified risk.</returns>
		public List<RemoteComment> Risk_RetrieveComments(RemoteCredentials credentials, int projectId, int RiskId)
		{
			List<RemoteComment> retList = new List<RemoteComment>();

			if (RiskId > 0)
			{
				retList = this.CommentRetrieve(credentials, projectId, RiskId, DataModel.Artifact.ArtifactTypeEnum.Risk);
			}

			return retList;
		}

		/// <summary>Creates a new comment for a risk.</summary>
		/// <param name="remoteComment">The remote comment.</param>
		/// <returns>The RemoteComment with the comment's new ID specified.</returns>
		public RemoteComment Risk_CreateComment(RemoteCredentials credentials, int projectId, RemoteComment remoteComment)
		{
			RemoteComment retComment = this.CreateComment(credentials, projectId, remoteComment, DataModel.Artifact.ArtifactTypeEnum.Risk);

			//Send Notification..
			//Pull the requirement.
			int tskNum = -1;
			try
			{
				Risk risk = new RiskManager().Risk_RetrieveById(remoteComment.ArtifactId, true);
				tskNum = risk.RiskId;
				if (risk != null)
					new NotificationManager().SendNotificationForArtifact(risk, null, remoteComment.Text);
			}
			catch (Exception ex)
			{
				Logger.LogErrorEvent(CLASS_NAME + "Risk_CreateComment()", ex, "Sending message for Risk #" + tskNum + ".");
			}

			return retComment;
		}

		/// <summary>
		/// Retrieves the list of risk statuses in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of risk statuses</returns>
		public List<RemoteRiskStatus> Risk_RetrieveStatuses(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Risk_RetrieveStatuses";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Call the business object to actually retrieve the risk statuses
			RiskManager riskManager = new RiskManager();

			try
			{
				List<RiskStatus> riskStati = riskManager.RiskStatus_Retrieve(projectTemplateId);

				//Populate the API data objects and return
				List<RemoteRiskStatus> remoteRiskStati = new List<RemoteRiskStatus>();
				foreach (RiskStatus riskStatus in riskStati)
				{
					RemoteRiskStatus remoteRiskStatus = new RemoteRiskStatus();
					PopulationFunctions.PopulateRiskStatus(remoteRiskStatus, riskStatus);
					remoteRiskStati.Add(remoteRiskStatus);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRiskStati;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of risk types in the system
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of risk types </returns>
		public List<RemoteRiskType> Risk_RetrieveTypes(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Risk_RetrieveTypes";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Call the business object to actually retrieve the risk types
			RiskManager riskManager = new RiskManager();
			RiskWorkflowManager workflowManager = new RiskWorkflowManager();

			try
			{
				List<RiskType> riskTypes = riskManager.RiskType_Retrieve(projectTemplateId);

				//Populate the API data objects and return
				List<RemoteRiskType> remoteRiskTypes = new List<RemoteRiskType>();
				foreach (RiskType riskType in riskTypes)
				{
					RemoteRiskType remoteRiskType = new RemoteRiskType();
					PopulationFunctions.PopulateRiskType(remoteRiskType, riskType);
					remoteRiskTypes.Add(remoteRiskType);

					//Also get the associated workflow for this project
					remoteRiskType.WorkflowId = workflowManager.Workflow_GetForRiskType(riskType.RiskTypeId);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRiskTypes;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of risk probabilities in the project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of risk probabilities </returns>
		public List<RemoteRiskProbability> Risk_RetrieveProbabilities(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Risk_RetrieveProbabilities";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Call the business object to actually retrieve the risk probabilities
			RiskManager riskManager = new RiskManager();

			try
			{
				List<RiskProbability> probabilities = riskManager.RiskProbability_Retrieve(projectTemplateId);

				//Populate the API data objects and return
				List<RemoteRiskProbability> remoteRiskProbabilities = new List<RemoteRiskProbability>();
				foreach (RiskProbability probability in probabilities)
				{
					RemoteRiskProbability remoteRiskProbability = new RemoteRiskProbability();
					PopulationFunctions.PopulateRiskProbability(remoteRiskProbability, probability);
					remoteRiskProbabilities.Add(remoteRiskProbability);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRiskProbabilities;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of risk impacts in the project template
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <returns>The list of risk impacts </returns>
		public List<RemoteRiskImpact> Risk_RetrieveImpacts(RemoteCredentials credentials, int projectTemplateId)
		{
			const string METHOD_NAME = "Risk_RetrieveImpacts";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			//Call the business object to actually retrieve the risk impacts
			RiskManager riskManager = new RiskManager();

			try
			{
				List<RiskImpact> impacts = riskManager.RiskImpact_Retrieve(projectTemplateId);

				//Populate the API data objects and return
				List<RemoteRiskImpact> remoteRiskImpacts = new List<RemoteRiskImpact>();
				foreach (RiskImpact impact in impacts)
				{
					RemoteRiskImpact remoteRiskImpact = new RemoteRiskImpact();
					PopulationFunctions.PopulateRiskImpact(remoteRiskImpact, impact);
					remoteRiskImpacts.Add(remoteRiskImpact);
				}

				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();
				return remoteRiskImpacts;
			}
			catch (Exception exception)
			{
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves the list of risk fields and their workflow status for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current risk type</param>
		/// <param name="currentStatusId">The current risk status</param>
		/// <returns>The list of risk fields</returns>
		public List<RemoteWorkflowField> Risk_RetrieveWorkflowFields(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "Risk_RetrieveWorkflowFields";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowField> retList = new List<RemoteWorkflowField>();

			//Get the workflow ID for the specified type.
			RiskWorkflowManager workflowManager = new RiskWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForRiskType(currentTypeId);

			//Pull fields.
			List<RiskWorkflowField> workflowFields = workflowManager.Workflow_RetrieveFieldStates(workflowId, currentStatusId);

			foreach (RiskWorkflowField workflowField in workflowFields)
			{
				RemoteWorkflowField remoteWorkflowField = new RemoteWorkflowField();
				PopulationFunctions.PopulateWorkflowField(remoteWorkflowField, workflowField);
				retList.Add(remoteWorkflowField);
			}

			return retList;
		}

		/// <summary>
		/// Will retrieve available transitions for the specied status ID for the currently logged-on user.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current risk type</param>
		/// <param name="currentStatusId">The current risk status</param>
		/// <param name="isCreator">Is the user the creator of the risk</param>
		/// <param name="isOwner">Is the user the owner of the risk</param>
		/// <returns>The list of workflow transitions</returns>
		public List<RemoteWorkflowTransition> Risk_RetrieveWorkflowTransitions(RemoteCredentials credentials, int projectId, int currentTypeId, int currentStatusId, bool isCreator, bool isOwner)
		{
			const string METHOD_NAME = "Risk_RetrieveWorkflowTransitions";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRisks);
			}

			List<RemoteWorkflowTransition> retList = new List<RemoteWorkflowTransition>();

			//Get the use's role in the project.
			ProjectUserView projectUser = new ProjectManager().RetrieveUserMembershipById(projectId, userId);
			if (projectUser == null)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}
			int roleId = projectUser.ProjectRoleId;

			//Get the workflow ID for the specified type.
			RiskWorkflowManager workflowManager = new RiskWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForRiskType(currentTypeId);

			List<RiskWorkflowTransition> workflowTransitions = workflowManager.WorkflowTransition_RetrieveByInputStatus(workflowId, currentStatusId, roleId, isCreator, isOwner);

			foreach (RiskWorkflowTransition transition in workflowTransitions)
			{
				RemoteWorkflowTransition wrkTransition = new RemoteWorkflowTransition();
				PopulationFunctions.PopulateWorkflowTransition(wrkTransition, transition);
				retList.Add(wrkTransition);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves the list of risk custom properties and their workflow state for a given type and status/step.
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="currentTypeId">The current risk type</param>
		/// <param name="currentStatusId">The current risk status</param>
		/// <returns>The list of risk custom property states</returns>
		public List<RemoteWorkflowCustomProperty> Risk_RetrieveWorkflowCustomProperties(RemoteCredentials credentials, int projectTemplateId, int currentTypeId, int currentStatusId)
		{
			const string METHOD_NAME = "Risk_RetrieveWorkflowCustomProperties";

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project template
			bool isAuthorized = new TemplateManager().IsAuthorizedToViewTemplate(credentials.UserId, projectTemplateId);
			if (!isAuthorized)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProjectTemplate", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProjectTemplate, projectTemplateId));
			}

			List<RemoteWorkflowCustomProperty> retList = new List<RemoteWorkflowCustomProperty>();

			//Get the workflow ID for the specified type.
			RiskWorkflowManager workflowManager = new RiskWorkflowManager();
			int workflowId = workflowManager.Workflow_GetForRiskType(currentTypeId);

			//Pull custom properties
			List<RiskWorkflowCustomProperty> workflowCustomProperties = workflowManager.Workflow_RetrieveCustomPropertyStates(workflowId, currentStatusId);

			foreach (RiskWorkflowCustomProperty workflowCustomProperty in workflowCustomProperties)
			{
				RemoteWorkflowCustomProperty remoteWorkflowCustomProperty = new RemoteWorkflowCustomProperty();
				PopulationFunctions.PopulateWorkflowCustomProperty(remoteWorkflowCustomProperty, workflowCustomProperty);
				retList.Add(remoteWorkflowCustomProperty);
			}

			return retList;
		}

		/// <summary>
		/// Retrieves a list of risk mitigations
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="riskId">The id of the risk</param>
		/// <returns>The list of mitigations</returns>
		public List<RemoteRiskMitigation> Risk_RetrieveMitigations(RemoteCredentials credentials, int projectId, int riskId)
		{
			const string METHOD_NAME = "Risk_RetrieveMitigations";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRisks);
			}

			try
			{
				RiskManager riskManager = new RiskManager();
				RiskView risk = riskManager.Risk_RetrieveById2(riskId);

				//Make sure that the project ids match
				if (risk.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the risk mitigations
				List<RiskMitigation> riskMitigations = riskManager.RiskMitigation_Retrieve(riskId);
				List<RemoteRiskMitigation> remoteRiskMitigations = new List<RemoteRiskMitigation>();
				foreach (RiskMitigation riskMitigation in riskMitigations)
				{
					RemoteRiskMitigation remoteRiskMitigation = new RemoteRiskMitigation();
					PopulationFunctions.PopulateRiskMitigation(remoteRiskMitigation, riskMitigation);
					remoteRiskMitigations.Add(remoteRiskMitigation);
				}

				return remoteRiskMitigations;
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Retrieves a single risk mitigation by its ID
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="riskMitigationId">The id of the risk mitigation</param>
		/// <returns>The risk mitigation</returns>
		public RemoteRiskMitigation Risk_RetrieveMitigationById(RemoteCredentials credentials, int projectId, int riskMitigationId)
		{
			const string METHOD_NAME = "Risk_RetrieveMitigationById";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to view risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.View))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRisks);
			}

			try
			{
				//Get the risk mitigation with risk/project info
				RiskManager riskManager = new RiskManager();
				RiskMitigation riskMitigation = riskManager.RiskMitigation_RetrieveById(riskMitigationId, false, true);
				if (riskMitigation == null)
				{
					return null;
				}

				//Make sure that the project ids match
				if (riskMitigation.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Populate the risk mitigation
				RemoteRiskMitigation remoteRiskMitigation = new RemoteRiskMitigation();
				PopulationFunctions.PopulateRiskMitigation(remoteRiskMitigation, riskMitigation);

				return remoteRiskMitigation;
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Adds a risk mitigation to a risk
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteRiskMitigation">The new mitigation to add</param>
		/// <param name="existingRiskMitigationId">The id of the existing mitigation to insert before (null = end of the list)</param>
		/// <param name="creatorId">The id of the user adding the mitigation (null = use authenticated user)</param>
		/// <returns>The mitigation with the id added</returns>
		public RemoteRiskMitigation Risk_AddMitigation(RemoteCredentials credentials, int projectId, RemoteRiskMitigation remoteRiskMitigation, int? existingRiskMitigationId, int? creatorId)
		{
			const string METHOD_NAME = "Risk_AddMitigation";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to modify risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRisks);
			}

			try
			{
				RiskManager riskManager = new RiskManager();
				RiskView risk = riskManager.Risk_RetrieveById2(remoteRiskMitigation.RiskId);

				//Make sure that the project ids match
				if (risk.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Now add the mitigation
				remoteRiskMitigation.RiskMitigationId = riskManager.RiskMitigation_Insert(
					projectId,
					remoteRiskMitigation.RiskId,
					existingRiskMitigationId,
					remoteRiskMitigation.Description,
					(creatorId.HasValue) ? creatorId.Value : userId,
					remoteRiskMitigation.CreationDate,
					remoteRiskMitigation.ReviewDate
					);

				//Return object
				return remoteRiskMitigation;
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Updates an existing risk mitigation
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="remoteRiskMitigation">The mitigation to update</param>
		public void Risk_UpdateMitigation(RemoteCredentials credentials, int projectId, RemoteRiskMitigation remoteRiskMitigation)
		{
			const string METHOD_NAME = "Risk_UpdateMitigation";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure the id is populated
			if (!remoteRiskMitigation.RiskMitigationId.HasValue)
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("RiskMitigationIdMissing", Resources.Messages.Services_RiskMitigationIdMissing);
			}

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to modify risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRisks);
			}

			try
			{
				RiskManager riskManager = new RiskManager();
				RiskView risk = riskManager.Risk_RetrieveById2(remoteRiskMitigation.RiskId);

				//Make sure that the project ids match
				if (risk.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Now retrieve the mitigation and update
				RiskMitigation riskMitigation = riskManager.RiskMitigation_RetrieveById(remoteRiskMitigation.RiskMitigationId.Value);
				if (riskMitigation != null && riskMitigation.RiskId == risk.RiskId)
				{
					//Set the concurrency date
					riskMitigation.ConcurrencyDate = remoteRiskMitigation.ConcurrencyDate;

					riskMitigation.StartTracking();
					riskMitigation.Description = remoteRiskMitigation.Description;
					riskMitigation.ReviewDate = remoteRiskMitigation.ReviewDate;
					riskMitigation.LastUpdateDate = DateTime.UtcNow;
					riskMitigation.ConcurrencyDate = DateTime.UtcNow;
					riskMitigation.IsActive = remoteRiskMitigation.IsActive;
					riskManager.RiskMitigation_Update(projectId, riskMitigation, userId);
				}
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		/// <summary>
		/// Deletes a risk mitigation in the list
		/// </summary>
		/// <param name="credentials">The API credentials</param>
		/// <param name="projectId">The ID of the project</param>
		/// <param name="projectTemplateId">The ID of the project template</param>
		/// <param name="riskId">The id of the risk</param>
		/// <param name="riskMitigationId">The id of the mitigation to delete</param>
		public void Risk_DeleteMitigation(RemoteCredentials credentials, int projectId, int riskId, int riskMitigationId)
		{
			const string METHOD_NAME = "Risk_DeleteMitigation";

			Logger.LogEnteringEvent(CLASS_NAME + METHOD_NAME);

			//Make sure we have an authenticated user
			if (!IsAuthenticated(credentials))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("SessionNotAuthenticated", Resources.Messages.Services_SessionNotAuthenticated);
			}
			int userId = credentials.UserId;

			//Make sure we are connected to a project
			if (!IsAuthorized(credentials, projectId))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("NotConnectedToProject", String.Format(Resources.Messages.WebPartBase_NotAuthorizedForProject, projectId));
			}


			//Make sure we have permissions to modify risks
			if (!IsAuthorized(credentials, projectId, DataModel.Artifact.ArtifactTypeEnum.Risk, Project.PermissionEnum.Modify))
			{
				//Throw back an exception
				Logger.LogExitingEvent(CLASS_NAME + METHOD_NAME);
				Logger.Flush();

				throw CreateFault("AuthorizationViolation", Resources.Messages.Services_NotAuthorizedViewRisks);
			}

			try
			{
				RiskManager riskManager = new RiskManager();
				RiskView risk = riskManager.Risk_RetrieveById2(riskId);

				//Make sure that the test case is in the authorized project
				if (risk.ProjectId != projectId)
				{
					throw CreateFault("ItemNotBelongToProject", Resources.Messages.Services_ItemNotBelongToProject);
				}

				//Get the list of test mitigations
				List<RiskMitigation> riskMitigations = riskManager.RiskMitigation_Retrieve(riskId);

				//Make sure the mitigation is in the risk, otherwise ignore
				if (riskMitigations.Any(r => r.RiskMitigationId == riskMitigationId))
				{
					//Call the business object to actually perform the delete
					riskManager.RiskMitigation_Delete(projectId, riskMitigationId, userId);
				}
			}
			catch (Exception exception)
			{
				//Convert into a SOAP exception and throw
				Logger.LogErrorEvent(CLASS_NAME + METHOD_NAME, exception);
				throw ConvertExceptions(exception);
			}
		}

		#endregion
	}
}
