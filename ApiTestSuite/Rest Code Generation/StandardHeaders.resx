<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Accept" xml:space="preserve">
    <value>Accept</value>
    <comment>Content-Types that are acceptable</comment>
  </data>
  <data name="Accept_Charset" xml:space="preserve">
    <value>Accept-Charset</value>
    <comment>Character sets that are acceptable</comment>
  </data>
  <data name="Accept_Datetime" xml:space="preserve">
    <value>Accept-Datetime</value>
    <comment>Acceptable version in time</comment>
  </data>
  <data name="Accept_Encoding" xml:space="preserve">
    <value>Accept-Encoding</value>
    <comment>Acceptable encodings. See HTTP compression.</comment>
  </data>
  <data name="Accept_Language" xml:space="preserve">
    <value>Accept-Language</value>
    <comment>Acceptable human languages for response</comment>
  </data>
  <data name="Access_Control_Allow_Methods" xml:space="preserve">
    <value>Access-Control-Allow-Methods</value>
    <comment>CORS response allowed methods</comment>
  </data>
  <data name="Access_Control_Allow_Origin" xml:space="preserve">
    <value>Access-Control-Allow-Origin</value>
    <comment>CORS response origin</comment>
  </data>
  <data name="Access_Control_Max_Age" xml:space="preserve">
    <value>Access-Control-Max-Age</value>
    <comment>CORS response maximum age</comment>
  </data>
  <data name="Access_Control_Request_Headers" xml:space="preserve">
    <value>Access-Control-Request-Headers</value>
    <comment>CORS request headers</comment>
  </data>
  <data name="Access_Control_Request_Method" xml:space="preserve">
    <value>Access-Control-Request-Method</value>
    <comment>CORS request method</comment>
  </data>
  <data name="Authorization" xml:space="preserve">
    <value>Authorization</value>
    <comment>Authentication credentials for HTTP authentication</comment>
  </data>
  <data name="Cache_Control" xml:space="preserve">
    <value>Cache-Control</value>
    <comment>Used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain</comment>
  </data>
  <data name="Connection" xml:space="preserve">
    <value>Connection</value>
    <comment>What type of connection the user-agent would prefer</comment>
  </data>
  <data name="Content_Length" xml:space="preserve">
    <value>Content-Length</value>
    <comment>The length of the request body in octets (8-bit bytes)</comment>
  </data>
  <data name="Content_MD5" xml:space="preserve">
    <value>Content-MD5</value>
    <comment>A Base64-encoded binary MD5 sum of the content of the request body</comment>
  </data>
  <data name="Content_Type" xml:space="preserve">
    <value>Content-Type</value>
    <comment>The MIME type of the body of the request (used with POST and PUT requests)</comment>
  </data>
  <data name="Cookie" xml:space="preserve">
    <value>Cookie</value>
    <comment>an HTTP cookie previously sent by the server with Set-Cookie (below)</comment>
  </data>
  <data name="Date" xml:space="preserve">
    <value>Date</value>
    <comment>The date and time that the message was sent</comment>
  </data>
  <data name="Expect" xml:space="preserve">
    <value>Expect</value>
    <comment>Indicates that particular server behaviors are required by the client</comment>
  </data>
  <data name="From" xml:space="preserve">
    <value>From</value>
    <comment>The email address of the user making the request</comment>
  </data>
  <data name="Host" xml:space="preserve">
    <value>Host</value>
    <comment>The domain name of the server (for virtual hosting), and the TCP port number on which the server is listening. The port number may be omitted if the port is the standard port for the service requested.[5] Mandatory since HTTP/1.1. Although domain name are specified as case-insensitive,[6][7] it is not specified whether the contents of the Host field should be interpreted in a case-insensitive manner[8] and in practice some implementations of virtual hosting interpret the contents of the Host field in a case-sensitive manner.[citation needed]</comment>
  </data>
  <data name="If_Match" xml:space="preserve">
    <value>If-Match</value>
    <comment>Only perform the action if the client supplied entity matches the same entity on the server. This is mainly for methods like PUT to only update a resource if it has not been modified since the user last updated it.</comment>
  </data>
  <data name="If_Modified_Since" xml:space="preserve">
    <value>If-Modified-Since</value>
    <comment>Allows a 304 Not Modified to be returned if content is unchanged</comment>
  </data>
  <data name="If_None_Match" xml:space="preserve">
    <value>If-None-Match</value>
    <comment>Allows a 304 Not Modified to be returned if content is unchanged, see HTTP ETag</comment>
  </data>
  <data name="If_Range" xml:space="preserve">
    <value>If-Range</value>
    <comment>If the entity is unchanged, send me the part(s) that I am missing; otherwise, send me the entire new entity</comment>
  </data>
  <data name="If_Unmodified_Since" xml:space="preserve">
    <value>If-Unmodified-Since</value>
    <comment>Only send the response if the entity has not been modified since a specific time.</comment>
  </data>
  <data name="Max_Forwards" xml:space="preserve">
    <value>Max-Forwards</value>
    <comment>Limit the number of times the message can be forwarded through proxies or gateways.</comment>
  </data>
  <data name="Origin" xml:space="preserve">
    <value>Origin</value>
    <comment>CORS request origin</comment>
  </data>
  <data name="Pragma" xml:space="preserve">
    <value>Pragma</value>
    <comment>Implementation-specific headers that may have various effects anywhere along the request-response chain.</comment>
  </data>
  <data name="Proxy_Authorization" xml:space="preserve">
    <value>Proxy-Authorization</value>
    <comment>Authorization credentials for connecting to a proxy.</comment>
  </data>
  <data name="Range" xml:space="preserve">
    <value>Range</value>
    <comment>Request only part of an entity. Bytes are numbered from 0.</comment>
  </data>
  <data name="Referer_Sic" xml:space="preserve">
    <value>Referer[sic]</value>
    <comment>This is the address of the previous web page from which a link to the currently requested page was followed. (The word “referrer” is misspelled in the RFC as well as in most implementations.)</comment>
  </data>
  <data name="TE" xml:space="preserve">
    <value>TE</value>
    <comment>The transfer encodings the user agent is willing to accept: the same values as for the response header Transfer-Encoding can be used, plus the "trailers" value (related to the "chunked" transfer method) to notify the server it expects to receive additional headers (the trailers) after the last, zero-sized, chunk.</comment>
  </data>
  <data name="Upgrade" xml:space="preserve">
    <value>Upgrade</value>
    <comment>Ask the server to upgrade to another protocol.</comment>
  </data>
  <data name="User_Agent" xml:space="preserve">
    <value>User-Agent</value>
    <comment>The user agent string of the user agent</comment>
  </data>
  <data name="Via" xml:space="preserve">
    <value>Via</value>
    <comment>Informs the server of proxies through which the request was sent.</comment>
  </data>
  <data name="Warning" xml:space="preserve">
    <value>Warning</value>
    <comment>A general warning about possible problems with the entity body.</comment>
  </data>
</root>