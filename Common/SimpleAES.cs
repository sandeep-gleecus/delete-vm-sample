using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Inflectra.SpiraTest.Common
{
	/// <summary>
	/// Simple AES for encrypting Spira licenses and other passwords
	/// </summary>
	public class SimpleAES
	{
		/// <summary>The encrypting Key. 32 randomly-generated bytes.</summary>
		private static readonly byte[] Key = { 174, 191, 1, 3, 211, 207, 202, 14, 124, 168, 5, 61, 80, 51, 26, 162, 98, 91, 213, 123, 37, 57, 167, 11, 206, 9, 31, 192, 62, 186, 64, 251 }; // [OnShore to replace]
		/// <summary>The encrypting value. 16 randomly-generated bytes.</summary>
		private static readonly byte[] Vector = { 161, 173, 42, 125, 237, 222, 164, 194, 233, 140, 117, 2, 73, 155, 88, 134 }; // [OnShore to replace]

		private ICryptoTransform EncryptorTransform, DecryptorTransform;
		private UTF8Encoding UTFEncoder;

		/// <summary>Create an instance of this class using the default Key/Vector.</summary>
		public SimpleAES() : this(Key, Vector) { }

		/// <summary>Create an instance with the given Key and Vector values.</summary>
		/// <param name="key">The encrypting Key.</param>
		/// <param name="vector">The encrypting Value.</param>
		public SimpleAES(byte[] key, byte[] vector)
		{
			//This is our encryption method
			if (CryptoConfig.AllowOnlyFipsAlgorithms)
			{
				AesCryptoServiceProvider aes = new AesCryptoServiceProvider();

				//Create an encryptor and a decryptor using our encryption method, key, and vector.
				EncryptorTransform = aes.CreateEncryptor(key, vector);
				DecryptorTransform = aes.CreateDecryptor(key, vector);

				//Used to translate bytes to text and vice versa
				UTFEncoder = new UTF8Encoding();
			}
			else
			{
				RijndaelManaged rm = new RijndaelManaged();

				//Create an encryptor and a decryptor using our encryption method, key, and vector.
				EncryptorTransform = rm.CreateEncryptor(key, vector);
				DecryptorTransform = rm.CreateDecryptor(key, vector);

				//Used to translate bytes to text and vice versa
				UTFEncoder = new UTF8Encoding();
			}
		}

		/// -------------- Two Utility Methods (not used but may be useful) -----------
		/// Generates an encryption key.
		static public byte[] GenerateEncryptionKey()
		{
			//Generate a Key.
			if (CryptoConfig.AllowOnlyFipsAlgorithms)
			{
				AesCryptoServiceProvider aes = new AesCryptoServiceProvider();
				aes.GenerateKey();
				return aes.Key;
			}
			else
			{
				RijndaelManaged rm = new RijndaelManaged();
				rm.GenerateKey();
				return rm.Key;
			}
		}

		/// Generates a unique encryption vector
		static public byte[] GenerateEncryptionVector()
		{
			//Generate a Vector
			if (CryptoConfig.AllowOnlyFipsAlgorithms)
			{
				AesCryptoServiceProvider aes = new AesCryptoServiceProvider();
				aes.GenerateIV();
				return aes.IV;
			}
			else
			{
				RijndaelManaged rm = new RijndaelManaged();
				rm.GenerateIV();
				return rm.IV;
			}
		}


		/// ----------- The commonly used methods ------------------------------    
		/// Encrypt some text and return a string suitable for passing in a URL.
		public string EncryptToString(string textValue)
		{
			return ByteArrToString(Encrypt(textValue));
		}
		public string EncryptToBase64String(string textValue)
		{
			return ByteArrToBase64String(Encrypt(textValue));
		}

		/// Encrypt some text and return an encrypted byte array.
		public byte[] Encrypt(string TextValue)
		{
			//Translates our text value into a byte array.
			byte[] bytes = UTFEncoder.GetBytes(TextValue);

			//Used to stream the data in and out of the CryptoStream.
			MemoryStream memoryStream = new MemoryStream();

			/*
             * We will have to write the unencrypted bytes to the stream,
             * then read the encrypted result back from the stream.
             */
			#region Write the decrypted value to the encryption stream
			CryptoStream cs = new CryptoStream(memoryStream, EncryptorTransform, CryptoStreamMode.Write);
			cs.Write(bytes, 0, bytes.Length);
			cs.FlushFinalBlock();
			#endregion

			#region Read encrypted value back out of the stream
			memoryStream.Position = 0;
			byte[] encrypted = new byte[memoryStream.Length];
			memoryStream.Read(encrypted, 0, encrypted.Length);
			#endregion

			//Clean up.
			cs.Close();
			memoryStream.Close();

			return encrypted;
		}

		/// The other side: Decryption methods
		public string DecryptString(string encryptedString)
		{
			return Decrypt(StrToByteArray(encryptedString));
		}
		public string DecryptBase64String(string encryptedString)
		{
			return Decrypt(Base64StrToByteArray(encryptedString));
		}

		/// <summary>
		/// Decryption when working with byte arrays.    
		/// </summary>
		/// <param name="EncryptedValue"></param>
		/// <returns></returns>
		public string Decrypt(byte[] EncryptedValue)
		{
			#region Write the encrypted value to the decryption stream
			MemoryStream encryptedStream = new MemoryStream();
			CryptoStream decryptStream = new CryptoStream(encryptedStream, DecryptorTransform, CryptoStreamMode.Write);
			decryptStream.Write(EncryptedValue, 0, EncryptedValue.Length);
			decryptStream.FlushFinalBlock();
			#endregion

			#region Read the decrypted value from the stream.
			encryptedStream.Position = 0;
			byte[] decryptedBytes = new byte[encryptedStream.Length];
			encryptedStream.Read(decryptedBytes, 0, decryptedBytes.Length);
			encryptedStream.Close();
			#endregion
			return UTFEncoder.GetString(decryptedBytes);
		}


		/// <summary>
		/// Convert a string to a byte array.  NOTE: Normally we'd create a Byte Array from a string using an ASCII encoding (like so).
		///   System.Text.ASCIIEncoding encoding = new System.Text.ASCIIEncoding();
		///   return encoding.GetBytes(str);
		/// However, this results in character values that cannot be passed in a URL.  So, instead, I just
		/// lay out all of the byte values in a long string of numbers (three per - must pad numbers less than 100).
		/// </summary>
		/// <param name="str"></param>
		/// <returns></returns>
		public byte[] StrToByteArray(string str)
		{
			if (str.Length == 0)
				throw new Exception("Invalid string value in StrToByteArray");

			byte val;
			byte[] byteArr = new byte[str.Length / 3];
			int i = 0;
			int j = 0;
			do
			{
				val = byte.Parse(str.Substring(i, 3));
				byteArr[j++] = val;
				i += 3;
			}
			while (i < str.Length);
			return byteArr;
		}

		/// Convert a string to a byte array.  Assumes base64 encoding
		public byte[] Base64StrToByteArray(string str)
		{
			if (str.Length == 0)
				throw new Exception("Invalid string value in StrToByteArray");
			byte[] byteArr = System.Convert.FromBase64String(str);
			return byteArr;
		}

		// Same comment as above.  Normally the conversion would use an ASCII encoding in the other direction:
		//      System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();
		//      return enc.GetString(byteArr);    
		public string ByteArrToString(byte[] byteArr)
		{
			byte val;
			string tempStr = "";
			for (int i = 0; i <= byteArr.GetUpperBound(0); i++)
			{
				val = byteArr[i];
				if (val < 10)
					tempStr += "00" + val.ToString();
				else if (val < 100)
					tempStr += "0" + val.ToString();
				else
					tempStr += val.ToString();
			}
			return tempStr;
		}

		/// <summary>
		/// Convert to a simple base 64 string
		/// </summary>
		/// <param name="byteArr"></param>
		/// <returns></returns>
		public string ByteArrToBase64String(byte[] byteArr)
		{
			//Handle empty case
			if (byteArr.Length == 0)
			{
				return "";
			}
			return System.Convert.ToBase64String(byteArr);
		}
	}
}
