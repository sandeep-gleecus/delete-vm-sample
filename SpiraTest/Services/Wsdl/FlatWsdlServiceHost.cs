using System;
using System.Collections.Generic;
using System.Text;
using System.ServiceModel;
using System.ServiceModel.Description;
using Inflectra.SpiraTest.Common;
using System.Web;
using Inflectra.SpiraTest.Web.Services.Utils;

namespace Inflectra.SpiraTest.Web.Services.Wsdl
{
    /// <summary>
    /// Modifies the WSDL generated by the WCF service to be a single file without imports so that it's easier to consume
    /// by older clients. Also this service host dynamically generates the appropriate endpoints dynamically
    /// </summary>
    /// <remarks>
    /// Reduces the amount of configuration needed in Web.Config and avoids need to manually
    /// create separate HTTP and HTTPS binding endpoints for each service
    /// </remarks>
    public class FlatWsdlServiceHost : ServiceHost
    {
        private const string CLASS_NAME = "FlatWsdlServiceHost";

        /// <summary>
        /// Constructor
        /// </summary>
        public FlatWsdlServiceHost()
        {
        }

        /// <summary>
        /// Constructor
        /// </summary>
        public FlatWsdlServiceHost(Type serviceType, params Uri[] baseAddresses)
            :
            base(serviceType, baseAddresses)
        {
        }

        /// <summary>
        /// Constructor
        /// </summary>
        public FlatWsdlServiceHost(object singeltonInstance, params Uri[] baseAddresses)
            :
            base(singeltonInstance, baseAddresses)
        {
        }

        /// <summary>
        /// Configures the WCF service
        /// </summary>
        protected override void ApplyConfiguration()
        {
            bool httpBaseAddressAvailable, httpsBaseAddressAvailable;

            base.ApplyConfiguration();
            CreateEndPoints(out httpBaseAddressAvailable, out httpsBaseAddressAvailable);
            SpecifyServiceBehaviors(httpBaseAddressAvailable, httpsBaseAddressAvailable);
            InjectFlatWsdlExtension();
        }

        /// <summary>
        /// Specify the service behavior. Easier to do it here than in the web.config file
        /// </summary>
        /// <param name="httpBaseAddressAvailable">Is there a HTTP base address available</param>
        /// <param name="httpsBaseAddressAvailable">Is there a HTTPS base address available</param>
        private void SpecifyServiceBehaviors(bool httpBaseAddressAvailable, bool httpsBaseAddressAvailable)
        {
            //<dataContractSerializer maxItemsInObjectGraph="2147483647" />
            ContractDescription contract = ContractDescription.GetContract(this.Description.ServiceType);
            foreach (OperationDescription operationDescription in contract.Operations)
            {
                DataContractSerializerOperationBehavior dataContractSerializer = operationDescription.Behaviors.Find<DataContractSerializerOperationBehavior>();
                if (dataContractSerializer == null)
                {
                    dataContractSerializer = new DataContractSerializerOperationBehavior(operationDescription);
                    operationDescription.Behaviors.Add(dataContractSerializer);
                }
                dataContractSerializer.MaxItemsInObjectGraph = Int32.MaxValue;
            }

            //Dynamically enable HTTP/HTTPS get based on the available base addresses
            //<serviceMetadata httpGetEnabled="?" httpsGetEnabled="?" />
            ServiceMetadataBehavior serviceMetaData = this.Description.Behaviors.Find<ServiceMetadataBehavior>();
            if (serviceMetaData == null)
            {
                serviceMetaData = new ServiceMetadataBehavior();
                this.Description.Behaviors.Add(serviceMetaData);
            }

			//Add an API throttle if specified
			if (Common.ConfigurationSettings.Default.Api_MaxConcurrentCallsThrottle > 0)
			{
				ServiceThrottlingBehavior serviceThrottlingBehavior = new ServiceThrottlingBehavior();
				serviceThrottlingBehavior.MaxConcurrentCalls = Common.ConfigurationSettings.Default.Api_MaxConcurrentCallsThrottle;
				this.Description.Behaviors.Add(serviceThrottlingBehavior);
			}

			//We dynamically set these based on the available base addresses
			serviceMetaData.HttpGetEnabled = httpBaseAddressAvailable;
            serviceMetaData.HttpsGetEnabled = httpsBaseAddressAvailable;

            //<serviceDebug includeExceptionDetailInFaults="true" />
            ServiceDebugBehavior serviceDebug = this.Description.Behaviors.Find<ServiceDebugBehavior>();
            if (serviceDebug == null)
            {
                serviceDebug = new ServiceDebugBehavior();
                this.Description.Behaviors.Add(serviceDebug);
            }
            serviceDebug.IncludeExceptionDetailInFaults = true;
        }

        /// <summary>
        /// Dynamically create the appropriate endpoint for HTTP or HTTPS
        /// <param name="httpBaseAddressAvailable">Do we have an HTTP base address</param>
        /// <param name="httpBaseAddressAvailable">Do we have an HTTPS base address</param>
        /// </summary>
        private void CreateEndPoints(out bool httpBaseAddressAvailable, out bool httpsBaseAddressAvailable)
        {
            const string METHOD_NAME = "CreateEndPoints";

            //Create the endpoint behavior for the API web services using SOAP 1.1 - i.e. basic Http Binding

            // Create the endpoint based on the service name and the binding derived from the scheme name
            ContractDescription contract = ContractDescription.GetContract(this.Description.ServiceType);
            httpBaseAddressAvailable = false;
            httpsBaseAddressAvailable = false;
            foreach (Uri address in this.BaseAddresses)
            {
                Logger.LogTraceEvent(CLASS_NAME + METHOD_NAME, "Creating an endpoint for contract " + contract.Name + " and address " + address.AbsoluteUri);

                //Create the appropriate web binding for the URL scheme (http/https)
                BasicHttpBinding binding = new BasicHttpBinding();
                binding.MaxReceivedMessageSize = Int32.MaxValue;
                binding.AllowCookies = true;
                binding.MaxBufferSize = Int32.MaxValue;
                binding.MaxBufferPoolSize = Int32.MaxValue;
                binding.CloseTimeout = new TimeSpan(0, 0, 1, 0, 0);   //1 minute
                binding.OpenTimeout = new TimeSpan(0, 0, 1, 0, 0);   //1 minute
                binding.ReceiveTimeout = new TimeSpan(0, 0, 10, 0, 0);   //10 minutes
                binding.SendTimeout = new TimeSpan(0, 0, 10, 0, 0);   //10 minutes
                if (address.Scheme.ToLowerInvariant() == "https")
                {
                    binding.Security.Mode = BasicHttpSecurityMode.Transport;
                    binding.Security.Transport.ClientCredentialType = HttpClientCredentialType.None;
                    httpsBaseAddressAvailable = true;
                }
                else
                {
                    binding.Security.Mode = BasicHttpSecurityMode.None;
                    httpBaseAddressAvailable = true;
                }

                //Set the reader quotas to unlimited
                binding.ReaderQuotas.MaxArrayLength = Int32.MaxValue;
                binding.ReaderQuotas.MaxBytesPerRead = Int32.MaxValue;
                binding.ReaderQuotas.MaxDepth = Int32.MaxValue;
                binding.ReaderQuotas.MaxNameTableCharCount = Int32.MaxValue;
                binding.ReaderQuotas.MaxStringContentLength = Int32.MaxValue;

                //Add the behavior to set the culture to the one specified in SpiraTest
                LocalizationEndpointBehavior localizationEndpointBehavior = new LocalizationEndpointBehavior(true);

                //Create the endpoint and configure its binding namespace to match the service namespace
                binding.Namespace = this.Description.Namespace;
                ServiceEndpoint serviceEndpoint = new ServiceEndpoint(contract, binding, new EndpointAddress(address));
                serviceEndpoint.Behaviors.Add(localizationEndpointBehavior);

                //Add the endpoint
                this.Description.Endpoints.Add(serviceEndpoint);
            }
        }

        /// <summary>
        /// Configure the WSDL generation for the endpoints
        /// </summary>
        private void InjectFlatWsdlExtension()
        {
            foreach (ServiceEndpoint endpoint in this.Description.Endpoints)
            {
                WsdlExtensionsConfig config = new WsdlExtensionsConfig();
                config.SingleFile = true;
                //See if we have an override URL to use in the WSDL
                string customBaseUrl = Common.Properties.Settings.Default.WcfBaseUrl;
                if (!String.IsNullOrEmpty(customBaseUrl))
                {
                    //Add on the service URL to the base URI
                    //We need to get the part of the service afer the host name and app-path
                    string vdir = HttpContext.Current.Request.ApplicationPath;
                    string serviceUrl;
                    if (vdir == "/")
                    {
                        serviceUrl = customBaseUrl + endpoint.Address.Uri.PathAndQuery;
                    }
                    else
                    {
                        serviceUrl = endpoint.Address.Uri.PathAndQuery.Replace(vdir, customBaseUrl);
                    }
                    config.Location = new Uri(serviceUrl);
                }
                endpoint.Behaviors.Add(new WsdlExtensions(config));
            }
        }
    }
}


